#define TECPLOTENGINEMODULE
/*
USAGE:
-----------------------------------------------------------------------
This source code, in part or whole may be used without permission
from Tecplot, Inc.  Modification is encouraged however we
do ask that you report any changes to Tecplot Support (support@tecplot.com) 
so that the master copy can be updated.  For information on compiling
see below.
-----------------------------------------------------------------------

SYNTAX:
-----------------------------------------------------------------------
The command line syntax can be generated by typing:

  preplot <Cr>
-----------------------------------------------------------------------

BINARY FILE FORMAT:
-----------------------------------------------------------------------
The binary Datafile format (as produced by the preplot) is
described below.


The binary datafile has two main sections.  A header section and a data
section.


         +----------------+
         | HEADER SECTION |
         +----------------+
         +---------+
         |FLOAT32  |              EOHMARKER, value=357.0
         +---------+
         +----------------+
         | DATA SECTION   |
         +----------------+




I.  HEADER SECTION

    The header section contains The version number of the file, a title
    of the file, the names of the varialles to be plotted, the
    descriptions of all zones to be read in and all text and geometry
    definitions.

     i.  Magic number, Version number
         +-----------+
         | "#!TDV108"|       8 Bytes, exact characters "#!TDV108".
         +-----------+       Version number follows the "V" and
                             consumes the next 3 characters (for
                             example: "V75 ", "V101").

     ii. Integer value of 1.
         +-----------+
         | INT32     |       This is used to determine the byte order
         +-----------+       of the reader relative to the writer.



     iii. Title and variable names.
         +-----------+
         | INT32*N   |       The TITLE. (See note 1.)
         +-----------+
         +-----------+
         | INT32     |       Number of variables (NumVar) in the datafile.
         +-----------+
         +-----------+
         | INT32*N   |       Variable names.  N =  L[1] + L[2] + .... L[NumVar]
         +-----------+       where:
                                    L[i] = length of the ith variable name + 1
                                           (for the terminating 0 value).
                             (See note 1.)
     iv.  Zones
         +-----------+
         | FLOAT32   |       Zone marker. Value = 299.0
         +-----------+
         +-----------+
         | INT32*N   |       Zone name. (See note 1.) N = length of zone name + 1.
         +-----------+
         +-----------+
         | INT32     |       ParentZone: Zero based zone number within this datafile
         +-----------+                   to which this zone is a child.
         +-----------+
         | INT32     |       StrandID: -2 = pending strand ID for assignment by Tecplot,
         +-----------+                 -1 = static strand ID
                                        0 <= N < 32700 valid strand ID
         +-----------+
         | FLOAT64   |       Solution time.
         +-----------+
         +-----------+
         | INT32     |       Zone Color (set to -1 if you want tecplot to
         +-----------+       determine).
         +-----------+
         | INT32     |       ZoneType 0=ORDERED,1=FELINESEG,2=FETRIANGLE,
         +-----------+                3=FEQUADRILATERAL,4=FETETRAHEDRON,5=FEBRICK
         +-----------+
         | INT32     |       DataPacking 0=Block, 1=Point
         +-----------+               
         +-----------+
         | INT32     |       Specify Var Location.  0 = Don't specify, all data is 
         +-----------+       located at the nodes.  1 = Specify
         if "specify var location" == 1
           +-----------+
           | INT32*NV  |     Variable Location (only specify if above is 1).  
           +-----------+     0 = Node, 1 = Cell Centered (See note 5.)
         +-----------+
         | INT32     |       Are raw local 1-to-1 face neighbors supplied? (0=FALSE 1=TRUE)
         +-----------+       These raw values are a compact form of the local 1-to-1 face
                             neighbors. If supplied Tecplot assumes that the face
                             neighbors are fully specified and therefore it will not
                             perform auto face neighbor assignment, thereby improving
                             Tecplot's time to first plot.
                             See data section below for format details. ORDERED and
                             FELINESEG zones must specify 0 for this value since raw
                             face neighbors are not defined for these zone types.

         +-----------+
         | INT32     |       Number of miscellaneous user defined face neighbor connections (value >= 0)
         +-----------+       This value is in addition to the face neighbors supplied
                             in the raw section.

         if "number of miscellaneous user defined face neighbor connections" != 0
           +-----------+
           | INT32     |     User defined face neighbor mode
           +-----------+     (0=Local 1-to-1, 1=Local 1-to-many, 2=Global 1-to-1, 3=Global 1-to-many)
           if FE Zone:
             +-----------+
             | INT32     |     Indicates if the finite element face neighbors are
             +-----------+     completely specified by the miscellaneous face neighbors
                               given: (0=NO, 1=YES). If yes, then Tecplot will not perform
                               auto assignment of face neighbors otherwise all faces not
                               specified are considered boundaries. If no, then Tecplot will
                               perform auto-assignment of the face neighbors unless the
                               raw face neighbor array was supplied. This option is not
                               valid for ORDERED zones.
         if Ordered Zone:
           +-----------+
           | INT32*3   |     IMax,JMax,KMax
           +-----------+

         if FE Zone:
           +-----------+
           | INT32     |     NumPts
           +-----------+
           +-----------+
           | INT32     |     NumElements.
           +-----------+       
           +-----------+
           | INT32*3   |     ICellDim,JCellDim,KCellDim (for future use; set to zero)
           +-----------+       

         For all zone types (repeat for each Auxiliary data name/value pair):
         +-----------+
         | INT32     |       1=Auxiliary name/value pair to follow
         +-----------+       0=No more Auxiliar name/value pairs.

         If the above is 1, then supply the following:
           +-----------+
           | INT32*N   |     name string (See note 1.)
           +-----------+      
           +-----------+
           | INT32     |     Auxiliary Value Format (Currently only allow 0=AuxDataType_String)
           +-----------+
           +-----------+
           | INT32*N   |     value string  (See note 1.)
           +-----------+      


      v.  Geometries
         +-----------+
         | FLOAT32   |       Geometry marker.  Value = 399.0
         +-----------+
         +-----------+
         | INT32     |       Position CoordSys 0=Grid, 1=Frame, 2=FrameOffset(not used),
         +-----------+                         3= OldWindow(not used), 4=Grid3D(New to V10)
         +-----------+
         | INT32     |       Scope 0=Global 1=Local
         +-----------+
         +-----------+
         | INT32     |       DrawOrder 0=After, 1=Before
         +-----------+
         +-----------+
         | FLOAT64*3 |       (X or Theta),(Y or R),(Z or dummy)  i.e. the starting location
         +-----------+
         +-----------+
         | INT32     |       Zone (0=all)
         +-----------+
         +-----------+
         | INT32     |       Color
         +-----------+
         +-----------+
         | INT32     |       FillColor
         +-----------+
         +-----------+
         | INT32     |       IsFilled (0=no 1=yes)
         +-----------+
         +-----------+
         | INT32     |       GeomType  0=Line, 1=Rectangle 2=Square,
         +-----------+                 3=Circle, 4=ellipse
         +-----------+
         | INT32     |       LinePattern  0=Solid 1=Dashed 2=DashDot 3=Dotted...
         +-----------+
         +-----------+
         | FLOAT64   |       Pattern Length
         +-----------+
         +-----------+
         | FLOAT64   |       Line Thickness
         +-----------+
         +-----------+
         | INT32     |       NumEllipsePts
         +-----------+
         +-----------+
         | INT32     |       Arrowhead Style 0=Plain, 1=Filled, 2=Hollow
         +-----------+
         +-----------+
         | INT32     |       Arrowhead Attachment 0=None, 1=Beg, 2=End, 3=Both
         +-----------+
         +-----------+
         | FLOAT64   |       Arrowhead Size
         +-----------+
         +-----------+
         | FLOAT64   |       Arrowhead Angle
         +-----------+
         +-----------+
         | IN32*N    |       Macro Function Command (string: N = Length+1)
         +-----------+
         +-----------+
         | INT32     |       Polyline Field Data Type 1=Float, 2=Double  (GTYPE)
         +-----------+
         +-----------+
         | INT32     |       Clipping (0=ClipToAxes,1=ClipToViewport,2=ClipToFrame)
         +-----------+


If the geometry type is line then:
         +-----------+
         | INT32     |       Number of polylines
         +-----------+
         +-----------+
         | INT32     |       Number of points, line 1.
         +-----------+
         +-----------+
         | GTYPE*N   |       X-block geometry points N=NumPts
         +-----------+
         +-----------+
         | GTYPE*N   |       Y-block geometry points N=NumPts
         +-----------+
         +-----------+
         | GTYPE*N   |       Z-block geometry points N=NumPts (Grid3D Only)
         +-----------+
             .
             .
             .

If the geometry type is Rectangle then
         +-----------+
         | GTYPE*2   |       X and Y offset for far corner of rectangle
         +-----------+

If the geometry type is Circle then
         +-----------+
         | GTYPE     |       Radius
         +-----------+

If the geometry type is Square then
         +-----------+
         | GTYPE     |       Width
         +-----------+

If the geometry type is Ellipse then
         +-----------+
         | GTYPE*2   |       X and Y Radii
         +-----------+


    vi.   Text
         +-----------+
         | FLOAT32   |       Text marker.  Value=499.0
         +-----------+
         +-----------+
         | INT32     |       Position CoordSys 0=Grid, 1=Frame, 2=FrameOffset(not used),
         +-----------+                         3= OldWindow(not used), 4=Grid3D(New to V10)
         +-----------+
         | INT32     |       Scope 0=Global 1=Local
         +-----------+
         +-----------+
         | FLOAT64*3 |       (X or Theta),(Y or R),(Z or dummy) Starting Location
         +-----------+
         +-----------+
         | INT32     |       FontType
         +-----------+
         +-----------+
         | INT32     |       Character Height Units 0=Grid, 1=Frame, 2=Point
         +-----------+
         +-----------+
         | FLOAT64   |       Height of characters
         +-----------+
         +-----------+
         | INT32     |       Text Box type 0=NoBox 1=Hollow 2=Filled
         +-----------+
         +-----------+
         | FLOAT64   |       Text Box Margin
         +-----------+
         +-----------+
         | FLOAT64   |       Text Box Margin Linewidth
         +-----------+
         +-----------+
         | INT32     |       Text Box Outline Color
         +-----------+
         +-----------+
         | INT32     |       Text Box Fill Color
         +-----------+
         +-----------+
         | FLOAT64   |       Angle
         +-----------+
         +-----------+
         | FLOAT64   |       Line Spacing
         +-----------+
         +-----------+
         | INT32     |       Text Anchor. 0=left,      1=center,     2=right,
         +-----------+                    3=midleft    4=midcenter   5=midright,
                                          6=headleft   7=headcenter  8=headright
         +-----------+
         | INT32     |       Zone (0=all)
         +-----------+
         +-----------+
         | INT32     |       Color
         +-----------+
         +-----------+
         | INT32*N   |       MacroFunctionCommand (string: N = Length + 1)
         +-----------+
         +-----------+
         | INT32     |       Clipping (0=ClipToAxes,1=ClipToViewport,2=ClipToFrame)
         +-----------+
         +-----------+
         | INT32*N   |       Text.  N=Text Length+1
         +-----------+

     vii.CustomLabel
         +-----------+
         | FLOAT32   |       CustomLabel Marker;  F=599
         +-----------+
         +-----------+
         | INT32     |       Number of labels
         +-----------+
         +-----------+
         | INT32*N   |       Text for label 1.  (N=length of label + 1) See note 1.
         +-----------+
         +-----------+
         | INT32*N   |       Text for label 2.  (N=length of label + 1) See note 1.
         +-----------+
             .
             .
             .
         +-----------+
         | INT32*N   |       Text for label NumLabels.  (N=length of label + 1) See note 1.
         +-----------+

    viii.UserRec
         +-----------+
         | FLOAT32   |       UserRec Marker;  F=699
         +-----------+
         +-----------+
         | INT32*N   |       Text for UserRec.  See note 1.
         +-----------+

    ix. Dataset Auxiliary data.
         +-----------+
         | FLOAT32   |       DataSetAux Marker;  F=799.0
         +-----------+
         +-----------+
         | INT32*N   |       Text for Auxiliary "Name".  See note 1.
         +-----------+
         +-----------+
         | INT32     |       Auxiliary Value Format (Currently only
         +-----------+       allow 0=AuxDataType_String)
         +-----------+
         | INT32*N   |       Text for Auxiliary "Value".  See note 1.
         +-----------+
    x. Variable Auxiliary data.
         +-----------+
         | FLOAT32   |       VarAux Marker;  F=899.0
         +-----------+
         +-----------+
         | INT32*N   |       Variable number (zero based value)
         +-----------+
         +-----------+
         | INT32*N   |       Text for Auxiliary "Name".  See note 1.
         +-----------+
         +-----------+
         | INT32     |       Auxiliary Value Format (Currently only
         +-----------+       allow 0=AuxDataType_String)
         +-----------+
         | INT32*N   |       Text for Auxiliary "Value".  See note 1.
         +-----------+

II.  DATA SECTION (don't forget to separate the header from the data with an EOHMARKER)
     The data section contains all of the data associated with the
     zone definitions in the header.

     i. For both ordered and fem zones:
         +-----------+
         | FLOAT32   |       Zone marker  Value = 299.0
         +-----------+
         +-----------+
         | INT32*N   |       variable data format, N=Total number of vars
         +-----------+       1=Float, 2=Double, 3=LongInt, 4=ShortInt, 5=Byte, 6=Bit
         +-----------+
         | INT32     |       Has passive variables: 0 = no, 1 = yes.
         +-----------+
         if "has passive variables" != 0
           +-----------+
           | INT32*NV  |     Is variable passive: 0 = no, 1 = yes
           +-----------+     (Omit entirely if "Has passive variables" is 0).
         +-----------+
         | INT32     |       Has variable sharing 0 = no, 1 = yes.       
         +-----------+                                       
         if "has variable sharing" != 0
           +-----------+
           | INT32*NV  |     Zero based zone number to share variable with (relative to this datafile).
           +-----------+     (-1 = no sharing).   (Omit entirely if "Has variable sharing" is 0).
         +-----------+
         | INT32     |       Zero based zone number to share connectivity list with (-1 = no sharing).
         +-----------+
         Compressed list of min/max pairs for each non-shared and non-passive variable. For each
         non-shared and non-passive varaible (as specified above):
           +-----------+
           | FLOAT64   |       Min value
           +-----------+
           +-----------+
           | FLOAT64   |       Max value
           +-----------+
         +-----------+
         | xxxxxxxxxx|       Zone Data.  Each variable is in data format as
         +-----------+       specified above.

     ii. specific to ordered zones
         if "zone number to share connectivity list with" == -1 &&
            "number of miscellaneous user defined face neighbor connections" != 0
           +-----------+
           | INT32*N   |     Face neighbor connections.
           +-----------+     N = (number of miscellaneous user defined face neighbor connections) * P 
                             (See note 5 below).


     iii. specific to fem zones
         if "zone number to share connectivity lists with" == -1
           +-----------+
           | INT32*N   |     Zone Connectivity Data N=L*JMax (see note 3 below).
           +-----------+
         if "zone number to share connectivity lists with" == -1 &&
            "raw local 1-to-1 face neighbors are supplied"
           +-----------+
           | INT32*N   |     Raw local 1-to-1 face neighbor array.
           +-----------+     N = (NumElements * NumFacesPerElement)
                             (See note 4 below).
         if "zone number to share connectivity lists with" == -1 &&
            "number of miscellaneous user defined face neighbor connections" != 0
           +-----------+
           | INT32*N   |     Face neighbor connections.
           +-----------+     N = (number of miscellaneous user defined face neighbor connections) * P 
                             (See note 5 below).




NOTES:

1.  All character data is represented by INT32 values.

     Example:  The letter "A" has an ASCII value of 65.  The WORD
               written to the data file for the letter "A" is then
               65.
               In fortran this could be done by doing the following:

               Integer*32 I
               .
               .
               I = ICHAR('A');

               WRITE(10) I


    All character strings are null terminated (i.e. terminated by a zero value)


2.  In FE Data I = Number of points, J = Number of elements, and
    K = Element type where:

    0 = Triangles;
    1 = Quadrilaterals;
    2 = Tetrahedrons.
    3 = Bricks.
    4 = LineSeg


3.  This represents JMax sets of adjacency zero based indices where each
    set contains L values where L is
    3 for TRIANGLES
    4 for QUADRILATERALS
    4 for TETRAHEDRONS
    8 for BRICKS


4.  The raw face neighbor array is dimensioned by number of elements for the
    zone times the number of faces per element where each member of the array
    holds the zero based element neighbor of that face. A boundary face is one
    that no neighboring element and is represented by a -1. Faces should only
    be neighbors if they logically share nodes and they should be reciprocal.


5.  FaceNeighbor Mode   # values  Data
    ---------------------------------------------------------------------
    LocalOneToOne       3         cz,fz,cz
    LocalOneToMany      nz+4      cz,fz,oz,nz,cz1,cz2,...,czn
    GlobalOneToOne      4         cz,fz,ZZ,CZ
    GlobalOneToMany     2*nz+4    cz,fz,oz,nz,ZZ1,CZ1,ZZ2,CZ2,...,ZZn,CZn
    
    Where:
        cz = cell in current zone (zero based)
        fz = face of cell in current zone (zero based)
        oz = face obsuration flag (only applies to one-to-many):
               0 = face partially obscured
               1 = face entirely obscured
        nz = number of cell or zone/cell associations (only applies to one-to-many)
        ZZ = remote Zone (zero based)
        CZ = cell in remote zone (zero based)
    
    cz,fz combinations must be unique and multiple entries are
    not allowed. Additionally, Tecplot assumes that with the
    one-to-one face neighbor modes a supplied cell face is
    entirely obscured by it's neighbor.  With one-to-many, the
    obscuration flag must be supplied.
    
    Face neighbors that are not supplied are run through
    Tecplot's auto face neighbor generator (FE only).

5.  Cell centered variable (DATA SECTION)
    To make reading of cell centered binary data efficient, Tecplot stores
    IMax*JMax*KMax numbers of cell centered values, where IMax, JMax, and KMax
    represent the number of points in the I, J, and K directions. Therefore
    extra zero values (ghost values) are written to the data file for the
    slowest moving indices. For example if your data's IJK dimensions are 2x3x2
    a cell centered variable will have 1x2x1 (i.e. (I-1)x(J-1)x(K-1))
    significant values however 2x3x2 values must be written out because it must
    include the ghost values. Assume that the two significant cell centered
    values are 1.5 and 12.5. The ghost values will be output with a zero value.

    So if the zone was dimensioned 2x3x2 it's cell centered variable would be
    represented as follows:
      1.5  0.0    12.5  0.0     0.0  0.0     0.0  0.0     0.0  0.0     0.0  0.0

    If the zone was dimensioned 3x2x2 it's cell centered variable would be
    represented as follows:
      1.5  12.5  0.0     0.0  0.0  0.0     0.0  0.0  0.0     0.0  0.0  0.0

    and if the zone was dimensioned 2x2x3 it's cell centered variable would be
    represented as follows:
      1.5  0.0    0.0  0.0     12.5  0.0     0.0  0.0     0.0  0.0     0.0  0.0

    Obviously for large variables the wasted space is less significant that it
    is for the small example above.
-----------------------------------------------------------------------


COMPILING:
-----------------------------------------------------------------------
 Preplot was originally developed in PASCAL and then later converted
 to C.  To compile preplot use one of the following commands:

For UNIX, et.al.:
 cc preplot.cpp -DPLOT3D -DUNIXX -DCRAYT3M  -o preplot        (Cray T3M only)
 cc preplot.cpp -DPLOT3D -DUNIXX -DOLDCRAY  -o preplot        (Older crays like YMP's)
 cc preplot.cpp -DPLOT3D -DUNIXX -DOLDCRAY -DWEEDMIDBLOCKS -o preplot
 cc preplot.cpp -DPLOT3D -DUNIXX -DCRAYIEEE -o preplot
 cc preplot.cpp -DPLOT3D -DUNIXX -DIRIS -o preplot
 cc preplot.cpp -DPLOT3D -DUNIXX -DSUN -o preplot
 cc preplot.cpp -DPLOT3D -DUNIXX -DDEC -o preplot
 cc preplot.cpp -DPLOT3D -DUNIXX -DHITACHI -o preplot
 cc preplot.cpp -DPLOT3D -DUNIXX -DDECALPHA -o preplot
 cc preplot.cpp -DPLOT3D -DUNIXX -DCOMPAQALPHA -o preplot
 cc preplot.cpp -DPLOT3D -DUNIXX -DHP -o preplot
 cc preplot.cpp -DPLOT3D -DUNIXX -DLINUX -o preplot
 cc preplot.cpp -DPLOT3D -DUNIXX -DIBMRS6000 -o preplot


 In addition, you can modify the io buffer size used by preplot by
 putting the following define at the top of this file:

#define TECBUFSIZE nnnn

 where nnnn is the size that you want the buffers to be set to.
 A good place to start would be somthing like 1024*16.


For Windows:
 cl /DMSWIN preplot.cpp (Microsoft C)

Including the -DPLOT3D flag adds the capability to read
plot3d files.

If you have some other "generic" unix system then most likely
the IRIS version of the compile command should work.  If you still 
have problems then you may have to do some customizing yourself (In 
which case please let us know what you came up with).

MACHINE SPECIFIC NOTES:

if -DCRAYIEEE  is used with the CRAY version then this creates a version of
preplot that can process IEEE binary files on a CRAY.  The prceedure to
follow is:

     1.  Issue the cray command to force all future writes from a
         FORTRAN program to a selected unit number or filename to
         be written in IEEE format.  The command is:

           assign -N ieee -f f77 f:fname

                   or

           assign -N ieee -f f77 u:#


         where fname is a file name to make the assignment to and
         # is a FORTRAN unit number to assign to.

         To list all assignments use:

           assign -V

         To remove an assignment use:

           assign -R

     2.  Run your FORTRAN application - creating an IEEE formatted
         PLOT3D file.

     3.  Run this special version of preplot on the IEEE PLOT3D file.
         Make sure and include -plot3d and -f flags in the preplot
         command line.



-----------------------------------------------------------------------

END CODELOG
*/

#define TecplotBinaryFileVersion 108 /* copied form GLOBAL.h */
#define VersionString "PREPLOT V11.00-08/02/2006  Copyright (C) Tecplot, Inc. 1987-2006.\n"

#define MAXNUMWARNINGS 50


/*
 * Stuff from GLOBAL.h needed for the #includes
 */
#define Boolean_t char
#define MaxCharsFilePath _MAX_PATH





#if defined TECPLOTKERNEL

#include "stdafx.h"
#define PLOT3D
#include "MASTER.h"
#include "TASSERT.h"
#include "Q_UNICODE.h"
#include "ALLOC.h"
#include "SYSTEM.h"
#include "TIMEOUT.h"


extern void GetMaxVarZone(int *MaxNumZones,
                          int *MaxNumVars);
extern int GetMaxPtsInALine(void);
extern Boolean_t GetRandomFileName(char **F);
extern void DiskIOError(void);
#else /* !TECPLOTKERNEL */
#if defined WIN32 && !defined MSWIN
#define MSWIN
#endif
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#define INVARIANT(EXPR)
#define REQUIRE(EXPR)
#define ENSURE(EXPR)
#define CHECK(EXPR)
#define VERIFY(EXPR)  ((void)(EXPR))
#define NOT_IMPLEMENTED()  not implemented /* intentionally break the compile */
#if defined UNIXX || defined DOS || defined MSWIN
#define ALLOC_ARRAY(N,Type,S) (Type *)malloc((N)*sizeof(Type))
#define ALLOC_ITEM(Type,S)    (Type *)malloc(sizeof(Type))
#define FREE_ARRAY(X,S)       free((void *)(X))
#define FREE_ITEM(X,S)        free((void *)(X))
#endif
#endif

#define FOPEN    fopen
#define FREOPEN  freopen
#define FCLOSE   fclose
#define FREAD    fread
#define FWRITE   fwrite
#define FSEEK    fseek
#define FTELL    ftell

#define IMPLICATION(P,Q) (!(P) || (Q))
#ifdef MAX
#  undef MAX
#endif
#define MAX(X,Y) ((X) > (Y) ? (X) : (Y) )
#ifdef MIN
#  undef MIN
#endif
#define MIN(X,Y) ((X) < (Y) ? (X) : (Y) )

#if !defined TECPLOTKERNEL
#include <stdlib.h>
#if defined MSWIN
#include <io.h>
#else
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#endif
#endif /* !TECPLOTKERNEL */

#if defined TECPLOTKERNEL
#define PLOT3D
#endif

#if defined CRAYIEEE
#define OLDCRAY
#endif

#if defined HP || defined IBMRS6000 || defined LINUX
#define IRIS
#endif

#if defined OLDCRAY
#define   FloatSize        8
#define   DOUBLE           float
#define   LONGIS64
#else
#define   FloatSize        4
#  if defined CRAYT3M
#  define   DOUBLE           float
#  define   SHORTIS32
#  else
#define   DOUBLE           double
#  endif
#endif

#define   LARGEDOUBLE      1.0E+150
#define   SMALLDOUBLE      1.0E-150
#define   LARGELONG        2147483646
#define   LARGESHORT       32766
#define   DEGPERRADIANS    57.295779513082323

#if defined (IRIS3000)
#define IRIS
#endif

#if defined IRIS3000
#  define DOUBLE_SCANF_FMT "%e"
#else
#  define DOUBLE_SCANF_FMT "%le"
#endif

#if defined COMPAQALPHA
#define DECALPHA
#endif

#if defined (DECALPHA)
#define DEC
#define LONGIS64
#endif


#if defined IRIS || defined SUN || defined DEC || defined OLDCRAY || defined CRAYT3M || defined DARWIN
#include <string.h>
#include <ctype.h>
#define  MaxCharsFileName   260
#endif
#if defined DOS
#include <ctype.h>
#define  MaxCharsFileName   260
#endif
#if defined MSWIN
#include <ctype.h>
#include <string.h>
#define  MaxCharsFileName   (MaxCharsFilePath+1) /* about 260 */
#endif

#define DEFAULT_MAXNUMZONESORVARS 32700

/*
 * Due to our current line buffer code not handling lines larger than the
 * static amount (i.e. through repreated calls to fgets), the line length must
 * be the largest of all string entity values listed below.
 */
#define   MaxLineIndex          32000
#define   MaxCharsBaseName      (MaxCharsFileName-4)
/*
 * If any of these values changes it's corresponding value in GLOBAL.h must
 * change to match it so that files created by preplot and Tecplot are
 * consistent.
 */
#define   MaxChrsDatasetTitle   256
#define   MaxChrsZnTitle        128
#define   MaxChrsVarName        128
#define   MaxChrsAuxValueString MaxLineIndex
#define   MaxChrsTextString     MaxLineIndex



/* #define   MaxGeometryPts    6000 -- this is now a variable */
#define   DEFAULT_MAX_GEOMETRY_PTS  32000
#define   MaxGeomSegments   50
#define   MaxCustomLabels   (5000*10)
#define   MaxCustomColors   56

#define   FALSE             0
#define   TRUE              1
#define   UNSET_BOOLEAN     3
#define   ABS(x)           ((x)>=0 ? (x) : -(x))
#define   ROUND2(X)        ((X) >= 0 ? \
                               ((LgIndex)(X+0.49)) : \
                               ((LgIndex)(X-0.49)))

#define   MaxNumSetMembers  DEFAULT_MAXNUMZONESORVARS
#define   SetSize           ((MaxNumSetMembers)/32+1)
#define   LargestIndex      2000000000
#define   MaxPlot3DVars     50


#define ZONEMARKER           299.0
#define GEOMMARKER           399.0
#define TEXTMARKER           499.0
#define CUSTOMLABELMARKER    599.0
#define USERRECMARKER        699.0
#define DATASETAUXDATAMARKER 799.0
#define VARAUXDATAMARKER     899.0
#define EOHMARKER            357.0

#define BAD_SET_VALUE        (-1)
#define STRAND_ID_STATIC     (-1)
#define STRAND_ID_PENDING    (-2)
#define STRAND_ID_UNASSIGNED (-3) /* ...only relevant for preplot */

typedef enum
  {
    Units_Grid,
    Units_Frame,
    Units_Point,
    Units_Screen,
    Units_AxisPercentage /* not used for text */
  } Units_e;


typedef enum
  {
    FieldDataType_Reserved, /* never use */
    FieldDataType_Float,
    FieldDataType_Double,
    FieldDataType_Int32,
    FieldDataType_Int16,
    FieldDataType_Byte,
    FieldDataType_Bit
  } FieldDataType_e;

typedef enum
  {
    Arrowhead_Plain,
    Arrowhead_Filled,
    Arrowhead_Hollow
  } ArrowheadStyle_e;

typedef enum
  {
    ArrowheadAttach_None,
    ArrowheadAttach_AtBeginning,
    ArrowheadAttach_AtEnd,
    ArrowheadAttach_AtBothEnds
  } ArrowheadAttachment_e;

typedef enum
  {
    TextAnchor_Left,
    TextAnchor_Center,
    TextAnchor_Right,
    TextAnchor_MidLeft,
    TextAnchor_MidCenter,
    TextAnchor_MidRight,
    TextAnchor_HeadLeft,
    TextAnchor_HeadCenter,
    TextAnchor_HeadRight,
    TextAnchor_OnSide
  } TextAnchor_e;


typedef enum CoordSysType  {GRID,FRAME,FRAMEOFFSET,OLDWINDOW,GRID3D,UNDEF} CoordSysType;
typedef enum ScopeType     {GLOBAL,LOCAL}                ScopeType;
typedef enum DrawOrderType {AFTERDATA,BEFOREDATA} DrawOrderType;
/* deprecated */
typedef enum ElementType  {TRIANGLE,QUADRILATERAL,
                           TETRAHEDRON,BRICK,
                           LINESEG,
                           BADELEMENT = 99}            ElementType;
typedef enum LineType     {SOLID,
                           DASHED,
                           DASHDOT,
                           DOTTED,
                           LONGDASH,
                           DASHDOTDOT}                  LineType;
typedef enum GeometryType {LINE,
                           RECTANGLE,
                           SQUARE,
                           CIRCLE,
                           ELLIPSE,
                           /* deprecated: use LINE and GRID3D */
                           LINE3D }                     GeometryType;
typedef enum ZoneDataType {ORDERED,
                           FELINESEG,
                           FETRIANGLE,
                           FEQUADRILATERAL,
                           FETETRAHEDRON,
                           FEBRICK}                     ZoneDataType;
typedef enum ClippingType {CLIPTOVIEWPORT,
                           CLIPTOFRAME}                 ClippingType;
typedef enum DataPackingType {BLOCKPACKING,
                              POINTPACKING}             DataPackingType;
typedef enum FaceNeighborModeType {LOCALONETOONE,
                                   LOCALONETOMANY,
                                   GLOBALONETOONE,
                                   GLOBALONETOMANY}     FaceNeighborModeType;
/* deprecated */
typedef enum FormatType   {IJKBLOCK,
                           IJKPOINT,
                           FEBLOCK,
                           FEPOINT} FormatType;
typedef enum Tokens       {NullToken,
                           TITLEToken,
                           DATASETAUXDATAToken,
                           VARAUXDATAToken,
                           VARIABLESToken,
                           ZONEToken,
                           GEOMETRYToken,
                           CUSTOMLABELToken,
                           USERRECToken,
                           TEXTToken,
                           IdentToken,
                           StringToken,
                           ValueToken,
                           SequenceToken,
                           EqualsToken,
                           LeftParenToken,
                           RightParenToken,
                           EndofFileToken,
                           EndofVarLineToken,
                           DupConnectToken,
                           SetToken,
                           UnknownToken}              Tokens;
#if defined PLOT3D
typedef enum Plot3DModeEnum {MODE_Unknown,
                             MODE_1D,
                             MODE_2D,
                             MODE_3DW,
                             MODE_3DP,
                             MODE_UNSTRUCTURED}             Plot3DModeEnum;
typedef enum Plot3DVarEnum  { Var_GridAndQ,
                              Var_GridOnly,
                              Var_GridAndFunction,
                              Var_GridAndFunctionAndQ}       Plot3DVarEnum;
#endif


#if defined TECPLOTKERNEL
extern Boolean_t Interrupted;
extern Boolean_t IsInterfaceSuspended(void);
extern Boolean_t InBatchMode;
extern Boolean_t _Gr_CheckInterrupt(const char *InterruptMessage,
                                  const char *InterruptFileLocation,
                                  int         InterruptFileLine);
#endif

typedef char               LStringType[MaxChrsTextString+1];
typedef char              *StringPtr;

typedef short         SmInteger;
typedef unsigned char Byte;

#if defined LONGIS64
  typedef unsigned int  uint32;
  typedef int           LgIndex;
#endif

#if defined SHORTIS32
  typedef unsigned short uint32;
  typedef short          LgIndex;
#endif

#if !defined LONGIS64 && !defined SHORTIS32
  typedef unsigned long int  uint32;
  typedef int                LgIndex;
#endif

typedef struct NodeVarStruct { LgIndex   ii;
                               LgIndex   val; } NodeVarType;

/**
 * Basic linked list management. All "subclasses" make sure that the "Next"
 * pointer is the first item in the list structure. This allows us to
 * reuse the list management functions.
 */
typedef struct ListItem_s
  {
    struct ListItem_s *Next;
  } ListItem_s;

/**
 * Declaration for a list iterator.
 */
typedef Boolean_t (*ListItemIterator_pf)(ListItem_s *ListItem,
                                       void       *ClientData);
/**
 */
typedef struct AuxDataListItem_s
  /* extends ListItem_s */
  {
    /* since we are extending ListItem_s it must be first item of structure */
    ListItem_s  ListItem;
    char       *Name;
    char       *Value;
  } AuxDataListItem_s;

/**
 */
static AuxDataListItem_s *ZoneAuxDataListItemHead = NULL;


static int                MaxGeometryPts = DEFAULT_MAX_GEOMETRY_PTS;
static char               ErrString[1024];
static char               InFileName[MaxCharsFileName];
static char               FinalInFileName[MaxCharsFileName];
static LgIndex            LineNumber;
#if !defined TECPLOTKERNEL
static int                NumWarns;
#endif
static int                MaxNumVars  = DEFAULT_MAXNUMZONESORVARS;
static int                MaxNumZones = DEFAULT_MAXNUMZONESORVARS;
static CoordSysType       CoordSys;
static LineType           LinePattern;
static double             PatternLength;
static double             LineThickness;
static double             LineSpacing;
static LgIndex            NumEllipsePts;
static LgIndex            ArrowheadStyle;
static LgIndex            ArrowheadAttachment;
static double             ArrowheadSize;
static double             ArrowheadAngle;
static GeometryType       GeomType;
static ZoneDataType      *ZoneType;
static DataPackingType   *DataPacking;
static ClippingType       TextClipping;
static ClippingType       GeomClipping;
static DataPackingType    GeomDataPacking;
static Boolean_t          WriteRawFaceNeighborArray;
static FaceNeighborModeType FaceNeighborMode;
static Boolean_t          FEFaceNeighborsComplete;
static LgIndex            FaceNeighborConnections;
static LgIndex           *VarShareZone;
static LgIndex            ZoneColor;
static LgIndex            Color;
static LgIndex            FillColor;
static LgIndex            IsFilled;
static double             BoxMargin;
static LgIndex            BoxFillColor;
static LgIndex            BoxOutlineColor;
static LgIndex            BoxType;
static LgIndex            FontType;
static TextAnchor_e       TextAnchor;
static Units_e            HeightUnits;
static LgIndex            TGZone;
static StringPtr          UserRecString;
static StringPtr          CustomLabel[MaxCustomLabels];
static int                NumCustomLabels;
static double             Angle;
static ScopeType          Scope;
static DrawOrderType      DrawOrder;
static double             Height;
static LgIndex            ICellDim;
static LgIndex            JCellDim;
static LgIndex            KCellDim;
static LgIndex           *ParentZone;
static LgIndex           *StrandID;
static double            *SolutionTime;
static LgIndex           *IMax;
static LgIndex           *JMax;
static LgIndex           *KMax;
static LgIndex            NodeVar;
static LgIndex            RepeatLength_g = 0;
static double             RepeatValue_g;
static LgIndex            RepeatLength_q = 0;
static double             RepeatValue_q;
static LStringType        CurData;
static int                LinePos;
static int                LineLen;
static char               Line[MaxLineIndex+1];
static Tokens             CurToken;
static double             CurTValue;
static LgIndex            CurTSeqStart;
static LgIndex            CurTSeqEnd;
static LgIndex            ParenTokenNestLevel;
static LgIndex            BracketNestLevel;
static LStringType        HeaderString;
static Boolean_t          PreplotIsOk;
static Boolean_t          EndOfHeader;
static Boolean_t          Done;
static double            *YGeometryValues  = NULL;
static double            *ZGeometryValues  = NULL;
static FieldDataType_e    GeomDataType;
static char              *BlckFName;
static char               PlotFileName[MaxCharsFileName];
static FILE              *BlckFile;
static FILE              *PlotFile;
static FILE              *InFile;
static int                CurZone;
static StringPtr         *VarName;
static StringPtr         *ZoneName;
static LgIndex           *ConnectivityShareZone;
static int                NumVars;
static double             XX,YY,ZZ;
static Boolean_t          Echo;
static char               TextString[MaxChrsTextString];
static char               MacroString[7000];
static LgIndex            Index;
static LgIndex           *IStart;
static LgIndex           *IEnd;
static LgIndex           *ISkip;
static LgIndex           *JStart;
static LgIndex           *JEnd;
static LgIndex           *JSkip;
static LgIndex           *KStart;
static LgIndex           *KEnd;
static LgIndex           *KSkip;
static FieldDataType_e   *VarDataType;
static Boolean_t         *VarIsCellCentered;
static Boolean_t         *VarIsPassive;
static double            *VarMin;
static double            *VarMax;
static uint32            *CurTSet;
static NodeVarType       *NodeVarList;
static LgIndex            LastNodeInList;
static uint32            *ZoneSet;
static Boolean_t          StopAfterLastZone;
static Boolean_t          ReverseOutputBytes; /*
                                               * If Preplot's -foreignplt flag
                                               * is used the output bytes are
                                               * reversed so that one platform
                                               * can produce files that have
                                               * native byte order on another
                                               * platform.
                                               */
static LgIndex            LastZone;
static Boolean_t          ErrProcessed;
static unsigned char      CurByte;
static int                CurBit;


#if defined PLOT3D
static FILE              *InFile_q;
static FILE              *InFile_f;
static float             *Plot3DVarArray[MaxPlot3DVars+8];
static LgIndex           *Plot3DConnectivityArray;
static LgIndex            Plot3DVarArrayCurIndex[MaxPlot3DVars+8];
static LgIndex           *Plot3DGridBase;
static LgIndex           *Plot3DConnectivityBase;
static Boolean_t            InputIsPlot3D;
static Plot3DVarEnum      Plot3DVarFormat;
static Boolean_t            Plot3DInputIsBinary;
static Boolean_t            Plot3DIsMultiGrid;
static short              Plot3DHasIBlank;
static Boolean_t            Plot3DInputHasRecordMarks;
static Boolean_t            Plot3DCollapseIJK;
static Plot3DModeEnum     Plot3DMode;
static LgIndex            Plot3DNumGrids;
static LgIndex            Plot3DCurGrid;
static LgIndex           *Plot3DIDim;
static LgIndex           *Plot3DJDim;
static LgIndex           *Plot3DKDim;
static uint32            *Plot3DKSet;
static uint32            *Plot3DJSet;
static uint32            *Plot3DISet;
static double             Plot3DVarMin[MaxPlot3DVars+8];
static double             Plot3DVarMax[MaxPlot3DVars+8];


#if !defined TECPLOTKERNEL
static uint32             Plot3DBadBlockCount;
#endif
static int                Plot3DNumPVars;
static int                Plot3DNumQVars;
static int                Plot3DNumFVars;
static Boolean_t            IJKSetSet;
static Boolean_t            Plot3DIsForeign;  /* reverse the bytes? */
#endif


#if defined TECPLOTKERNEL /* Used ONLY for oem/demo integer checksums */


extern void UPDATEOEMCHECKSUM(LgIndex   *CheckSum,
                              void      *ByteArray,
                              size_t    size,
                              size_t    nobj,
                              Boolean_t ReverseBytes);
extern Boolean_t IsOemLaunch;
extern Boolean_t IsDemoLaunch;

static char OemSaveAscii[100];

/* Note: if DEFAULT_MAXNUMZONESORVARS, then
   MAXZONEMAP must also change in Tecplot to match! */

LgIndex PreplotChecksum[DEFAULT_MAXNUMZONESORVARS]; 

#endif


/******************************************************************************
 *                                                                            *
 *                     Linked List Manangement Functions                      *
 *                                                                            *
 *****************************************************************************/

/**
 */
static void ListIterate(ListItem_s          *ListHead,
                        ListItemIterator_pf Iterator,
                        void                *ClientData)
{
  ListItem_s *ListItem;
  Boolean_t    DoContinue;
  for (ListItem = ListHead, DoContinue = TRUE;
       ListItem != NULL && DoContinue;
       ListItem = ListItem->Next)
    {
      DoContinue = Iterator(ListItem, ClientData);
    }
}

/**
 * Adds the item to the end of the list.
 */
static void ListAddItem(ListItem_s **ListHead,
                        ListItem_s *ListItemToAdd)
{
  if (*ListHead == NULL)
    {
      *ListHead = ListItemToAdd;
    }
  else
    {
      ListItem_s *ListItem = *ListHead;
      while (ListItem->Next != NULL)
        ListItem = ListItem->Next;
      ListItem->Next = ListItemToAdd;
    }
}

/**
 * Finds the item to remove and returns it. This list then
 * no longer has a reference to the item.
 */
static void ListRemoveItem(ListItem_s **ListHead,
                           ListItem_s *ListItemToRemove)
{
  if (*ListHead != NULL)
    {
      ListItem_s *PreviousListItem = NULL;
      ListItem_s *ListItem = *ListHead;
      while (ListItem != NULL && ListItem != ListItemToRemove)
        {
          PreviousListItem = ListItem;
          ListItem = ListItem->Next;
        }

      if (ListItem != NULL)
        {
          /* unhook the item from the list */
          if (ListItem == *ListHead)
            *ListHead = ListItem->Next;
          else
            PreviousListItem->Next = ListItem->Next;

          /* get rid of any list reference */
          ListItem->Next = NULL;
        }
    }
}



static void ReverseBytes(void *buffer,int len)
{
  char *p = (char*)buffer;
  char r_buffer[256]; /* should be enough... */
  int i;

  for (i=0;i<len;i++)
    r_buffer[i] = p[len-1-i];

  for (i=0;i<len;i++)
    p[i] = r_buffer[i];
}


/**
 */
static void CleanupAuxDataListItem(AuxDataListItem_s **AuxDataListItem)
{
  REQUIRE(VALID_REF(AuxDataListItem));

  if (*AuxDataListItem != NULL)
    {
      if ((*AuxDataListItem)->Name != NULL)
        FREE_ARRAY((*AuxDataListItem)->Name, "auxiliary data name");
      if ((*AuxDataListItem)->Value != NULL)
        FREE_ARRAY((*AuxDataListItem)->Value, "auxiliary data value");
      FREE_ITEM(*AuxDataListItem, "auxiliary data item");
      *AuxDataListItem = NULL;
    }
}

/**
 */
static void CleanupAuxDataList(AuxDataListItem_s **AuxDataListItemHeadRef)
{
  REQUIRE(VALID_REF(AuxDataListItemHeadRef));
  REQUIRE(VALID_REF(*AuxDataListItemHeadRef) || *AuxDataListItemHeadRef == NULL);

  while (*AuxDataListItemHeadRef != NULL)
    {
      AuxDataListItem_s *AuxDataListItem = *AuxDataListItemHeadRef;
      ListRemoveItem((ListItem_s **)AuxDataListItemHeadRef,
                     (ListItem_s *)AuxDataListItem);
      CleanupAuxDataListItem(&AuxDataListItem);
    }
}


static void CleanUp(Boolean_t IsOk)
{
  int I;
  for (I = 0; I < MaxCustomLabels; I++)
    if (CustomLabel[I])
      {
        FREE_ARRAY(CustomLabel[I],"custom label");
        CustomLabel[I] = NULL;
      }

  if (ZoneName)
    {
      for (I = 0; I < MaxNumZones; I++)
        if (ZoneName[I])
          {
            FREE_ARRAY(ZoneName[I],"zone name");
            ZoneName[I] = NULL;
          }
    }

  if (VarName)
    {
      for (I = 0; I < MaxNumVars; I++)
        if (VarName[I])
          {
            FREE_ARRAY(VarName[I],"var name");
            VarName[I] = NULL;
          }
    }

#if defined PLOT3D
  if (InFile_f)
    {
#     if defined TECPLOTKERNEL
        Close_File(&InFile_f,FALSE);
#     else
        FCLOSE(InFile_f);
#     endif
      InFile_f = NULL;
    }
  if (InFile_q)
    {
#     if defined TECPLOTKERNEL
        Close_File(&InFile_q,FALSE);
#     else
        FCLOSE(InFile_q);
#     endif
      InFile_q = NULL;
    }
  for (I = 0; I < MaxPlot3DVars+8; I++)
    {
      if (Plot3DVarArray[I])
        {
          FREE_ARRAY(Plot3DVarArray[I],"plot3d var array");
          Plot3DVarArray[I] = NULL;
        }
    }
   if (Plot3DConnectivityArray)
     FREE_ARRAY(Plot3DConnectivityArray,"plot3d connectivity array");
#endif

  if (!IsOk && *PlotFileName)
    {
      if ( PlotFile )
        {
          if ( PlotFile != stdin )
#           if defined TECPLOTKERNEL
              Close_File(&PlotFile,FALSE);
#           else
              FCLOSE(PlotFile);
#           endif
          PlotFile = NULL;
        }
      unlink(PlotFileName);
    }
  if ( BlckFName )
    {
      if ( *BlckFName )
        {
          if ( BlckFile )
            {
#             if defined TECPLOTKERNEL
                Close_File(&BlckFile,FALSE);
#             else
                FCLOSE(BlckFile);
#             endif
              BlckFile = NULL;
            }
          unlink(BlckFName);
        }
      FREE_ARRAY(BlckFName, "BlckFName");
      BlckFName = NULL;
    }


  if (VarShareZone)         FREE_ARRAY(VarShareZone,"VarShareZone");
  if (VarName)              FREE_ARRAY(VarName,"VarName");
  if (ZoneName)             FREE_ARRAY(ZoneName,"ZoneName");
  if (ConnectivityShareZone)FREE_ARRAY(ConnectivityShareZone,"ConnectivityShareZone");
  if (ParentZone)           FREE_ARRAY(ParentZone,"ParentZone");
  if (StrandID)             FREE_ARRAY(StrandID,"StrandID");
  if (SolutionTime)         FREE_ARRAY(SolutionTime,"SolutionTime");
  if (IMax)                 FREE_ARRAY(IMax,"IMax");
  if (JMax)                 FREE_ARRAY(JMax,"JMax");
  if (KMax)                 FREE_ARRAY(KMax,"KMax");
  if (ZoneType)             FREE_ARRAY(ZoneType,"ZoneType");
  if (DataPacking)          FREE_ARRAY(DataPacking,"DataPacking");
  if (CurTSet)              FREE_ARRAY(CurTSet,"CurTSet");
  if (IStart)               FREE_ARRAY(IStart,"IStart");
  if (IEnd)                 FREE_ARRAY(IEnd,"IEnd");
  if (ISkip)                FREE_ARRAY(ISkip,"ISkip");
  if (JStart)               FREE_ARRAY(JStart,"JStart");
  if (JEnd)                 FREE_ARRAY(JEnd,"JEnd");
  if (JSkip)                FREE_ARRAY(JSkip,"JSkip");
  if (KStart)               FREE_ARRAY(KStart,"KStart");
  if (KEnd)                 FREE_ARRAY(KEnd,"KEnd");
  if (KSkip)                FREE_ARRAY(KSkip,"KSkip");
  if (VarDataType)          FREE_ARRAY(VarDataType,"VarDataType");
  if (VarIsCellCentered)    FREE_ARRAY(VarIsCellCentered,"VarIsCellCentered");
  if (VarIsPassive)         FREE_ARRAY(VarIsPassive,"VarIsPassive");
  if (VarMin)               FREE_ARRAY(VarMin,"VarMin");
  if (VarMax)               FREE_ARRAY(VarMax,"VarMax");
  if (ZoneSet)              FREE_ARRAY(ZoneSet,"ZoneSet");
  if (YGeometryValues)      FREE_ARRAY(YGeometryValues,"YGeometryValues");
  if (ZGeometryValues)      FREE_ARRAY(ZGeometryValues,"ZGeometryValues");

  VarShareZone          = NULL;
  VarName               = NULL;
  ZoneName              = NULL;
  ConnectivityShareZone = NULL;
  ParentZone            = NULL;
  StrandID              = NULL;
  SolutionTime          = NULL;
  IMax                  = NULL;
  JMax                  = NULL;
  KMax                  = NULL;
  ZoneType              = NULL;
  DataPacking           = NULL;
  CurTSet               = NULL;
  IStart                = NULL;
  IEnd                  = NULL;
  ISkip                 = NULL;
  JStart                = NULL;
  JEnd                  = NULL;
  JSkip                 = NULL;
  KStart                = NULL;
  KEnd                  = NULL;
  KSkip                 = NULL;
  VarDataType           = NULL;
  VarIsCellCentered     = NULL;
  VarIsPassive          = NULL;
  VarMin                = NULL;
  VarMax                = NULL;
  ZoneSet               = NULL;
  YGeometryValues       = NULL;
  ZGeometryValues       = NULL;

  CleanupAuxDataList(&ZoneAuxDataListItemHead);


#if defined PLOT3D
  if (Plot3DISet)             FREE_ARRAY(Plot3DISet,"Plot3DISet");
  Plot3DISet = NULL;

  if (Plot3DJSet)             FREE_ARRAY(Plot3DJSet,"Plot3DJSet");
  Plot3DJSet = NULL;

  if (Plot3DKSet)             FREE_ARRAY(Plot3DKSet,"Plot3DKSet");
  Plot3DKSet = NULL;

  if (Plot3DGridBase)         FREE_ARRAY(Plot3DGridBase,"Plot3DGridBase");
  Plot3DGridBase = NULL;
  if (Plot3DConnectivityBase) FREE_ARRAY(Plot3DConnectivityBase,"Plot3DConnectivityBase");
  Plot3DConnectivityBase = NULL;
  if (Plot3DIDim)             FREE_ARRAY(Plot3DIDim,"Plot3DIDim");
  Plot3DIDim = NULL;
  if (Plot3DJDim)             FREE_ARRAY(Plot3DJDim,"Plot3DJDim");
  Plot3DJDim = NULL;
  if (Plot3DKDim)             FREE_ARRAY(Plot3DKDim,"Plot3DKDim");
  Plot3DKDim = NULL;
#endif
}


static Boolean_t AllocatePreplotStuff(void)
{
  Boolean_t IsOk = TRUE;
#if defined TECPLOTKERNEL
  int ii;
  /* adjust defaults */
  GetMaxVarZone(&MaxNumVars,&MaxNumZones);
  MaxGeometryPts = GetMaxPtsInALine();

  for (ii=0;ii<DEFAULT_MAXNUMZONESORVARS;ii++)
    PreplotChecksum[ii] = 0;  /* OEM_INVALID_CHECKSUM; */

#endif

  YGeometryValues       = ALLOC_ARRAY(MaxGeometryPts+1,double,"YGeometryValues");
  ZGeometryValues       = ALLOC_ARRAY(MaxGeometryPts+1,double,"ZGeometryValues");
  VarShareZone          = ALLOC_ARRAY(MaxNumVars,LgIndex, "VarShareZone");
  VarName               = ALLOC_ARRAY(MaxNumVars,StringPtr,"VarName");
  ZoneName              = ALLOC_ARRAY(MaxNumZones,StringPtr,"ZoneName");
  ConnectivityShareZone = ALLOC_ARRAY(MaxNumZones,LgIndex,"ConnectivityShareZone");
  ParentZone            = ALLOC_ARRAY(MaxNumZones,LgIndex,"ParentZone");
  StrandID              = ALLOC_ARRAY(MaxNumZones,LgIndex,"StrandID");
  SolutionTime          = ALLOC_ARRAY(MaxNumZones,double,"SolutionTime");
  IMax                  = ALLOC_ARRAY(MaxNumZones,LgIndex,"IMax");
  JMax                  = ALLOC_ARRAY(MaxNumZones,LgIndex,"JMax");
  KMax                  = ALLOC_ARRAY(MaxNumZones,LgIndex,"KMax");
  ZoneType              = ALLOC_ARRAY(MaxNumZones,ZoneDataType,"ZoneType");
  DataPacking           = ALLOC_ARRAY(MaxNumZones,DataPackingType,"DataPacking");
  CurTSet               = ALLOC_ARRAY(SetSize+1,uint32,"CurTSet");
  IStart                = ALLOC_ARRAY(MaxNumZones,LgIndex,"IStart");
  IEnd                  = ALLOC_ARRAY(MaxNumZones,LgIndex,"IEnd");
  ISkip                 = ALLOC_ARRAY(MaxNumZones,LgIndex,"ISkip");
  JStart                = ALLOC_ARRAY(MaxNumZones,LgIndex,"JStart");
  JEnd                  = ALLOC_ARRAY(MaxNumZones,LgIndex,"JEnd");
  JSkip                 = ALLOC_ARRAY(MaxNumZones,LgIndex,"JSkip");
  KStart                = ALLOC_ARRAY(MaxNumZones,LgIndex,"KStart");
  KEnd                  = ALLOC_ARRAY(MaxNumZones,LgIndex,"KEnd");
  KSkip                 = ALLOC_ARRAY(MaxNumZones,LgIndex,"KSkip");
  VarDataType           = ALLOC_ARRAY(MaxNumVars,FieldDataType_e,"VarDataType");
  VarIsCellCentered     = ALLOC_ARRAY(MaxNumVars,Boolean_t,"VarIsCellCentered");
  VarIsPassive          = ALLOC_ARRAY(MaxNumVars,Boolean_t,"VarIsPassive");
  VarMin                = ALLOC_ARRAY(MaxNumVars,double,"VarMin");
  VarMax                = ALLOC_ARRAY(MaxNumVars,double,"VarMax");
  ZoneSet               = ALLOC_ARRAY(SetSize+1,uint32,"ZoneSet");

#if defined PLOT3D
  Plot3DISet              = ALLOC_ARRAY(SetSize+1,uint32,"Plot3DISet");
  Plot3DJSet              = ALLOC_ARRAY(SetSize+1,uint32,"Plot3DJSet");
  Plot3DKSet              = ALLOC_ARRAY(SetSize+1,uint32,"Plot3DKSet");
  Plot3DGridBase          = ALLOC_ARRAY(MaxNumZones,LgIndex,"Plot3DGridBase");
  Plot3DConnectivityBase  = ALLOC_ARRAY(MaxNumZones,LgIndex,"Plot3DConnectivityBase");
  Plot3DIDim              = ALLOC_ARRAY(MaxNumZones,LgIndex,"Plot3DIDim");
  Plot3DJDim              = ALLOC_ARRAY(MaxNumZones,LgIndex,"Plot3DJDim");
  Plot3DKDim              = ALLOC_ARRAY(MaxNumZones,LgIndex,"Plot3DKDim");
#endif

  if ((VarShareZone          == NULL) ||
      (VarName               == NULL) ||
      (ZoneName              == NULL) ||
      (ConnectivityShareZone == NULL) ||
      (ParentZone            == NULL) ||
      (StrandID              == NULL) ||
      (SolutionTime          == NULL) ||
      (IMax                  == NULL) ||
      (JMax                  == NULL) ||
      (KMax                  == NULL) ||
      (ZoneType              == NULL) ||
      (DataPacking           == NULL) ||
      (CurTSet               == NULL) ||
      (IStart                == NULL) ||
      (IEnd                  == NULL) ||
      (ISkip                 == NULL) ||
      (JStart                == NULL) ||
      (JEnd                  == NULL) ||
      (JSkip                 == NULL) ||
      (KStart                == NULL) ||
      (KEnd                  == NULL) ||
      (KSkip                 == NULL) ||
      (VarDataType           == NULL) ||
      (VarIsCellCentered     == NULL) ||
      (VarIsPassive          == NULL) ||
      (VarMin                == NULL) ||
      (VarMax                == NULL) ||
      (ZoneSet               == NULL))
    {
      IsOk = FALSE;
    }

#if defined PLOT3D
  if ((Plot3DGridBase         == NULL) ||
      (Plot3DConnectivityBase == NULL) ||
      (Plot3DIDim             == NULL) ||
      (Plot3DJDim             == NULL) ||
      (Plot3DKDim             == NULL) ||
      (Plot3DISet             == NULL) ||
      (Plot3DJSet             == NULL) ||
      (Plot3DKSet             == NULL))
    {
      IsOk = FALSE;
    }
#endif

  return (IsOk);
}




#if !defined TECPLOTKERNEL
static Boolean_t GetRandomFileName(char **FName)
{
  if ( FName == NULL )
    return FALSE;
  *FName = ALLOC_ARRAY(10, char, "RandomFName");
  if ( *FName == NULL )
    return FALSE;
# if defined (DOS)
    {
      strcpy(*FName, "BLCKFILE");
    }
# else
    {
      strcpy(*FName,"ppXXXXXX");
#     if defined MSWIN
        {
          _mktemp(*FName);
        }
#     else
        {
          /*
           * HP's 'C' compiler doesn't like to have a complex declaration as a
           * statement unless we specify more compiler flags. So to keep
           * compilation of preplot simple we just declare them separately and
           * assign them below instead of declaring and defining the mask as a
           * single statement.
           */
          mode_t OrigUmask;
          int FileDesc;
          /*
           * POSIX compiant behavior is to make
           * sure umask is set correctly first.
           */
          OrigUmask = umask(0022); /* ...should produce rw------- */
          FileDesc = mkstemp(*FName);
          if (FileDesc != -1)
            close(FileDesc);
          umask(OrigUmask);
        }
#     endif
    }
# endif
  return TRUE;
}
#endif

#define SetBitSize (8*sizeof(uint32))

/************************************************************/
static Boolean_t inset(uint32  i,
                     uint32 *set)
{
  uint32 Word;
  uint32 SetMask;

  SetMask = (uint32)1 << (i % SetBitSize);
  Word    = i / SetBitSize;
  return ((Boolean_t)((SetMask & set[Word]) != 0));
}


static Boolean_t issetnull(uint32 *set,
                         uint32  l)
{
  uint32 i;
  for (i = 0; i < l; i++)
    if ((long int)set[i] != (long int)0)
      return((Boolean_t)0);
  return((Boolean_t)1);
}


static void addtoset(uint32  i,
                     uint32 *set)
{
  uint32 Word;

  Word      = i / SetBitSize;
  set[Word] = (set[Word] | ((uint32)1 << (i % SetBitSize)));
}


static void settonull(uint32 *set,
                      uint32 l)
{
  uint32 i;

  for (i = 0; i < l; i++)
    set[i] = 0;
}


uint32 getlastsetmember(uint32 *set)
{
  uint32 word;
  uint32 setmemberbase;
  uint32 setmember;

  word = SetSize-1;

  while ((word > 0) && (set[word] == 0))
    {
      word--;
    }

  setmemberbase = word*32;
  setmember = setmemberbase + SetBitSize - 1;
  while ((setmember > setmemberbase) && (!inset(setmember,set)))
    setmember--;

  return setmember;
}




static void ErrorMessage(const char *S,
                         Boolean_t   ShowLine)
{
  PreplotIsOk = FALSE;
  if (ErrProcessed)
    return;

  ErrProcessed = TRUE;
  /*
   * IsOk may already have be set to FALSE.  Force it to be FALSE.
   */
  if (ShowLine)
    {
      sprintf(ErrString, "Err:  %s\n\n",S);
      if (LinePos < 50)
        {
          Boolean_t InsertedBar = FALSE;
          int CurLinePos = 0;
          char *ErrPtr;

          sprintf(&ErrString[strlen(ErrString)],
                  "Error occurred on line %d near position\nmarked with \"@\" below:\n\n",
                  LineNumber);

          ErrPtr = &ErrString[strlen(ErrString)];
          while ((Line[CurLinePos] != '\0') && (CurLinePos < 200))
            {
              if (CurLinePos == LinePos)
                {
                  *ErrPtr++ = '@';
                  InsertedBar = TRUE;
                }
              *ErrPtr++ = Line[CurLinePos++];
            }
          if (!InsertedBar)
            *ErrPtr++ = '@';
          *ErrPtr = '\0';
        }
      else
        sprintf(&ErrString[strlen(ErrString)],
                "Error occurred on line number %d\n\n",LineNumber);
    }
  else
    sprintf(ErrString,"Err: %s",S);
#if !defined TECPLOTKERNEL
  printf("%s\n\n",ErrString);
#endif
}

#if !defined TECPLOTKERNEL
static void DiskIOError(void)
{
  ErrorMessage("Cannot write to disk!!  Check disk space!",FALSE);
}
#endif

static void ErrFile(char *FName)
{
  char TString[MaxCharsFileName+50];
  sprintf(TString,"Cannot find input file %s\n",FName);
  ErrorMessage(TString,FALSE);
}

static void WarnMsg(const char *S,
                    Boolean_t     ShowLine)
{

#if !defined TECPLOTKERNEL
  if (NumWarns < MAXNUMWARNINGS)
    {
      putchar('\n');
      if (ShowLine)
        {
          int   I;
          for (I = 0; I <= LinePos+4; I++)
            putchar(' ');
          printf("V");
          for (I = 0; I < 3; I++)
            putchar('-');
          printf("Warning: %s\n",S);
          printf("%5d %s\n\n",LineNumber,Line);
        }
      else
        printf("Warning: %s\n\n",S);
    }
  NumWarns++;
  if (NumWarns == MAXNUMWARNINGS)
    {
      printf("Warning Limit Exceeded... Further warnings will not be printed\n");
    }
#endif
}


static void Reset_NodeList(LgIndex NumPoints)
{
  if ( NodeVarList != NULL )
    FREE_ARRAY(NodeVarList,"node var list");

  NodeVarList = ALLOC_ARRAY(NumPoints,NodeVarType,"node var list");

  if ( NodeVarList == NULL )
    ErrorMessage("Cannot allocate temporary memory for node var values",FALSE);

  LastNodeInList = 0;
} /* Reset_NodeList */


static void Add_To_NodeList(LgIndex   Index,
                            double    Value)
{
  LgIndex   pp;
  LgIndex   VV = ROUND2(Value);

  LastNodeInList++;
  pp = LastNodeInList;
  while ( (pp > 1) && (VV < NodeVarList[pp-1].val) )
    {
      NodeVarList[pp] = NodeVarList[pp-1];
      pp--;
    }
  if ( (pp == 1) || (VV > NodeVarList[pp-1].val) )
    {
      NodeVarList[pp].ii  = Index;
      NodeVarList[pp].val = VV;
    }
  else
    ErrorMessage("Node Values repeated.", TRUE);

} /* Add_To_NodeList() */


static LgIndex   Find_In_NodeList(double Value)
{
  LgIndex   hi,lo,mid;
  LgIndex   val;
  LgIndex   VV = ROUND2(Value);

  hi = LastNodeInList;
  lo = 1;

  while ( hi >= lo )
    {
      mid = ( hi + lo ) / 2;
      val =  NodeVarList[mid].val;
      if ( VV < val )
        hi = mid - 1;
      else if ( VV > val )
        lo = mid + 1;
      else
        return(NodeVarList[mid].ii);
    }

  return(0);

} /* Find_In_NodeList() */


static void CheckIfValue(void)
{
  if (!PreplotIsOk)
    return;

  if (CurToken != ValueToken)
    ErrorMessage("Expecting a value",TRUE);
}


static int GetNextLimit(char       **CPtrPtr,
                        LgIndex      Default,
                        Boolean_t     *IsOk)
{
  LgIndex   Sum = Default;

  if (CPtrPtr && *CPtrPtr && **CPtrPtr)
    {
      if (**CPtrPtr != ',')
        {
          Sum = 0;
          while ((**CPtrPtr != ',') &&
                 (**CPtrPtr != ' ') &&
                 (**CPtrPtr != '\0'))
            {
              if (isdigit(**CPtrPtr))
                Sum = Sum*10 + **CPtrPtr - '0';
              else
                *IsOk = FALSE;
              (*CPtrPtr)++;
            }
        }
      (*CPtrPtr)++;
    }
  return (Sum);
}



static Boolean_t SetIJLimits(LgIndex      *IJStart,
                           LgIndex      *IJEnd,
                           LgIndex      *IJSkip,
                           char         *S)
{
  LgIndex   StartZ,EndZ,Z;
  LgIndex   NStart,NEnd,NSkip;
  Boolean_t IsOk = TRUE;
  char   *CPtr = S;

  if (Echo)
    printf("Set IJ Limits, >%s<\n",S);

  StartZ = GetNextLimit(&CPtr,0,&IsOk);
  /* translate result and make zero based for looping */
  if (StartZ == 0)
    {
      /* all zones */
      StartZ = 0;
      EndZ   = MaxNumZones - 1;
    }
  else
    {
      /* a single zone */
      StartZ--;
      EndZ = StartZ;
    }

  NStart = GetNextLimit(&CPtr,1,&IsOk);
  NEnd   = GetNextLimit(&CPtr,0,&IsOk);
  NSkip  = GetNextLimit(&CPtr,1,&IsOk);

  for (Z = StartZ; IsOk && (Z <= EndZ); Z++)
    {
      IJStart[Z] = NStart;
      IJEnd[Z]   = NEnd;
      IJSkip[Z]  = NSkip;
    }
  return (IsOk);
}

/**
 */
static Boolean_t WriteBinaryByte(FILE *File,
                                 Byte  ByteValue)
{
  Boolean_t IsOk;
  size_t    NumValuesWritten;

  REQUIRE(VALID_REF(File));

  NumValuesWritten = FWRITE(&ByteValue,sizeof(ByteValue),1,File);
  IsOk = (Boolean_t)(NumValuesWritten == 1);

  ENSURE(VALID_BOOLEAN(IsOk));
  return IsOk;
}

/**
 */
static Boolean_t WriteBinaryShort(FILE      *File,
                                  SmInteger  ShortValue)
{
  Boolean_t IsOk;
  size_t    NumValuesWritten;

  REQUIRE(VALID_REF(File));

  if (ReverseOutputBytes)
    ReverseBytes(&ShortValue, sizeof(ShortValue));

  NumValuesWritten = FWRITE(&ShortValue,sizeof(ShortValue),1,File);
  IsOk = (Boolean_t)(NumValuesWritten == 1);

  ENSURE(VALID_BOOLEAN(IsOk));
  return IsOk;
}

/**
 */
static Boolean_t WriteBinaryInt(FILE    *File,
                                LgIndex  IntValue)
{
  Boolean_t IsOk;
  size_t    NumValuesWritten;

  REQUIRE(VALID_REF(File));

  if (ReverseOutputBytes)
    ReverseBytes(&IntValue, sizeof(IntValue));

# if defined OLDCRAY
    {
      int    TempI  = IntValue;
      int    i      = 1;
      int    type   = 1; 
      int    bitoff = 0;
      char   Int4Buffer[4];

      CRAY2IEG(&type,&i,Int4Buffer,&bitoff,&TempI);
      NumValuesWritten = FWRITE(Int4Buffer,sizeof(IntValue),1,File);
    }
# else
    {
      NumValuesWritten = FWRITE(&IntValue,sizeof(IntValue),1,File);
    }
# endif

  IsOk = (Boolean_t)(NumValuesWritten == 1);

  ENSURE(VALID_BOOLEAN(IsOk));
  return IsOk;
}

/**
 */
static Boolean_t WriteBinaryFloat(FILE  *File,
                                  float  FloatValue)
{
  Boolean_t IsOk;
  size_t    NumValuesWritten;

  REQUIRE(VALID_REF(File));

  if (ReverseOutputBytes)
    ReverseBytes(&FloatValue, sizeof(FloatValue));

# if defined OLDCRAY
    {
      double TempD  = (double)FloatValue;
      int    i      = 1;
      int    type   = 2; 
      int    bitoff = 0;
      char   Real4Buffer[4];

      CRAY2IEG(&type,&i,Real4Buffer,&bitoff,&TempD);
      NumValuesWritten = FWRITE(Real4Buffer,sizeof(FloatValue),1,File);
    }
# else
    {
      NumValuesWritten = FWRITE(&FloatValue,sizeof(FloatValue),1,File);
    }
# endif

  IsOk = (Boolean_t)(NumValuesWritten == 1);

  ENSURE(VALID_BOOLEAN(IsOk));
  return IsOk;
}

/**
 */
static Boolean_t WriteBinaryDouble(FILE   *File,
                                   double  DoubleValue)
{
  Boolean_t IsOk;
  size_t    NumValuesWritten;

  REQUIRE(VALID_REF(File));

  if (ReverseOutputBytes)
    ReverseBytes(&DoubleValue, sizeof(DoubleValue));

# if defined OLDCRAY
    {
      double TempD  = DoubleValue;
      int    i      = 1;
      int    type   = 8; 
      int    bitoff = 0;
      char   Real8Buffer[8];

      CRAY2IEG(&type,&i,Real8Buffer,&bitoff,&TempD);
      NumValuesWritten = FWRITE(Real8Buffer,sizeof(DoubleValue),1,File);
    }
# else
    {
      NumValuesWritten = FWRITE(&DoubleValue,sizeof(DoubleValue),1,File);
    }
# endif

  IsOk = (Boolean_t)(NumValuesWritten == 1);

  ENSURE(VALID_BOOLEAN(IsOk));
  return IsOk;
}

/**
 */
static void WriteI(FILE       *F,
                   LgIndex    I)
{
  if (!PreplotIsOk)
    return;

  if (!WriteBinaryInt(F, I))
    DiskIOError();
}

/**
 */
static float DoubleToSingle(double D)
{
  float S;
  if ((D > -1.0E-36) && (D < 1.0E-36))
    S = 0.0;
  else if (D > 1.0E36)
    S = 1.0E36F;
  else if (D < -1.0E36)
    S = -1.0E36F;
  else
    S = (float)D;
  return (S);
}

/**
 */
static double ClipDouble(double D)
{
  double S;
  if ((D > -SMALLDOUBLE ) && (D < SMALLDOUBLE))
    S = 0.0;
  else if (D > LARGEDOUBLE)
    S = LARGEDOUBLE;
  else if (D < -LARGEDOUBLE)
    S = -LARGEDOUBLE;
  else
    S = D;
  return (S);
}

/**
 */
static void WriteR(FILE           *F,
                   double          R,
                   FieldDataType_e DT)
{
  if (!PreplotIsOk)
    return;
  switch (DT)
    {
      case FieldDataType_Double :
        {
          double D = ClipDouble(R);
          if (!WriteBinaryDouble(F, D))
            DiskIOError();
        } break;
      case FieldDataType_Float :
        {
          float S = DoubleToSingle(R);
          if (!WriteBinaryFloat(F, S))
            DiskIOError();
        } break;
      case FieldDataType_Int32 :
        {
          LgIndex L;
          if (R > LARGELONG)
            L = LARGELONG;
          else if (R < -LARGELONG)
            L = -LARGELONG;
          else
            L = (LgIndex)R;

          if (!WriteBinaryInt(F, L))
            DiskIOError();
        } break;
      case FieldDataType_Int16 :
        {
          short S;
          if (R > LARGESHORT)
            S = LARGESHORT;
          else if (R < -LARGESHORT)
            S = -LARGESHORT;
          else
            S = (short)R;

          if (!WriteBinaryShort(F, S))
            DiskIOError();
        } break;
      case FieldDataType_Byte :
        {
          unsigned char B;
          if (R > 255)
            B = 255;
          else if (R < 0)
            B = 0;
          else
            B = (unsigned char)R;

          if (!WriteBinaryByte(F, B))
            DiskIOError();
        } break;
      case FieldDataType_Bit :
        {
          if (R >= 1.0)
            CurByte |= (01 << CurBit);
          CurBit++;
          if (CurBit == 8)
            {
              if (!WriteBinaryByte(F, CurByte))
                DiskIOError();
              CurBit  = 0;
              CurByte = 0;
            }
        } break;
      default :
        {
          CHECK(FALSE);
        } break;
    }
}

/**
 */
static void TrimAndStuffString(char      **SPtr,
                               const char *S,
                               size_t      MaxLen)
{
  if (PreplotIsOk)
    {
      size_t LenUsed = strlen(S);
      while (LenUsed > 0 && S[LenUsed-1] == ' ')
        LenUsed--;

      if (LenUsed > MaxLen)
        LenUsed = MaxLen;

      if (*SPtr != NULL)
        FREE_ARRAY(*SPtr,"non null stuff string");

      (*SPtr) = ALLOC_ARRAY(LenUsed+1,char,"stuff string");

      if ((*SPtr) == NULL)
        ErrorMessage("Out of heap space for strings!",TRUE);

      if (LenUsed != 0)
        strncpy(*SPtr,S,LenUsed);
      (*SPtr)[LenUsed] = '\0';
    }
}


static void TrimAndCopyCurData(char   *S,
                               size_t MaxLen)
{
  size_t L;

  CurData[MaxLen] = '\0';
  strcpy(S,CurData);
  L = strlen(S);
  while (L > 0 && S[L-1] == ' ')
    L--;
  S[L] = '\0';
}


/**
 * Return a duplicate of the string or NULL if sufficient memory is not
 * available.
 */
static char *DupString(const char *String)
{
  char *Result;

  REQUIRE(VALID_REF(String));

  Result = ALLOC_ARRAY(strlen(String) + 1, char, "duplicate string");
  if (Result != NULL)
    strcpy(Result, String);

  ENSURE(Result == NULL || (VALID_REF(Result) && strcmp(Result, String) == 0));
  return Result;
}


/**
 * Remove any leading white space from the string and return
 * a reference to it. NOTE: The input string is modified.
 */
static char *StringFlushLeft(char *String)
{
  char *Result = String;
  char *Start = String;

  REQUIRE(VALID_REF(String));

  /* move the substring beginning at the first non-whitespace */
  /* character to the head of the string                      */
  while (isspace(*Start))
    Start++;
  if (Start != String)
    memmove(String, Start, strlen(Start) + 1);

  ENSURE(VALID_REF(Result) && Result == String);
  return Result;
}


/**
 * Remove any trailing white space from the string and return
 * a reference to it. NOTE: The input string is modified.
 */
static char *StringFlushRight(char *String)
{
  char *Result = String;
  char *End = NULL;
  
  REQUIRE(VALID_REF(String));

  for (End = &(String[strlen(String)]); End != String && isspace(End[-1]); End--)
    End[-1] = '\0';

  ENSURE(VALID_REF(Result) && Result == String);
  return Result;
}


/**
 * Remove any leading and trailing white space from the string 
 * and return a reference to it.  The return value is not
 * absolutely necessary since the input string is modified
 * but it is convenient sometimes.
 * NOTE: The input string is modified but no memory is
 * allocated nor deallocated.
 */
static char *TrimLeadAndTrailSpaces(char *String)
{
  REQUIRE((String == NULL) || VALID_REF(String));
  if (String)
    return (StringFlushLeft(StringFlushRight(String)));
  else
    return String;
}


static Boolean_t CompareIdent(const char *S,
                              const char *ID)
{
  const char *SPtr = S;
  const char *IPtr = ID;
  while (*SPtr)
    {
      if (toupper(*SPtr) != toupper(*IPtr))
        return (FALSE);
      SPtr++;
      IPtr++;
    }
  return ((Boolean_t)(*IPtr == '\0'));
}


/*
 * NOTE: Unix files contain \n at the end.
 *       DOS files contain \r \n at the end (and sometimes extra \r's)
 *       Package files will contain a \0 at the end of the layout file.
 *  
 *       This should work regardless of whether the file is opened as
 *       ASCII or binary.
 *
 *       Code lifted from "ReadLine()" function in ioutil.c
 */
static Boolean_t GetALine(FILE *F)
{
  Boolean_t IsOk = FALSE;
  short   C;

  C = fgetc(F);

  if ((C != EOF) && (C != '\0'))
    {
      IsOk = TRUE;

      LineLen = 0;
      while ((C != EOF) &&
             (C != '\0') &&
             (C != '\n') &&
             (C != '\r') &&
             (LineLen < MaxLineIndex-1))
        {
          Line[LineLen++] = (char)C;
          C = fgetc(F);
        }

      if (LineLen >= MaxLineIndex-1)
        {
          IsOk = FALSE;
          ErrorMessage("Line Too Long",TRUE);
        }
      else
        {
          Line[LineLen] = '\0';
        }

      /*
       * Chew up possible "extra" carriage returns from DOS
       */
      while (C == '\r')
        C = fgetc(F);
    }
  return (IsOk);
}



static Boolean_t GetNextLine(FILE *F)
{
  Boolean_t Done = FALSE;

  while (!Done)
    {
      if (!GetALine(F))
        return (FALSE);
      else
        Done = (*Line && (*Line != '#'));
      LineNumber++;
#if defined TECPLOTKERNEL
      if (CheckTimeOut())
        {
          _Gr_CheckInterrupt(NULL,__FILE__,__LINE__);
          if (Interrupted && !(IsInterfaceSuspended() || InBatchMode))
            PreplotIsOk = FALSE;
        }
#endif
    }

  if (Echo > 1)
    printf("%5d: %s",LineNumber,Line);
  LinePos = -1;
  return (TRUE);
}

static Boolean_t CheckTokenStr(const char *S)
{
  Boolean_t Result = TRUE;
  char S2[MaxChrsTextString+1];
  int  ii;

  ii = 0;
  while (Result                &&
         (CurData[ii] != '\0') &&
         (ii < MaxChrsTextString))
    {
      if (islower(CurData[ii]))
        S2[ii] = toupper(CurData[ii]);
      else
        S2[ii] = CurData[ii];
      if (S[ii] == '\0')
        Result = FALSE;
      ii++;
    }
  S2[ii] = '\0';

  if (Result)
    Result = (strcmp(S2,S) == 0);

  return (Result);
}


static Boolean_t CheckPartialTokenStr(const char *S)
{
  Boolean_t Result = TRUE;
  char S2[MaxChrsTextString+1];
  size_t SLen;
  size_t ii;

  SLen = strlen(S);

  ii = 0;
  while (Result                &&
         (CurData[ii] != '\0') &&
         (ii < SLen )          &&
         (ii < MaxChrsTextString))
    {
      if (islower(CurData[ii]))
        S2[ii] = toupper(CurData[ii]);
      else
        S2[ii] = CurData[ii];
      if (S[ii] == '\0')
        Result = FALSE;
      ii++;
    }
  S2[ii] = '\0';

  if (Result)
    Result = (strcmp(S2,S) == 0);

  return (Result);
}


static void SkipToken(FILE *F)
{
  while ((LinePos < LineLen)    &&
         (Line[LinePos] != ' ') &&
         (Line[LinePos] != '\t'))
    LinePos++;
}


static LgIndex AssignLgIndex(double D)
{
  LgIndex L = 0;
  if ((D > 2147483646) || (D < -2147483646))
    ErrorMessage("Integer out of range",TRUE);
  else
    L = ROUND2(D);

  return (L);
}



static void GetToken(Boolean_t  TreatParenAsAlpha,
                     Boolean_t  OkToGetNextLine,
                     FILE    *F)
{
  LgIndex        I;
  LgIndex        TempR;
  char           S[40];
  int            IValue;
  DOUBLE         DValue;
  Boolean_t      EFound;
  Boolean_t      DFound;
  short          C;
  static LgIndex RecursionLevel = 0;
  Boolean_t      IsProcessingAuxData;

  RecursionLevel++; /* keep track of recursion level */

  /*
   * Are we currently looking for the dataset, variable, or zone auxiliary data
   * identifier token?
   */
  IsProcessingAuxData = (CurToken == DATASETAUXDATAToken ||
                         CurToken == VARAUXDATAToken     ||
                         (CurToken == IdentToken &&
                          CompareIdent(CurData, "AUXDATA")));

  do /* convenient block from which to break */
    {
      if (!PreplotIsOk)
        break;

      if (RepeatLength_g > 0)
        {
          CurTValue = RepeatValue_g;
          CurToken  = ValueToken;
          RepeatLength_g--;
          break;
        }

      CurData[0] = '\0';
      CurToken = NullToken;

      while ((Line[LinePos] == ' ')  ||
             (Line[LinePos] == ',')  ||
             (Line[LinePos] == '\r') ||
             (Line[LinePos] == '\t') ||
             (Line[LinePos] == '\\') ||
             (LinePos >= LineLen))
        {
          if (LinePos >= LineLen)
            {
              if (OkToGetNextLine)
                {
                  if (!GetNextLine(F))
                    {
                      CurToken = EndofFileToken;
                      break;
                    }
                }
              else
                {
                  CurToken = EndofVarLineToken;
                  break;
                }
            }
          LinePos++;
        }

      if (CurToken == EndofFileToken ||
          CurToken == EndofVarLineToken)
        break;

      if (Line[LinePos] == '=')
        {
          CurToken = EqualsToken;
          LinePos++;
        }
      else if (Line[LinePos] == '[' ||
               Line[LinePos] == ']')
        {
          /*
           * Special set processing.
           */
          if (Line[LinePos] == '[')
            {
              /*
               * Sets are processed recursively, therefore if an '[' token is
               * found at any other time it is an error.
               */
              BracketNestLevel++;
              if (BracketNestLevel == 1)
                {
                  /* parse the set by recursively calling GetToken */
                  LinePos++;

                  settonull(CurTSet,SetSize);

                  GetToken(TreatParenAsAlpha,OkToGetNextLine,F);

                  /* we are expecting at least one variable in the set */
                  if ((CurToken != ValueToken &&
                       CurToken != SequenceToken) && PreplotIsOk)
                    ErrorMessage("Expecting a set member.",TRUE);

                  while ((CurToken == ValueToken ||
                          CurToken == SequenceToken) && PreplotIsOk)
                    {
                      LgIndex Member;
                      if (CurToken == ValueToken)
                        {
                          Member = ROUND2(CurTValue) - 1;
                          if (0 <= Member && Member < MaxNumSetMembers)
                            {
                              addtoset(Member, CurTSet);
                              GetToken(TreatParenAsAlpha,OkToGetNextLine,F);
                            }
                          else
                            ErrorMessage("Invalid set member.",TRUE);
                        }
                      else if (CurToken == SequenceToken)
                        {
                          if (0 <= CurTSeqStart-1 &&
                                   CurTSeqStart-1 <= CurTSeqEnd-1 &&
                                                     CurTSeqEnd-1 < MaxNumSetMembers)
                            {
                              for (Member = CurTSeqStart - 1;
                                   Member <= CurTSeqEnd - 1;
                                   Member++)
                                addtoset(Member, CurTSet);

                              GetToken(TreatParenAsAlpha,OkToGetNextLine,F);
                            }
                          else
                            ErrorMessage("Invalid set member sequence.",TRUE);
                        }
                      else
                        {
                          CHECK(FALSE);
                        }
                    }
                }
              else
                ErrorMessage("Sets cannot be nested.", TRUE);
            }
          else if (Line[LinePos] == ']')
            {
              /*
               * Sets are processed recursively (see '[' above), therefore if
               * an ']' token is found at any other time it is an error.
               */
              if (BracketNestLevel == 1)
                {
                  BracketNestLevel--;
                  CurToken = SetToken;
                  LinePos++;
                }
              else
                ErrorMessage("Unexpected set character, ']', found.", TRUE);
            }
        }
      else if ((Line[LinePos] == '(') && !TreatParenAsAlpha)
        {
          CurToken = LeftParenToken;
          ParenTokenNestLevel++;
          LinePos++;
        }
      else if ((Line[LinePos] == ')') && !TreatParenAsAlpha)
        {
          CurToken = RightParenToken;
          ParenTokenNestLevel--;
          LinePos++;
        }
      else if ((Line[LinePos] == '-') &&
               !(isdigit(Line[LinePos+1]) || (Line[LinePos+1] == '.')))
        CurToken = UnknownToken;
      else if ((isdigit(Line[LinePos])) ||
               (Line[LinePos] == '.')   ||
               (Line[LinePos] == '+')   ||
               (Line[LinePos] == '-'))
        {
          CurToken = ValueToken;
          EFound   = FALSE;
          DFound   = FALSE;
          I        = 0;
          while ((I < 40)                 &&
                 (CurToken == ValueToken) &&
                 (LinePos < LineLen)      &&
                 (isdigit(C = Line[LinePos]) || (C == 'E')
                  || (C == 'D')
                  || (C == 'e')
                  || (C == 'd')
                  || (C == '.')
                  || (C == '+')
                  || (C == '-')))
            {
              if (C == '.')
                DFound = TRUE;
              else if (isalpha(C))
                {
                  EFound = TRUE;
                  C = 'E';
                }
              S[I++] = (char)C;

              if (C == '-')
                {
                  /*
                   * Are we dealing with a number sequence? In other
                   * words, where 1-5 is the sequence 1 through 5.
                   * NOTE: No white space is allowed between the number
                   *       and the sequence domain separator, '-'.
                   */
                  if ((ParenTokenNestLevel != 0 || BracketNestLevel != 0) && I > 1 && !EFound && !DFound)
                    {
                      CurToken = SequenceToken;
                      S[I] = '\0';
                      if (sscanf(S,"%d",&IValue) == EOF)
                        {
                          CurToken = UnknownToken;
                        }
                      else
                        {
                          CurTSeqStart = IValue;

                          /* scan for the sequence end value */
                          for (I = 0, LinePos++;
                               I < 40 && LinePos < LineLen && isdigit(C = Line[LinePos]);
                               I++, LinePos++)
                            {
                              S[I] = (char)C;
                            }
                          S[I] = '\0';
                          if (sscanf(S,"%d",&IValue) == EOF)
                            CurToken = UnknownToken;
                          else if (IValue <= CurTSeqStart)
                            ErrorMessage("Invalid sequence syntax: end sequence value "
                                   "must be larger than the start value.",TRUE);
                          else
                            CurTSeqEnd = IValue;

                          /*
                           * Don't over increment LinePos as it is updated at the
                           * bottom of the while number collecting the value
                           * characters.
                           */
                          if (PreplotIsOk)
                            LinePos--;
                        }
                    }
                  else
                    {
                      if (EFound)
                        {
                          if (!isalpha(Line[LinePos-1]))
                            CurToken = UnknownToken;
                        }
                      else if (I > 1)
                        {
                          /*
                           * Support arcane number type where
                           * 1-5 is equivalent to 1E-5.
                           */
                          EFound = TRUE;
                          S[I-1] = 'E';
                          S[I++] = '-';
                        }
                    }
                }
              else if (!EFound && (C == '+') && (I > 1))
                {
                  /*
                   * Support arcane number type where
                   * 1+5 is equivalent to 1E+5.
                   */
                  EFound = TRUE;
                  S[I-1] = 'E';
                  S[I++] = '+';
                }
              LinePos++;
            }

          if (CurToken == ValueToken)
            {
              S[I] = '\0';
              if (sscanf(S,DOUBLE_SCANF_FMT,&DValue) == EOF)
                CurToken = UnknownToken;
              else
                CurTValue = DValue;
#if defined TECPLOTKERNEL
              if ( IsOemLaunch || IsDemoLaunch )
                {
                  strcpy(OemSaveAscii,S); /* Might need to add this string representation
                                            of the field data value to the oem checksum, but
                                            we don't know if we have a field data value right now... */
                }
#endif /* TECPLOTKERNEL */

              if (Line[LinePos] == '*') /* repeat */
                {
                  TempR = AssignLgIndex(CurTValue) - 1;
                  LinePos++;
                  GetToken(FALSE,TRUE,F);
                  if ((CurToken == ValueToken) && (TempR >= 0.0))
                    {
                      RepeatValue_g  = CurTValue;
                      RepeatLength_g = TempR;
                    }
                  else if (PreplotIsOk)
                    ErrorMessage("Bad Repeat",TRUE);
                }
            }
        }
      else if (Line[LinePos] == '"')              /* stringToken */
        {
          CurToken   = StringToken;
          I          = 0;
          LinePos++;
          while ((I < MaxLineIndex)      &&
                 (I < MaxChrsTextString) &&
                 (LinePos < LineLen)     &&
                 (Line[LinePos] != '"'))
            {
              unsigned char ch;

              /* to make preplot backward compatible a three character */
              /* "\\n" sequence is converted to a new line character;  */
              /* this was part of bug fix #800470                      */
              if (LinePos+3 < LineLen &&
                  (Line[LinePos+0] == '\\' &&
                   Line[LinePos+1] == '\\' &&
                   Line[LinePos+2] == 'n'))
                {
                  LinePos += 2;
                  CurData[I++] = '\n';
                }
              else
                {
                  if ((Line[LinePos] == '\\') && ((LinePos < LineLen-1)))
                    LinePos++;
                  ch = Line[LinePos];
                  if ( ch<32 || ( 127<ch && ch<160 ) || ch>255 )
                    CurData[I++] = ' ';
                  else
                    CurData[I++] = ch;
                }
              LinePos++;
            }
          if ((LinePos < LineLen) && (Line[LinePos] == '"'))
            {
              LinePos++;
              CurData[I] = '\0';
            }
          else
            {
              CurData[0] = '\0';
              CurToken = UnknownToken;
            }
        }
      else
        {
          CurToken = IdentToken;
          I        = 0;
          while ((I < MaxLineIndex)      &&
                 (I < MaxChrsTextString) &&
                 (LinePos < LineLen)     &&
                 (Line[LinePos] != ' ')  &&
                 (Line[LinePos] != ',')  &&
                 (TreatParenAsAlpha ||
                  (Line[LinePos] != ')')) &&
                 (Line[LinePos] != '\t') &&
                 (Line[LinePos] != '\r') &&
                 (Line[LinePos] != '\\') &&
                 (Line[LinePos] != '='))
            {
              unsigned char ch = Line[LinePos];
              if ( ch<32 || ( 127<ch && ch<160 ) || ch>255 )
                CurData[I++] = ' ';
              else
                CurData[I++] = ch;
              LinePos++;
            }
          CurData[I] = '\0';

          if (!IsProcessingAuxData)
            {
              if (CheckTokenStr("ZONE"))
                CurToken = ZONEToken;
              else if (CheckTokenStr("FECONNECT"))
                CurToken = DupConnectToken;
              else if (CheckTokenStr("TITLE"))
                CurToken = TITLEToken;
              else if (CheckTokenStr("DATASETAUXDATA"))
                CurToken = DATASETAUXDATAToken;
              else if (CheckTokenStr("VARAUXDATA"))
                CurToken = VARAUXDATAToken;
              else if (CheckTokenStr("VARIABLES"))
                CurToken = VARIABLESToken;
              else if (CheckTokenStr("GEOMETRY"))
                CurToken = GEOMETRYToken;
              else if (CheckTokenStr("TEXT"))
                CurToken = TEXTToken;
              else if (CheckTokenStr("CUSTOMLABELS"))
                CurToken = CUSTOMLABELToken;
              else if (CheckTokenStr("USERREC"))
                CurToken = USERRECToken;
            }
        }
      if ((Echo >= 3) && ((CurToken == IdentToken) || (CurToken == StringToken)))
        {
          printf("TokenString = %s\n",CurData);
        }
    } while (FALSE); /* once */

  RecursionLevel--; /* keep track of recursion level */
}



#if defined PLOT3D
static int Plot3D_GetBinaryInt(FILE *F)
{
#if defined CRAYIEEE
  char   Int4Buffer[8];   /* 4? */
  int    i      = 1;
  int    type   = 1;
  int    bitoff = 0;
  long   I;
  FREAD(Int4Buffer,4,1,F);
  if (Plot3DIsForeign)
    ReverseBytes(Int4Buffer,4);

  IEG2CRAY(&type,&i,Int4Buffer,&bitoff,&I);
#else
  LgIndex I;
  FREAD(&I,sizeof(LgIndex),1,F);
  if (Plot3DIsForeign)
    ReverseBytes(&I,sizeof(LgIndex));
#endif

  return ((LgIndex)I);
}



#if defined OLDCRAY
static DOUBLE Plot3D_GetBinaryReal(FILE *F)
{

  float          R = 0.0;
#if defined CRAYIEEE
  char   Real4Buffer[8];   /* 4? */
  int    i      = 1;
  int    type   = 2;
  int    bitoff = 0;
  long   I;
  FREAD(Real4Buffer,4,1,F);
  if (Plot3DIsForeign)
    ReverseBytes(Real4Buffer,4);

  IEG2CRAY(&type,&i,Real4Buffer,&bitoff,&R);
#else
  LgIndex         *I = (LgIndex *)&R;
  unsigned char *C = (unsigned char *)&R;
  FREAD(&R,8,1,F);
  if (Plot3DIsForeign)
    ReverseBytes(&R,8);

  /* Weed out block markers?????
   * Sometimes a block marker?? appears in the middle of nowhere.
   * This is perhaps some sort of paragraph boundary for files on
   * disk.  Anyway, if this occurs then the following code removes
   * known bad combinations and patches up the problem.
   */
#if defined WEEDMIDBLOCKS
  if (!((C[0] == 61)  ||
        (C[0] == 62)  ||
        (C[0] == 63)  ||
        (C[0] == 64)  ||
        (C[0] == 189) ||
        (C[0] == 190) ||
        (C[0] == 191) ||
        (C[0] == 192)) &&
        (*I != 0))
    {
#if !defined TECPLOTKERNEL
      if (Plot3DBadBlockCount < 200)
        printf("# %d %d %d %d %d %d %d %d\n",
                  C[0],C[1],C[2],C[3],C[4],C[5],C[6],C[7]);
#endif
      Plot3DBadBlockCount++;
      FREAD(&R,8,1,F);
      if (Plot3DIsForeign)
        ReverseBytes(&R,8);
    }
#endif
#endif

  return ((DOUBLE)R);
}
#endif /* OLDCRAY */


#if !defined OLDCRAY 
static DOUBLE Plot3D_GetBinaryReal(FILE *F)
{
  float R = 0.0;
  
  FREAD(&R,4,1,F);
  if (Plot3DIsForeign)
    ReverseBytes(&R,4);

  return ((DOUBLE)R);
}
#endif


#if defined TECPLOTKERNEL
static long GetCount = 0;
#endif


static void  Plot3D_GetToken(FILE       *F,
                             Boolean_t     IsInt)
{
  short       C;
  LgIndex     I;
  LgIndex     TempR;
  char        S[40];
  DOUBLE      DValue;
  DOUBLE      AbsDValue;
  Boolean_t     DecimalOrEFound;

#if defined TECPLOTKERNEL
  GetCount++;
  if (CheckTimeOut())
    {
      _Gr_CheckInterrupt(NULL,__FILE__,__LINE__);
      if (Interrupted && !(IsInterfaceSuspended() || InBatchMode))
        PreplotIsOk = FALSE;
    }
#endif

  if (Plot3DInputIsBinary)
    {
      if (IsInt)
        CurTValue = (DOUBLE)Plot3D_GetBinaryInt(F);
      else
        CurTValue = Plot3D_GetBinaryReal(F);
    }
  else
    {
      if (F == InFile)
        {
          if (RepeatLength_g > 0)
            {
              RepeatLength_g--;
              CurTValue = RepeatValue_g;
              CurToken  = ValueToken;
              return;
            }
        }
      else
        {
          if (RepeatLength_q > 0)
            {
              RepeatLength_q--;
              CurTValue = RepeatValue_q;
              CurToken  = ValueToken;
              return;
            }
        }
    
      CurToken = NullToken;

      C = fgetc(F);
      while ((C != EOF) &&
            ((C == ' ')  ||
             (C == ',')  ||
             (C == '\t') ||
             (C == '\r') ||
             (C == '\n')))
        {
          C = fgetc(F);
        }

      if (C == EOF)
        CurToken = EndofFileToken;
      else if ((isdigit(C) ||
               (C == '.')  ||
               (C == '+')  ||
               (C == '-')))
        {
          CurToken        = ValueToken;
          DecimalOrEFound = FALSE;
          I     = 0;
          while ((I < 40)  &&
                 (isdigit(C) || (C == 'E')
                             || (C == 'e')
                             || (C == 'D')
                             || (C == 'd')
                             || (C == '.')
                             || (C == '+')
                             || (C == '-')))
            {
              if ((C == 'd') || (C == 'D') || (C == 'e'))
                C = 'E';
              S[I++]  = (char)C;
              if ((C == '.') || (C == 'E'))
                DecimalOrEFound = TRUE;
              C = fgetc(F);
            }

          S[I] = '\0';
          if (DecimalOrEFound)
            {
              if (sscanf(S,DOUBLE_SCANF_FMT,&DValue) == EOF)
                CurToken = UnknownToken;
              else
                {
                  AbsDValue = ABS(DValue);
                  if (AbsDValue < 1.0E-31)
                    CurTValue = 0.0;
                  else if (DValue >  1.0E31)
                    CurTValue =  1.0E31;
                  else if (DValue < -1.0E31)
                    CurTValue = -1.0E31;
                  else
                    CurTValue = DValue;
                }
            }
          else
            {
              int IntValue;
              if (sscanf(S,"%d",&IntValue) == EOF)
                CurToken = UnknownToken;
              else
                CurTValue = (double)IntValue;
            }
          if (C == '*')
            {
              TempR = (LgIndex)(CurTValue+0.01) - 1;
              Plot3D_GetToken(F,IsInt);
              if (CurToken == ValueToken)
                {
                  if (F == InFile)
                    {
                      RepeatValue_g  = CurTValue;
                      RepeatLength_g = TempR;
                    }
                  else 
                    {
                      RepeatValue_q  = CurTValue;
                      RepeatLength_q = TempR;
                    }
                }
              else
                ErrorMessage("Bad Repeat",FALSE);
            }
        }
    }
}



static void Plot3D_GetRecordMarks(FILE *F)
{
  if (Plot3DInputIsBinary)
    Plot3D_GetToken(F,TRUE);
}


static void Plot3D_GetAllRecordMarks(void)
{
  if (InFile_q)
    Plot3D_GetRecordMarks(InFile_q);
  if (InFile_f)
    Plot3D_GetRecordMarks(InFile_f);
  Plot3D_GetRecordMarks(InFile);
}

#endif /*Plot3D*/



static Boolean_t RemoveEqualsSign(Boolean_t TreatParenAsAlpha)
{
  GetToken(TreatParenAsAlpha,TRUE,InFile);
  if (CurToken == EqualsToken)
    {
      GetToken(TreatParenAsAlpha,TRUE,InFile);
      return (TRUE);
    }
  else
    return (FALSE);
}


static void GetAnInteger(LgIndex   *I)
{

  if (RemoveEqualsSign(FALSE))
    {
      CheckIfValue();
      *I = ABS(AssignLgIndex(CurTValue));
    }
  else
    ErrorMessage("Missing an Equals sign",TRUE);
}



static void GetAReal(double *R,
                     double  Min,
                     double  Max)
{
  if (RemoveEqualsSign(FALSE))
    {
      CheckIfValue();
      if ((CurTValue < Min) || (CurTValue > Max))
        ErrorMessage("Value out of Range",TRUE);
      *R = CurTValue;
    }
  else
    ErrorMessage("Missing an Equals sign",TRUE);
}


static Boolean_t GetSet(const char *ListString,
                      uint32     *Set,
                      const char *S)
{
  const char *SetPtr = ListString;
  LgIndex  I;
  LgIndex  Start,End,Skip;

  settonull(Set,SetSize);

  while (*SetPtr)
    {
      if (isdigit(*SetPtr))
        {
          Skip = 1;
          Start = *SetPtr++ - '0';
          while (isdigit(*SetPtr))
            Start = Start*10 + *SetPtr++ - '0';
          Start = ((Start > MaxNumSetMembers) ? MaxNumSetMembers : Start);
          if (*SetPtr == ':')
            {
              SetPtr++;
              if (!isdigit(*SetPtr))
                return (FALSE);
              End = *SetPtr++ - '0';
              while (isdigit(*SetPtr))
                End = End*10 + *SetPtr++ - '0';
              End = ((End > MaxNumSetMembers) ? MaxNumSetMembers : End);
              if (*SetPtr == ':')
                {
                  SetPtr++;
                  if (!isdigit(*SetPtr))
                    return (FALSE);
                  Skip = *SetPtr++ - '0';
                  while (isdigit(*SetPtr))
                    Skip = Skip*10 + *SetPtr++ - '0';
                  Skip = ((Skip > MaxNumSetMembers) ? MaxNumSetMembers : Skip);
                }
            }
          else
            End = Start;

          for (I = Start; I <= End; I += Skip)
            addtoset(I-1,Set);
          addtoset(End-1,Set);
        }
      else
        SetPtr++;
    }

#if !defined TECPLOTKERNEL
  printf("%s: ",S);
  for (I = 0; I < SetSize*sizeof(uint32); I++)
    if (inset(I,Set))
      printf("%d,",I+1);
  putchar('\n');
#endif
  return (TRUE);
}

/**
 */
static void WriteScaledTokenValue(FILE            *F,
                                  double           ScaledTValue,
                                  Boolean_t        WriteData,
                                  FieldDataType_e  DT,
                                  Boolean_t        RecordVarMinMax,
                                  double          *VarMinValue,
                                  double          *VarMaxValue)
{
  REQUIRE(VALID_BOOLEAN(WriteData));
  REQUIRE(VALID_BOOLEAN(RecordVarMinMax));
  REQUIRE(VALID_REF(VarMinValue));
  REQUIRE(VALID_REF(VarMaxValue));

  if (!PreplotIsOk)
    return;

  if (Echo == 9)
    printf("%G\n",ScaledTValue);
  if (WriteData)
    {
      WriteR(F,ScaledTValue,DT);
#if defined TECPLOTKERNEL
      if ( IsOemLaunch || IsDemoLaunch )
        {
          UPDATEOEMCHECKSUM(&PreplotChecksum[CurZone],
                            OemSaveAscii,
                            strlen(OemSaveAscii),
                            1,
                            FALSE);
        }
#endif
      /* keep track of the min/max value for variables */
      if (RecordVarMinMax)
        {
          if (ScaledTValue < *VarMinValue)
            *VarMinValue = ScaledTValue;
          if (ScaledTValue > *VarMaxValue)
            *VarMaxValue = ScaledTValue;
        }
    }
}

/**
 */
static void GetBlock(FILE            *F,
                     Boolean_t        WriteData,
                     LgIndex          IStart,
                     LgIndex          IEnd,
                     LgIndex          ISkip,
                     LgIndex          IMax,
                     LgIndex          JStart,
                     LgIndex          JEnd,
                     LgIndex          JSkip,
                     LgIndex          JMax,
                     LgIndex          KStart,
                     LgIndex          KEnd,
                     LgIndex          KSkip,
                     LgIndex          KMax,
                     LgIndex          VarNum, /* -1 for geometries */
                     FieldDataType_e  DT,
                     Boolean_t        IsCellCentered,
                     double           ScaleFact,
                     double          *VarMinValue,
                     double          *VarMaxValue)
{
  LgIndex  N = 0;
  if (PreplotIsOk)
    {
      Boolean_t RecordVarMinMax = (VarNum != -1);
      if (RecordVarMinMax)
        {
          *VarMinValue =  LARGEDOUBLE;
          *VarMaxValue = -LARGEDOUBLE;
        }

      if (ZoneType[CurZone] == ORDERED)
        {
          LgIndex I,J,K;
          LgIndex FinalIMax = IsCellCentered ? MAX(IMax-1, 1) : IMax;
          LgIndex FinalJMax = IsCellCentered ? MAX(JMax-1, 1) : JMax;
          LgIndex FinalKMax = IsCellCentered ? MAX(KMax-1, 1) : KMax;

          /*
           * As of binary version 104 we output binary data using the classic
           * plus layout that does not include the ghost cells of the slowest
           * moving index that is greater than one.
           */
          LgIndex IMaxAdjust = 0;
          LgIndex JMaxAdjust = 0;
          LgIndex KMaxAdjust = 0;
          if (KMax > 1)
            KMaxAdjust = 1;
          else if (JMax > 1)
            JMaxAdjust = 1;
          else if (IMax > 1)
            IMaxAdjust = 1;

          for (K = 1; K <= FinalKMax && PreplotIsOk; K++)
            {
              for (J = 1; J <= FinalJMax && PreplotIsOk; J++)
                {
                  for (I = 1; I <= FinalIMax && PreplotIsOk; I++)
                    {
                      if (CurToken != ValueToken)
                        {
                          if (CurToken == EndofFileToken)
                            {
                              char EMsg[100];
                              sprintf(EMsg,"Unexpected End of file.  "
                                      "Need more values, IJK=%d,%d,%d",
                                      I,J,K);
                              ErrorMessage(EMsg,FALSE);
                            }
                          else
                            ErrorMessage("Bad Value",TRUE);
                        }

                      if ((I >= IStart) && (I <= IEnd) &&
                          (J >= JStart) && (J <= JEnd) &&
                          (K >= KStart) && (K <= KEnd) &&
                          ((I == IEnd) || (((I-IStart) % ISkip) == 0)) &&
                          ((J == JEnd) || (((J-JStart) % JSkip) == 0)) &&
                          ((K == KEnd) || (((K-KStart) % KSkip) == 0)))
                        {
                          N++; /* keep track of the number of values written */
                          WriteScaledTokenValue(F, ScaleFact*CurTValue, WriteData,
                                                DT, RecordVarMinMax,
                                                VarMinValue, VarMaxValue);
                        }

                      GetToken(FALSE,TRUE,InFile);
                    }

                  /*
                   * As of binary data file version 103 we output the ghost
                   * cells for binary data. Just fill them with zeros.
                   */
                  if (IsCellCentered && (FinalIMax < IMax-IMaxAdjust) && WriteData)
                    {
                      N++; /* keep track of the number of values written */
                      WriteR(F,0.0,DT);
                    }
                }
              if (IsCellCentered && (FinalJMax < JMax-JMaxAdjust) && WriteData) /* see note above */
                for (I = 1; (I <= IMax-IMaxAdjust) && PreplotIsOk; I++)
                  {
                    N++; /* keep track of the number of values written */
                    WriteR(F,0.0,DT);
                  }
            }
          if (IsCellCentered && (FinalKMax < KMax-KMaxAdjust) && WriteData) /* see note above */
            for (J = 1; (J <= JMax-JMaxAdjust) && PreplotIsOk; J++)
            for (I = 1; (I <= IMax-IMaxAdjust) && PreplotIsOk; I++)
              {
                N++; /* keep track of the number of values written */
                WriteR(F,0.0,DT);
              }
        }
      else
        {
          LgIndex I, EndIndex;

          if (IsCellCentered)
            EndIndex = JMax;
          else
            EndIndex = IMax;

          for (I = 0; I < EndIndex && PreplotIsOk; I++)
            {
              if (CurToken != ValueToken)
                {
                  if (CurToken == EndofFileToken)
                    {
                      char EMsg[100];
                      sprintf(EMsg,"Unexpected End of file.  "
                                   "Need to process %d more values.",
                                   EndIndex-I);

                      ErrorMessage(EMsg,FALSE);
                    }
                  else
                    ErrorMessage("Bad Value",TRUE);
                }

              N++; /* keep track of the number of values written */
              WriteScaledTokenValue(F, ScaleFact*CurTValue, WriteData,
                                    DT, RecordVarMinMax,
                                    VarMinValue, VarMaxValue);

              if (VarNum >=0 && VarNum == NodeVar)
                Add_To_NodeList(I+1, CurTValue);

              GetToken(FALSE,TRUE,InFile);
            }
        }
    }

  /*
   * Pad last byte with zeros if bit data.
   */
  if ((DT == FieldDataType_Bit) && WriteData)
    {
      N = N % 8;
      while (N++ < 8)
        WriteR(F,0.0,DT);
    }
}


#if defined PLOT3D
/**
 */
static void Plot3D_ExtractBlock(FILE    *File,
                                LgIndex  IVar,
                                LgIndex  Plane,
                                LgIndex  Grid,
                                short    IJKSetting,
                                double  *VarMin,
                                double  *VarMax)
{
  LgIndex   I,J,K;
  LgIndex   IMax     = Plot3DIDim[Grid];
  LgIndex   JMax     = Plot3DJDim[Grid];
  LgIndex   KMax     = Plot3DKDim[Grid];
  LgIndex   GridBase = Plot3DGridBase[Grid];

#if !defined TECPLOTKERNEL
  if (Echo)
    printf("%d    %d\n",IVar+1,Plane+1);
  else
    printf("%d,",IVar+1);
  fflush(stdout);
#endif

# define IJKOffset(I,J,K, IMax,JMax)    GridBase + ((I) + (IMax)*((J) + (JMax)*(K)))
  switch (IJKSetting)
    {
      case 'I' : /* I is Constant */
        {
          for (K = 0; K < KMax; K++)
          for (J = 0; J < JMax; J++)
            {
              double VarValue = Plot3DVarArray[IVar][IJKOffset(Plane,J,K, IMax,JMax)];
              WriteR(File, VarValue, FieldDataType_Float);
              if (VarValue < *VarMin)
                *VarMin = VarValue;
              if (VarValue > *VarMax)
                *VarMax = VarValue;
            }
        } break;
      case 'J' : /* J is Constant */
        {
          for (K = 0; K < KMax; K++)
          for (I = 0; I < IMax; I++)
            {
              double VarValue = Plot3DVarArray[IVar][IJKOffset(I,Plane,K, IMax,JMax)];
              WriteR(File, VarValue, FieldDataType_Float);
              if (VarValue < *VarMin)
                *VarMin = VarValue;
              if (VarValue > *VarMax)
                *VarMax = VarValue;
            }
        } break;
      case ' ' : /* Unknown */
      case 'K' : /* K is Constant */
        {
          for (J = 0; J < JMax; J++)
          for (I = 0; I < IMax; I++)
            {
              double VarValue = Plot3DVarArray[IVar][IJKOffset(I,J,Plane, IMax,JMax)];
              WriteR(File, VarValue, FieldDataType_Float);
              if (VarValue < *VarMin)
                *VarMin = VarValue;
              if (VarValue > *VarMax)
                *VarMax = VarValue;
            }
        } break;
    }
# undef IJKOffset
}

/**
 * Go back and re-write the var min/max values.
 */
static void Plot3D_RewriteVarMinMaxValues(FILE    *File,
                                          long     VarMinMaxOffset,
                                          double  *VarMin,
                                          double  *VarMax)
{
  int  J;
  long CurrentOffset = FTELL(File);
  PreplotIsOk = (CurrentOffset != -1 &&
                 FSEEK(File, VarMinMaxOffset, SEEK_SET) != -1);
  for (J = 0; J < NumVars; J++)
    {
      WriteR(File, VarMin[J], FieldDataType_Double);
      WriteR(File, VarMax[J], FieldDataType_Double);
    }
  if (PreplotIsOk)
    PreplotIsOk = (FSEEK(File, CurrentOffset, SEEK_SET) != -1);
}

/*
 * Currently just skips flags...
 *
 */
static void Plot3D_LoadFlags(FILE      *InF,
                             LgIndex    IGrid)
{
  LgIndex I;
  LgIndex NumElements;

  if (Plot3DJDim[IGrid] > 0)
    NumElements = Plot3DJDim[IGrid];
  else
    NumElements = Plot3DKDim[IGrid];

  for (I = 0; I < NumElements; I++)
    {
      Plot3D_GetToken(InF,TRUE);
    }
}





static void Plot3D_LoadConnectAndFlags(FILE      *InF,
                                       LgIndex    IGrid)
{
  LgIndex NumConnect;
  LgIndex I;
  LgIndex BaseI;
  LgIndex NumNodes;

  if (Plot3DJDim[IGrid] > 0)
    {
      NumNodes   = 3;
      NumConnect = Plot3DJDim[IGrid]*3;
    }
  else
    {
      Plot3D_LoadFlags(InF,IGrid);
      NumNodes   = 4;
      NumConnect = Plot3DKDim[IGrid]*4;
    }
  BaseI      = Plot3DConnectivityBase[IGrid];
#if !defined TECPLOTKERNEL
  printf("Loading Connect, Index ->%d %d\n",IGrid+1,Plot3DConnectivityBase[IGrid]);
#endif
  for (I = 0; I < NumConnect; I++)
    {
#if !defined TECPLOTKERNEL
      if (I % 4000 == 0)
        {
          putchar('.');
          fflush(stdout);
        }
#endif
      Plot3D_GetToken(InF,TRUE);
      Plot3DConnectivityArray[I+BaseI] = (LgIndex)CurTValue;
      if (Echo == 3)
        {
          printf("%5d",(int)CurTValue);
          if ((I % NumNodes) == NumNodes-1)
            putchar('\n');
        }
    }
  if (Plot3DJDim[IGrid] > 0)
    {
      Plot3D_LoadFlags(InF,IGrid);
    }
#if !defined TECPLOTKERNEL
  putchar('\n');
#endif
}




static void Plot3D_LoadVar(FILE      *InF,
                           Boolean_t    IsInt,
                           LgIndex    IVar,
                           LgIndex    N)
{
  LgIndex   I;
  LgIndex   J = 0;
#if !defined TECPLOTKERNEL
  printf("Loading Var,CurIndex ->%d %d\n",IVar+1,Plot3DVarArrayCurIndex[IVar]);
#endif
  for (I = 0; (I < N); I++)
    {
      J++;
#if !defined TECPLOTKERNEL
      if (J == 5000)
        {
          putchar('.');
          fflush(stdout);
          J = 0;
        }
#endif
      Plot3D_GetToken(InF,IsInt);
      Plot3DVarArray[IVar][(Plot3DVarArrayCurIndex[IVar])++] = (float)CurTValue;
      if (Echo == 3)
        {
          printf("%10G",CurTValue);
          if ((I % 7) == 6)
            putchar('\n');
        }
     }
#if !defined TECPLOTKERNEL
   putchar('\n');
#endif
}


#endif




static void RecogVarNames(void)
{
  NumVars = 0;
  if (RemoveEqualsSign(TRUE))
    {
      do
        {
          if ((CurToken == StringToken) || (CurToken == IdentToken))
            {
              if ( NumVars >= MaxNumVars )
#if defined TECPLOTKERNEL
                ErrorMessage("Maximum number of variables exceeded (increase $!Limits MaxPreplotVars)",FALSE);
#else
                ErrorMessage("Maximum number of variables exceeded (increase MaxNumVars)",FALSE);
#endif
              TrimAndStuffString(&VarName[NumVars],CurData,MaxChrsVarName);
              if (PreplotIsOk && Echo)
                printf("Var: %s\n",VarName[NumVars]);
              NumVars++;
            }
          else
            ErrorMessage("Bad variable name for variable:",TRUE);
          GetToken(TRUE,TRUE,InFile);
        }
      while (PreplotIsOk && ((CurToken == StringToken) || (CurToken == IdentToken)));
    }
  else
    ErrorMessage("Missing Equals sign after 'VARIABLES' in header",TRUE);
}


static void GetDupInfo(void)
{
  if (PreplotIsOk)
    {
      if (RemoveEqualsSign(FALSE))
        {
          if (CurToken != LeftParenToken)
            ErrorMessage("Expecting a left parenthesis",TRUE);

          if (PreplotIsOk)
            GetToken(FALSE,TRUE,InFile);

          if (PreplotIsOk &&
              (CurToken != ValueToken    &&
               CurToken != SequenceToken &&
               CurToken != DupConnectToken))
            ErrorMessage("Expecting a variable number",TRUE);

          while (PreplotIsOk &&
                 (CurToken == ValueToken    ||
                  CurToken == SequenceToken ||
                  CurToken == DupConnectToken))
            {
              if (CurToken == ValueToken)
                {
                  LgIndex Var = ROUND2(CurTValue);
                  if ((Var >= 1) && (Var <= NumVars))
                    {
                      VarShareZone[Var-1] = CurZone - 1;
                      GetToken(FALSE,TRUE,InFile);
                    }
                  else
                    ErrorMessage("Invalid value for dup var Assignment",TRUE);
                }
              else if (CurToken == SequenceToken)
                {
                  LgIndex VarSeqValue;
                  for (VarSeqValue = CurTSeqStart;
                       VarSeqValue <= CurTSeqEnd && PreplotIsOk;
                       VarSeqValue++)
                    {
                      if (VarSeqValue >= 1 && VarSeqValue <= NumVars)
                        VarShareZone[VarSeqValue-1] = CurZone - 1;
                      else
                        ErrorMessage("Invalid value for dup var Assignment",TRUE);
                    }
                  GetToken(FALSE,TRUE,InFile);
                }
              else
                {
                  if (CurZone >= 1)
                    ConnectivityShareZone[CurZone] = CurZone - 1;
                  else
                    ErrorMessage("No prior zone is available from which the "
                           "connectivity list can be duplicated.", TRUE);
                  GetToken(FALSE,TRUE,InFile);
                }
            }
          if (PreplotIsOk && (CurToken != RightParenToken))
            ErrorMessage("Expecting a value, FECONNECT, or a right parenthesis",TRUE);
        }
      else
        ErrorMessage("Expecting equals sign",TRUE);
    }
}



/**
 */
static ClippingType GetClipping(void)
{
  ClippingType Result = (ClippingType)-1;

  if (RemoveEqualsSign(FALSE))
    {
      if (CheckTokenStr("CLIPTOAXES"))
        Result = CLIPTOVIEWPORT; /* Deprecated mid v10 but allowed for backwars compatibility. */
      else if (CheckTokenStr("CLIPTOVIEWPORT"))
        Result = CLIPTOVIEWPORT;
      else if (CheckTokenStr("CLIPTOFRAME"))
        Result = CLIPTOFRAME;
      else
        ErrorMessage("Invalid CLIPPING, Need CLIPTOVIEWPORT or CLIPTOFRAME",TRUE);
    }
  else
    ErrorMessage("Missing Equals sign for DATAPACKING Specifier",TRUE);

  return Result;
}

/**
 */
static DataPackingType GetDataPacking(void)
{
  DataPackingType Result = (DataPackingType)-1;

  if (RemoveEqualsSign(FALSE))
    {
      if (CheckTokenStr("POINT"))
        Result = POINTPACKING;
      else if (CheckTokenStr("BLOCK"))
        Result = BLOCKPACKING;
      else
        ErrorMessage("Invalid DATAPACKING, Need POINT or BLOCK",TRUE);
    }
  else
    ErrorMessage("Missing Equals sign for DATAPACKING Specifier",TRUE);

  return Result;
}

/* deprecated: use ZONETYPE and DATAPACKING  */
static FormatType GetFormat(void)
{
  FormatType Result = (FormatType)-1;

  if (RemoveEqualsSign(FALSE))
    {
      if (CheckTokenStr("POINT"))
        Result = IJKPOINT;
      else if (CheckTokenStr("BLOCK"))
        Result = IJKBLOCK;
      else if (CheckTokenStr("FEBLOCK"))
        Result = FEBLOCK;
      else if (CheckTokenStr("FEPOINT"))
        Result = FEPOINT;
      else
        ErrorMessage("Invalid Format, Need POINT, BLOCK, FEPOINT, or FEBLOCK",TRUE);
    }
  else
    ErrorMessage("Missing Equals sign for Format Specifier",TRUE);

  return Result;
}


/**
 */
static ZoneDataType GetZoneDataType(void)
{
  ZoneDataType Result = (ZoneDataType)-1;

  if (RemoveEqualsSign(FALSE))
    {
      if (CheckTokenStr("ORDERED"))
        Result = ORDERED;
      else if (CheckTokenStr("FELINESEG"))
        Result = FELINESEG;
      else if (CheckTokenStr("FETRIANGLE"))
        Result = FETRIANGLE;
      else if (CheckTokenStr("FEQUADRILATERAL"))
        Result = FEQUADRILATERAL;
      else if (CheckTokenStr("FETETRAHEDRON"))
        Result = FETETRAHEDRON;
      else if (CheckTokenStr("FEBRICK"))
        Result = FEBRICK;
      else
        ErrorMessage("Invalid ZONETYPE, Need ORDERED, FELINESEG, FETRIANGLE, "
               "FEQUADRILATERAL, FETETRAHEDRON, or FEBRICK",TRUE);
    }
  else
    ErrorMessage("Missing Equals sign for ZONETYPE Specifier",TRUE);

  return Result;
}

/* deprecated: use ZONETYPE and DATAPACKING */
static ElementType GetElementType(void)
{
  ElementType Result = (ElementType)-1;

  if (RemoveEqualsSign(FALSE))
    {
      if (CheckTokenStr("TRIANGLE"))
        Result = TRIANGLE;
      else if (CheckTokenStr("QUADRILATERAL"))
        Result = QUADRILATERAL;
      else if (CheckTokenStr("TETRAHEDRON"))
        Result = TETRAHEDRON;
      else if (CheckTokenStr("BRICK"))
        Result = BRICK;
      else if (CheckTokenStr("LINESEG"))
        Result = LINESEG;
      else
        ErrorMessage("Invalid Element type, Need LINESEG, TRIANGLE, "
               "QUADRILATERAL, TETRAHEDRON, or BRICK",TRUE);
    }
  else
    ErrorMessage("Missing Equals sign for Format Specifier",TRUE);

  return Result;
}


#define Custom1_C 8

static void GetColor(LgIndex   *C)
{
  if (RemoveEqualsSign(FALSE))
    {
      Boolean_t IsOk = TRUE;
      if (CheckTokenStr("BLACK"))
        *C = 0;
      else if (CheckTokenStr("RED"))
        *C = 1;
      else if (CheckTokenStr("GREEN"))
        *C = 2;
      else if (CheckTokenStr("BLUE"))
        *C = 3;
      else if (CheckTokenStr("CYAN"))
        *C = 4;
      else if (CheckTokenStr("YELLOW"))
        *C = 5;
      else if (CheckTokenStr("PURPLE"))
        *C = 6;
      else if (CheckTokenStr("WHITE"))
        *C = 7;
      else 
        {
          char *NPtr = NULL;
          if (CheckPartialTokenStr("CUSTOM"))
            NPtr = &CurData[strlen("CUSTOM")];
          else if (CheckPartialTokenStr("CUST"))
            NPtr = &CurData[strlen("CUST")];

          if (NPtr)
            {
              int CustomColorNumber = 0;
              while (IsOk && *NPtr)
                {
                  if (isdigit(*NPtr))
                    {
                      CustomColorNumber = CustomColorNumber*10 + *NPtr - '0';
                      NPtr++;
                    }
                  else
                    IsOk = FALSE;
                }
              if (IsOk)
                {
                  if (CustomColorNumber > MaxCustomColors)
                    IsOk = FALSE;
                  else
                    *C = Custom1_C + CustomColorNumber - 1;
                }
            }
          else
            IsOk = FALSE;
        }
      if (!IsOk)
        ErrorMessage("Invalid Color",TRUE);
    }
  else
    ErrorMessage("Missing Equals Sign in Color Assignment",TRUE);
}


static void GetDataType(FieldDataType_e *DT,
                        Boolean_t          IsVar)
{
  Boolean_t Done = FALSE;
  int     I    = 0;
  if (!RemoveEqualsSign(FALSE))
    ErrorMessage("Missing Equals Sign in Data Type Assignment",TRUE);

  if (IsVar)
    {
      if (CurToken != LeftParenToken)
        ErrorMessage("Expecting a left parenthesis",TRUE);

      if (PreplotIsOk)
        GetToken(FALSE,TRUE,InFile);
    }

  while (PreplotIsOk && !Done && (I < MaxNumVars))
    {
      if (CheckTokenStr("SINGLE") ||
          CheckTokenStr("FLOAT"))
        DT[I] = FieldDataType_Float;
      else if (CheckTokenStr("DOUBLE"))
        DT[I] = FieldDataType_Double;
      else
        {
          if (!IsVar)
            ErrorMessage("Only allowed to use LONGINT, SHORTINT,\nBYTE and BIT data types with zone\nfield data",TRUE);
          if (CheckTokenStr("LONGINT"))
            DT[I] = FieldDataType_Int32;
          else if (CheckTokenStr("SHORTINT"))
            DT[I] = FieldDataType_Int16;
          else if (CheckTokenStr("BYTE"))
            DT[I] = FieldDataType_Byte;
          else if (CheckTokenStr("BIT"))
            DT[I] = FieldDataType_Bit;
          else
            ErrorMessage("Expecting a Data type or right parenthesis",TRUE);
        }
      I++;
      if (IsVar)
        {
          GetToken(FALSE,TRUE,InFile);
          if (CurToken == RightParenToken)
            Done = TRUE;
        }
      else
        Done = TRUE;
    }
}


static Boolean_t ZoneIsOk(LgIndex Zone)
{
  if (issetnull(ZoneSet,SetSize))
    return (TRUE);
  else
    return (inset(Zone,ZoneSet));
}


/* forward ref */
static AuxDataListItem_s *GetAuxData(const char         *AuxDataTokenName,
                                     AuxDataListItem_s **AuxDataListItem,
                                     LgIndex            *StrandID,
                                     double             *SolutionTime);
/* forward ref */
static void GetVarLocation(void);
/* forward ref */
static void GetPassiveVarList(void);
/* forward ref */
static void GetFaceNeighborMode(void);
/* forware ref */
static void GetFEFaceNeighborsComplete(void);
/* forward ref */
static void GetVarShareList(void);


static void RecogZoneHeader(void)
{
  int N;
  Boolean_t           FEFlagsUsed          = FALSE;
  Boolean_t           ISet                 = FALSE;
  Boolean_t           JSet                 = FALSE;
  Boolean_t           KSet                 = FALSE;
  Boolean_t           NVSet                = FALSE;
  LgIndex             SharedZone           = -1;
  Boolean_t           ZoneTypeSet          = FALSE;
  Boolean_t           DataPackingSet       = FALSE;
  AuxDataListItem_s *ZoneAuxDataListItem = NULL;

  /* deprecated: use ZONETYPE and DATAPACKING */
  FormatType  Format     = IJKPOINT;      /* deprecated */
  ElementType Element    = QUADRILATERAL; /* deprecated */
  Boolean_t   FormatSet  = FALSE;         /* deprecated */
  Boolean_t   ElementSet = FALSE;         /* deprecated */

  if ( CurZone >= MaxNumZones )
    {
#if defined TECPLOTKERNEL
      ErrorMessage("Maximum number of zones exceeded (increase $!Limits MaxPreplotZones)",FALSE);
#else
      ErrorMessage("Maximum number of zones exceeded (increase MaxNumZones)",FALSE);
#endif
      return;
    }

#if !defined TECPLOTKERNEL
  if (!Echo)
    printf("Zone : %3d\n",CurZone+1);
#endif
  /*Set Defaults*/
  TrimAndStuffString(&ZoneName[CurZone],"ZONE xxx",MaxChrsZnTitle);
  ZoneName[CurZone][5] = '0' + (CurZone+1) / 100;
  ZoneName[CurZone][6] = '0' + ((CurZone+1) % 100) / 10;
  ZoneName[CurZone][7] = '0' + (CurZone+1) % 10;
  ZoneColor            = -1;
  ParentZone[CurZone]  = BAD_SET_VALUE;
  StrandID[CurZone]    = STRAND_ID_UNASSIGNED;
  SolutionTime[CurZone]= 0.0;
  IMax[CurZone]        = 1;
  JMax[CurZone]        = 1;
  KMax[CurZone]        = 1;
  ICellDim             = 0; /* i.e. initially not defined */
  JCellDim             = 0; /* i.e. initially not defined */
  KCellDim             = 0; /* i.e. initially not defined */
  NodeVar              = -1;
  ZoneType[CurZone]         = ORDERED;
  DataPacking[CurZone]      = BLOCKPACKING;
  WriteRawFaceNeighborArray = FALSE;
  FaceNeighborMode          = LOCALONETOONE;
  FEFaceNeighborsComplete   = FALSE;
  FaceNeighborConnections   = 0;
  ConnectivityShareZone[CurZone] = -1; /* initially not sharing */

  for (N=0;N<MaxNumVars;N++)
    {
      VarDataType[N] = FieldDataType_Float;
      VarIsCellCentered[N] = FALSE;
      VarIsPassive[N] = FALSE;
      VarMin[N] = 0.0;
      VarMax[N] = 0.0;
      VarShareZone[N] = -1; /* initially not sharing */
    }

  if (CurToken == ZONEToken)
    {
      GetToken(FALSE,TRUE,InFile);
    }

  while ((CurToken == IdentToken) && (PreplotIsOk))
    {
      if (CompareIdent(CurData,"T"))
        {
          if (RemoveEqualsSign(FALSE))
            {
              if ((CurToken == StringToken) || (CurToken == IdentToken))
                TrimAndStuffString(&ZoneName[CurZone],CurData,MaxChrsZnTitle);
              else
                ErrorMessage("Missing or Invalid character string",TRUE);
            }
          else
            ErrorMessage("Missing Equals sign in Zone Title Assignment",TRUE);
        }
      else if (CompareIdent(CurData,"PARENTZONE"))
        {
          GetAnInteger(&ParentZone[CurZone]);
          ParentZone[CurZone]--; /* ASCII file is ones based; make it zero based for binary file */
          if (ParentZone[CurZone] < 0)
            ErrorMessage("PARENTZONE assignment must be to an existing zone within the datafile.",TRUE);
          else if (ParentZone[CurZone] == CurZone)
            ErrorMessage("PARENTZONE assignment may not be self referencing.",TRUE);
        }
      else if (CompareIdent(CurData,"STRANDID"))
        {
          GetAnInteger(&StrandID[CurZone]);
          StrandID[CurZone]--; /* ASCII file is ones based; make it zero based for binary file */
          if (StrandID[CurZone] <= STRAND_ID_PENDING)
            ErrorMessage("STRANDID's must be greater than or equal to 0.",TRUE);
        }
      else if (CompareIdent(CurData,"SOLUTIONTIME"))
        {
          GetAReal(&SolutionTime[CurZone],-LARGEDOUBLE,LARGEDOUBLE);
          /*
           * If the strand ID is yet unassigned, STRAND_ID_UNASSIGNED, change
           * the the value to STRAND_ID_PENDING indicating that we want Tecplot
           * to auto-assign strand ID's.
           */
          if (StrandID[CurZone] == STRAND_ID_UNASSIGNED)
            StrandID[CurZone] = STRAND_ID_PENDING;
        }
      else if (CompareIdent(CurData,"AUXDATA"))
        {
          ZoneAuxDataListItem = GetAuxData("AUXDATA", &ZoneAuxDataListItem, &StrandID[CurZone], &SolutionTime[CurZone]);
          if (ZoneAuxDataListItemHead == NULL)
            ZoneAuxDataListItemHead = ZoneAuxDataListItem; /* keep track of the head */
        }
      else if (CompareIdent(CurData,"D"))
        GetDupInfo();
      else if (CompareIdent(CurData,"C"))
        GetColor(&ZoneColor);
      else if (CompareIdent(CurData,"I"))
        {
          GetAnInteger(&IMax[CurZone]);
          ISet = TRUE;
        }
      else if (CompareIdent(CurData,"N"))
        {
          GetAnInteger(&IMax[CurZone]);
          FEFlagsUsed = TRUE;
          ISet = TRUE;
        }
      else if (CompareIdent(CurData,"J"))
        {
          GetAnInteger(&JMax[CurZone]);
          JSet = TRUE;
        }
      else if (CompareIdent(CurData,"E"))
        {
          GetAnInteger(&JMax[CurZone]);
          FEFlagsUsed = TRUE;
          JSet = TRUE;
        }
      else if (CompareIdent(CurData,"ZONETYPE"))
        {
          ZoneType[CurZone] = GetZoneDataType();
          ZoneTypeSet = TRUE;
        }
      else if (CompareIdent(CurData,"ICELLDIM"))
        {
          GetAnInteger(&ICellDim);
          FEFlagsUsed = TRUE;
        }
      else if (CompareIdent(CurData,"JCELLDIM"))
        {
          GetAnInteger(&JCellDim);
          FEFlagsUsed = TRUE;
        }
      else if (CompareIdent(CurData,"KCELLDIM"))
        {
          GetAnInteger(&KCellDim);
          FEFlagsUsed = TRUE;
        }
      else if (CompareIdent(CurData,"VARLOCATION"))
        {
          GetVarLocation();
        }
      else if (CompareIdent(CurData,"PASSIVEVARLIST"))
        {
          GetPassiveVarList();
        }
      else if (CompareIdent(CurData,"FACENEIGHBORMODE"))
        {
          GetFaceNeighborMode();
        }
      else if (CompareIdent(CurData,"FEFACENEIGHBORSCOMPLETE"))
        {
          GetFEFaceNeighborsComplete();
        }
      else if (CompareIdent(CurData,"FACENEIGHBORCONNECTIONS"))
        {
          GetAnInteger(&FaceNeighborConnections);
        }
      else if (CompareIdent(CurData,"CONNECTIVITYSHAREZONE"))
        {
          GetAnInteger(&ConnectivityShareZone[CurZone]);
          /* convert the zone number from a one to zero based value */
          ConnectivityShareZone[CurZone]--;
          if (ConnectivityShareZone[CurZone] < 0)
            ErrorMessage("Invalid zone number specified for "
                   "CONNECTIVITYSHAREZONE.", TRUE);
          else if (ConnectivityShareZone[CurZone] >= CurZone)
            ErrorMessage("Connectivity list can only share from "
                   "a lower numbered zone.", TRUE);
        }
      else if (CompareIdent(CurData,"VARSHARELIST"))
        {
          GetVarShareList();
        }
      /* deprecated: use ZONETYPE and DATAPACKING */
      else if (CompareIdent(CurData,"ET"))
        {
          Element = GetElementType();
          ElementSet = TRUE;
          FEFlagsUsed = TRUE;
        }
      else if (CompareIdent(CurData,"NV"))
        {
          GetAnInteger(&NodeVar);
          NodeVar--;
          NVSet = TRUE;
          FEFlagsUsed = TRUE;
        }
      else if (CompareIdent(CurData,"K"))
        {
          GetAnInteger(&KMax[CurZone]);
          KSet = TRUE;
        }
      else if (CompareIdent(CurData,"DATAPACKING"))
        {
          DataPacking[CurZone] = GetDataPacking();
          DataPackingSet = TRUE;
        }
      /* deprecated: use ZONETYPE and DATAPACKING  */
      else if (CompareIdent(CurData,"F"))
        {
          Format = GetFormat();
          FormatSet = TRUE;
        }
      else if (CompareIdent(CurData,"DT"))
        GetDataType(VarDataType,TRUE);
      else
        ErrorMessage("Bad Identifier in zone header",TRUE);
      if (PreplotIsOk)
        GetToken(FALSE,TRUE,InFile);
    }

  if (PreplotIsOk)
    {
      /*
       * If the strand ID is yet unassigned, STRAND_ID_UNASSIGNED, change the
       * the value to STRAND_ID_STATIC.
       */
      if (StrandID[CurZone] == STRAND_ID_UNASSIGNED)
        StrandID[CurZone] = STRAND_ID_STATIC;

      if ((ZoneTypeSet || DataPackingSet) &&
          (ElementSet || FormatSet))
        {
          ErrorMessage("Cannot mix 'ZONETYPE' and 'DATAPACKING' options "
                 "with deprecated 'ET' and 'F' options.", FALSE);
        }
      else if (!ZoneTypeSet && !DataPackingSet)
        {
          /* convert old values to new */
          if (Format == IJKBLOCK || Format == IJKPOINT)
            {
              DataPacking[CurZone] = (Format == IJKBLOCK
                                        ? BLOCKPACKING
                                        : POINTPACKING);
              ZoneType[CurZone] = ORDERED;
            }
          else if (Format == FEBLOCK || Format == FEPOINT)
            {
              DataPacking[CurZone] = (Format == FEBLOCK
                                        ? BLOCKPACKING
                                        : POINTPACKING);
              if (Element == LINESEG)
                ZoneType[CurZone] = FELINESEG;
              else if (Element == TRIANGLE)
                ZoneType[CurZone] = FETRIANGLE;
              else if (Element == QUADRILATERAL)
                ZoneType[CurZone] = FEQUADRILATERAL;
              else if (Element == TETRAHEDRON)
                ZoneType[CurZone] = FETETRAHEDRON;
              else if (Element == BRICK)
                ZoneType[CurZone] = FEBRICK;
              else
                CHECK(FALSE);
            }
          else
            {
              CHECK(FALSE);
            }
        }
    }

  if (PreplotIsOk)
    {
      if (DataPacking[CurZone] == POINTPACKING)
        {
          for (N=0; N<MaxNumVars && PreplotIsOk; N++)
            {
              if (VarDataType[N] == FieldDataType_Bit)
                ErrorMessage("Not allowed to use BIT data type when "
                       "data format is POINT or FEPOINT",TRUE);
            }
        }
    }


  if (PreplotIsOk)
    {
      if (ConnectivityShareZone[CurZone] != -1)
        {
          SharedZone = ConnectivityShareZone[CurZone];
        }
      else
        {
          LgIndex Var;
          for (Var = 0, SharedZone = -1; Var < MaxNumVars; Var++)
            {
              if (VarShareZone[Var] != -1)
                {
                  SharedZone = VarShareZone[Var];
                  break;
                }
            }
        }

      /*
       * Make sure that the I,J, and K max values are set.
       */
      if (SharedZone != -1)
        {
          if (ZoneType[CurZone] == ORDERED)
            {
              if (!ISet)
                {
                  IMax[CurZone] = IMax[SharedZone];
#if defined TECPLOTKERNEL
                  WarnMsg("Variables are being duplicated and I is not set.", FALSE);
#else
                  WarnMsg("Variables are being duplicated and I is not set.\n"
                          "         I will be set to value of previous zone.", FALSE);
#endif
                }
              if (!JSet)
                JMax[CurZone] = JMax[SharedZone];
              if (!KSet)
                KMax[CurZone] = KMax[SharedZone];

              ISet = TRUE;
              JSet = TRUE;
              KSet = TRUE;
            }
          else
            {
              if (!ISet)
                IMax[CurZone] = IMax[SharedZone];
              if (!JSet)
                JMax[CurZone] = JMax[SharedZone];

              ISet = TRUE;
              JSet = TRUE;
            }

          /* perform consistency check */
          if (CurZone == 0)
            ErrorMessage("Not allowed to share variables or connectivity "
                         "list for first zone",TRUE);
        }
      else
        {
          if (ZoneType[CurZone] == ORDERED &&
              !ISet && !JSet && !KSet)
            {
              IMax[CurZone] = LargestIndex; /* i.e. read to EOF */
            }

          if (!JSet)
            {
              if (ZoneType[CurZone] != ORDERED)
                JMax[CurZone] = LargestIndex; /* i.e. read to EOF */
              else
                JMax[CurZone] = 1;
            }
        }
    }

  if (PreplotIsOk                  &&
      ZoneType[CurZone] != ORDERED &&
      NVSet && !ISet)
    ErrorMessage("Cannot specify NV without also specifying N",TRUE);

  if (PreplotIsOk && FEFlagsUsed && ZoneType[CurZone] == ORDERED)
    ErrorMessage("N, E, NV, ICELLDIM, JCELLDIM, KCELLDIM "
           "or ET flag used for non-FE type data",TRUE);

  if (PreplotIsOk                       &&
      ConnectivityShareZone[CurZone] != -1 &&
      ZoneType[CurZone] != ZoneType[ConnectivityShareZone[CurZone]])
    ErrorMessage("Connectivity list can only share from "
           "a zone of the same type.", TRUE);

  if (PreplotIsOk && Echo)
    {
      printf("\n");
      printf("ZONE HEADER: T=           %10s\n",ZoneName[CurZone]);
      printf("             PARENTZONE=  %d\n",ParentZone[CurZone]+1);
      printf("             STRANDID=    %d\n",StrandID[CurZone]+1);
      printf("             SOLUTIONTIME=%g\n",SolutionTime[CurZone]);
      printf("             I=           %d\n",IMax[CurZone]);
      printf("             J=           %d\n",JMax[CurZone]);
      printf("             K=           %d\n",KMax[CurZone]);
      printf("             DATAPACKING= %s\n", (DataPacking[CurZone] == BLOCKPACKING
                                                  ? "BLOCK"
                                                  : "POINT"));

      if (ZoneType[CurZone] != ORDERED)
        {
          IStart[CurZone] = 1;
          IEnd[CurZone]   = IMax[CurZone];
          ISkip[CurZone]  = 1;
          JStart[CurZone] = 1;
          JEnd[CurZone]   = 1;
          JSkip[CurZone]  = 1;
        }
    }
  if (PreplotIsOk && !ISet && DataPacking[CurZone] == BLOCKPACKING)
    ErrorMessage("Zone must at least contain I identifier for BLOCK format",TRUE);
  if (PreplotIsOk && !ISet && ZoneType[CurZone] != ORDERED)
    ErrorMessage("Must Specify N (greater than 0)) for FE formats",TRUE);
  if (PreplotIsOk && NVSet && (NodeVar < 0) )
    ErrorMessage("NV must be greater than 0 if specified",TRUE);
  /*
   * Allow IMax[CurZone] == JMax[CurZone] == KMax[CurZone] == 0 (Zombie zone)
   */
  if (PreplotIsOk &&
      (IMax[CurZone] != 0 || JMax[CurZone] != 0 || KMax[CurZone] != 0))
    {
      if (IMax[CurZone] <= 0 )
        ErrorMessage("I must be greater than 0 if specified",TRUE);
      else if ( JMax[CurZone] <= 0 )
        ErrorMessage("J must be greater than 0 if specified",TRUE);
      else if ( KMax[CurZone] <= 0 )
        ErrorMessage("K must be greater than 0 if specified",TRUE);
    }
}

static void ShowColor(LgIndex   C)
{
       if (C == 0)  printf("BLACK\n");
  else if (C == 1)  printf("RED\n");
  else if (C == 2)  printf("GREEN\n");
  else if (C == 3)  printf("BLUE\n");
  else if (C == 4)  printf("CYAN\n");
  else if (C == 5)  printf("YELLOW\n");
  else if (C == 6)  printf("PURPLE\n");
  else if (C == 7)  printf("WHITE\n");
  else if (C == Custom1_C) printf("CUST1\n");
  else if (C == Custom1_C + 1) printf("CUST2\n");
  else if (C == Custom1_C + 2) printf("CUST3\n");
  else if (C == Custom1_C + 3) printf("CUST4\n");
  else if (C == Custom1_C + 4) printf("CUST5\n");
  else if (C == Custom1_C + 5) printf("CUST6\n");
  else if (C == Custom1_C + 6) printf("CUST7\n");
  else if (C == Custom1_C + 7) printf("CUST8\n");
  else printf("????");
}


static void GetArrowheadStyle(void)
{
  if (RemoveEqualsSign(FALSE))
    {
      if (CheckTokenStr("PLAIN"))
        ArrowheadStyle = Arrowhead_Plain;
      else if (CheckTokenStr("FILLED"))
        ArrowheadStyle = Arrowhead_Filled;
      else if (CheckTokenStr("HOLLOW"))
        ArrowheadStyle = Arrowhead_Hollow;
      else
        ErrorMessage("Invalid Arrowhead style, Need PLAIN, FILLED, or HOLLOW",TRUE);
    }
  else
    ErrorMessage("Missing equals sign in Arrowhead assignment",TRUE);
}


static void GetArrowheadAttachment(void)
{
  if (RemoveEqualsSign(FALSE))
    {
      if (CheckTokenStr("NONE"))
        ArrowheadAttachment = ArrowheadAttach_None;
      else if (CheckTokenStr("BEGINNING"))
        ArrowheadAttachment = ArrowheadAttach_AtBeginning;
      else if (CheckTokenStr("END"))
        ArrowheadAttachment = ArrowheadAttach_AtEnd;
      else if (CheckTokenStr("BOTH"))
        ArrowheadAttachment = ArrowheadAttach_AtBothEnds;
      else
        ErrorMessage("Invalid Arrowhead attachment",TRUE);
    }
  else
    ErrorMessage("Missing equals sign in Arrowhead assignment",TRUE);
}


static void GetCoordSys(void)
{
  if (RemoveEqualsSign(FALSE))
    {
      if (CheckTokenStr("FRAME"))
        CoordSys = FRAME;
      else if (CheckTokenStr("GRID"))
        CoordSys = GRID;
/*
      else if (CheckTokenStr("FRAMEOFFSET"))
        CoordSys = FRAMEOFFSET;
*/
      else if (CheckTokenStr("WINDOW"))
        CoordSys = OLDWINDOW;
      else if (CheckTokenStr("XYZGRID") || /* XYZGRID is deprecated from early v10 */
               CheckTokenStr("GRID3D"))
        CoordSys = GRID3D;
      else
        ErrorMessage("Invalid CoordSys, Need GRID, GRID3D, or FRAME",TRUE);
    }
  else
    ErrorMessage("Missing equals sign in CoordSys assignment",TRUE);
}


static void GetScope(void)
{
  if (RemoveEqualsSign(FALSE))
    {
      if (CheckTokenStr("GLOBAL"))
        Scope = GLOBAL;
      else if (CheckTokenStr("LOCAL"))
        Scope = LOCAL;
      else
        ErrorMessage("Invalid SCOPE, Need GLOBAL or LOCAL",TRUE);
    }
  else
    ErrorMessage("Missing equals sign in SCOPE assignment",TRUE);
}


static void GetDrawOrder(void)
{
  if (RemoveEqualsSign(FALSE))
    {
      if (CheckTokenStr("AFTERDATA"))
        DrawOrder = AFTERDATA;
      else if (CheckTokenStr("BEFOREDATA"))
        DrawOrder = BEFOREDATA;
      else
        ErrorMessage("Invalid DRAWORDER, Need AFTERDATA or BEFOREDATA",TRUE);
    }
  else
    ErrorMessage("Missing equals sign in DRAWORDER assignment",TRUE);
}





static void RecogGeometryHeader(void)
{
  Boolean_t XSet     = FALSE;
  Boolean_t YSet     = FALSE;
  Boolean_t ZSet     = FALSE;
  Boolean_t RSet     = FALSE;
  Boolean_t ThetaSet = FALSE;

  /* Set Defaults */
  XX                  = 0.0;
  YY                  = 0.0;
  ZZ                  = 0.0;
  Color               = 0;
  FillColor           = 0;
  IsFilled            = 0;
  TGZone              = -1;
  LineThickness       = 0.1;
  ArrowheadSize       = 5.0;
  ArrowheadAngle      = 20.0;
  ArrowheadAttachment = ArrowheadAttach_None;
  ArrowheadStyle      = Arrowhead_Plain;
  Scope               = GLOBAL;
  DrawOrder           = AFTERDATA;
  CoordSys            = UNDEF;
  LinePattern         = SOLID;
  PatternLength       = 4.0;
  GeomType            = LINE;
  GeomDataPacking     = POINTPACKING;
  GeomDataType        = FieldDataType_Float;
  NumEllipsePts       = 72;

  GetToken(FALSE,TRUE,InFile);
  while ((PreplotIsOk) && (CurToken == IdentToken))
    {
      if (CompareIdent(CurData,"X"))
        {
          GetAReal(&XX,-LARGEDOUBLE,LARGEDOUBLE);
          XSet = TRUE;
        }
      else if (CompareIdent(CurData,"R")) /* use X to hold it */
        {
          GetAReal(&XX,-LARGEDOUBLE,LARGEDOUBLE);
          RSet = TRUE;
        }
      else if (CompareIdent(CurData,"MFC"))
        {
          if (RemoveEqualsSign(FALSE))
            {
              if ((CurToken == StringToken) || (CurToken == IdentToken))
                strcpy(MacroString,CurData);
              else
                ErrorMessage("Expecting a character string",TRUE);
            }
          else
            ErrorMessage("Missing Equals sign in Text Assignment",TRUE);
        }

      else if (CompareIdent(CurData,"Y"))
        {
          GetAReal(&YY,-LARGEDOUBLE,LARGEDOUBLE);
          YSet = TRUE;
        }
      else if (CompareIdent(CurData,"THETA")) /* use Y to hold it */
        {
          GetAReal(&YY,-LARGEDOUBLE,LARGEDOUBLE);
          ThetaSet = TRUE;
        }
      else if (CompareIdent(CurData,"Z"))
        {
          GetAReal(&ZZ,-LARGEDOUBLE,LARGEDOUBLE);
          ZSet = TRUE;
        }
      else if (CompareIdent(CurData,"ZN"))
        {
          GetAnInteger(&TGZone);
          TGZone--;
        }
      else if (CompareIdent(CurData,"CS") ||
               CompareIdent(CurData,"M"))     /* Old */
        GetCoordSys();
      else if (CompareIdent(CurData,"S"))
        GetScope();
      else if (CompareIdent(CurData,"DRAWORDER"))
        GetDrawOrder();
      else if (CompareIdent(CurData,"C"))
        GetColor(&Color);
      else if (CompareIdent(CurData,"EP"))
        {
          GetAnInteger(&NumEllipsePts);
          if ((NumEllipsePts < 3) || (NumEllipsePts > 720 /*MaxPtsCircleOrEllipse*/))
            ErrorMessage("Invalid number of ellipse points",TRUE);
        }
      else if (CompareIdent(CurData,"PL"))
        GetAReal(&PatternLength,0.01,100.0);
      else if (CompareIdent(CurData,"LT"))
        GetAReal(&LineThickness,0.0001,100.0);
      else if (CompareIdent(CurData,"AST"))
        GetArrowheadStyle();
      else if (CompareIdent(CurData,"AAT"))
        GetArrowheadAttachment();
      else if (CompareIdent(CurData,"ASZ"))
        GetAReal(&ArrowheadSize,0.0,50.0);
      else if (CompareIdent(CurData,"AAN"))
        GetAReal(&ArrowheadAngle,1.0,90.0);
      else if (CompareIdent(CurData,"DT"))
        GetDataType(&GeomDataType,FALSE);
      else if (CompareIdent(CurData,"FC"))
        {
          GetColor(&FillColor);
          IsFilled = 1;
        }
      else if (CompareIdent(CurData,"T"))
        {
          if (RemoveEqualsSign(FALSE))
            {
              if (CheckTokenStr("LINE"))
                GeomType = LINE;
              else if (CheckTokenStr("RECTANGLE"))
                GeomType = RECTANGLE;
              else if (CheckTokenStr("SQUARE"))
                GeomType = SQUARE;
              else if (CheckTokenStr("ELLIPSE"))
                GeomType = ELLIPSE;
              else if (CheckTokenStr("CIRCLE"))
                GeomType = CIRCLE;
              else if (CheckTokenStr("LINE3D"))
                GeomType = LINE3D;
              else
                ErrorMessage("Invalid geometry Type, Need LINE,RECTANGLE\n,SQUARE,ELLIPSE, CIRCLE, or LINE3D",TRUE);
            }
          else
            ErrorMessage("Missing Equals Sign in geometry type assignment",TRUE);
        }
      else if (CompareIdent(CurData,"L"))
        {
          if (RemoveEqualsSign(FALSE))
            {
              if (CheckTokenStr("SOLID"))
                LinePattern = SOLID;
              else if (CheckTokenStr("DASHED"))
                LinePattern = DASHED;
              else if (CheckTokenStr("DASHDOT"))
                LinePattern = DASHDOT;
              else if (CheckTokenStr("DASHDOTDOT"))
                LinePattern = DASHDOTDOT;
              else if (CheckTokenStr("DOTTED"))
                LinePattern = DOTTED;
              else if (CheckTokenStr("LONGDASH"))
                LinePattern = LONGDASH;
              else
                ErrorMessage("Invalid Line Type, Need SOLID,DASHED,DASHDOT,DASHDOTDOT,LONGDASH or DOTTED",TRUE);
            }
          else
            ErrorMessage("Missing Equals Sign in line type assignment",TRUE);
        }
      else if (CompareIdent(CurData,"CLIPPING"))
        {
          GeomClipping = GetClipping();
        }
      else if (CompareIdent(CurData,"DATAPACKING"))
        {
          GeomDataPacking = GetDataPacking();
        }
      /* deprecated: use DATAPACKING */
      else if (CompareIdent(CurData,"F"))
        {
          if (GetFormat() == IJKBLOCK)
            GeomDataPacking = BLOCKPACKING;
          else
            GeomDataPacking = POINTPACKING;
        }
      else
        ErrorMessage("Bad Identifier in Geometry header",TRUE);
      if (PreplotIsOk)
        GetToken(FALSE,TRUE,InFile);
    }

  if (PreplotIsOk)
    {
      /* deprecated: use LINE and GRID3D */
      if (GeomType == LINE3D)
        {
          GeomType = LINE;
          CoordSys = GRID3D;
        }
    }

  if (PreplotIsOk &&
      (XSet || YSet || ZSet) &&
      (RSet || ThetaSet))
    {
      ErrorMessage("Cannot mix X,Y, and Z with R and THETA.",TRUE);
    }

  if (PreplotIsOk &&
      (CoordSys == FRAME || CoordSys == UNDEF || CoordSys == OLDWINDOW) &&
      (XX < 0.0 || YY < 0.0))
    {
      ErrorMessage("Geometry origins may not be negative in frame coordinates.",TRUE);
    }

  if (PreplotIsOk && Echo)
    {
      printf("\n");
      printf("GEOM HEADER: X= %G\n",XX);
      printf("             Y= %G\n",YY);
      printf("             Z= %G\n",ZZ);
      printf("            ZN= %d\n",(int)TGZone+1);
      printf("             C= ");
      ShowColor(Color);
      printf("             S= ");
      if (Scope == GLOBAL)
        printf("GLOBAL\n");
      else
        printf("LOCAL\n");

      printf("     DRAWORDER= ");
      if (DrawOrder == AFTERDATA)
        printf("AFTERDATA\n");
      else
        printf("BEFOREDATA\n");

      printf("            CS= ");
      switch (CoordSys)
        {
          case GRID       : printf("GRID\n");    break;
          case UNDEF      : 
          case OLDWINDOW  : 
          case FRAME      : printf("FRAME\n");   break;
          case GRID3D     : printf("GRID3D\n"); break;
          default         : CHECK(FALSE);        break;
        }

      printf("             L= ");
      switch (LinePattern)
        {
          case SOLID      : printf("SOLID\n");      break;
          case DASHED     : printf("DASHED\n");     break;
          case DASHDOT    : printf("DASHDOT\n");    break;
          case DASHDOTDOT : printf("DASHDOTDOT\n"); break;
          case DOTTED     : printf("DOTTED\n");     break;
          case LONGDASH   : printf("LONGDASH\n");   break;
        }

      printf("             T= ");
      switch (GeomType)
        {
          case LINE       : printf("LINE\n");      break;
          case RECTANGLE  : printf("RECTANGLE\n"); break;
          case SQUARE     : printf("SQUARE\n");    break;
          case CIRCLE     : printf("CIRCLE\n");    break;
          case ELLIPSE    : printf("ELLIPSE\n");   break;
          /* deprecated: should never get here as it was converted to LINE above */
          case LINE3D     : CHECK(FALSE);          break;
        }
      printf("           AST= ");
      switch (ArrowheadStyle)
        {
          case Arrowhead_Plain   : printf("PLAIN\n");   break;
          case Arrowhead_Filled  : printf("FILLED\n");  break;
          case Arrowhead_Hollow  : printf("HOLLOW\n");  break;
        }
      printf("           AAT= ");
      switch (ArrowheadAttachment)
        {
          case ArrowheadAttach_None         : printf("NONE\n");      break;
          case ArrowheadAttach_AtBeginning  : printf("BEGINNING\n"); break;
          case ArrowheadAttach_AtEnd        : printf("END\n");       break;
          case ArrowheadAttach_AtBothEnds   : printf("BOTH\n");      break;
        }
      printf("           ASZ= %G\n",ArrowheadSize);
      printf("           AAN= %G\n",ArrowheadAngle);
      printf("           MFC= %s\n",MacroString);

    }
}



static void GetHeightUnits(void)
{
  if (RemoveEqualsSign(FALSE))
    {
      if (CheckTokenStr("GRID"))
        HeightUnits = Units_Grid;
      else if (CheckTokenStr("FRAME"))
        HeightUnits = Units_Frame;
      else if (CheckTokenStr("POINT"))
        HeightUnits = Units_Point;
      else
        ErrorMessage("Invalid character height units, Need GRID, FRAME, or POINT",TRUE);
    }
  else
    ErrorMessage("Missing equals sign in scope assignment",TRUE);
}

static void GetTextAnchor(void)
{
  if (RemoveEqualsSign(FALSE))
    {
      if (CheckTokenStr("LEFT"))
        TextAnchor = TextAnchor_Left;
      else if (CheckTokenStr("CENTER"))
        TextAnchor = TextAnchor_Center;
      else if (CheckTokenStr("RIGHT"))
        TextAnchor = TextAnchor_Right;
      else if (CheckTokenStr("MIDLEFT"))
        TextAnchor = TextAnchor_MidLeft;
      else if (CheckTokenStr("MIDCENTER"))
        TextAnchor = TextAnchor_MidCenter;
      else if (CheckTokenStr("MIDRIGHT"))
        TextAnchor = TextAnchor_MidRight;
      else if (CheckTokenStr("HEADLEFT"))
        TextAnchor = TextAnchor_HeadLeft;
      else if (CheckTokenStr("HEADCENTER"))
        TextAnchor = TextAnchor_HeadCenter;
      else if (CheckTokenStr("HEADRIGHT"))
        TextAnchor = TextAnchor_HeadRight;
      else
        ErrorMessage("Invalid text anchor position",TRUE);
    }
  else
    ErrorMessage("Missing equals sign in text anchor assignment",TRUE);
}


static void RecogTextHeader(void)
{
  Boolean_t XSet     = FALSE;
  Boolean_t YSet     = FALSE;
  Boolean_t ZSet     = FALSE;
  Boolean_t RSet     = FALSE;
  Boolean_t ThetaSet = FALSE;

  /*Set Defaults*/
  XX              = 0.0;
  YY              = 0.0;
  ZZ              = 0.0;
  TGZone          = -1;
  Color           = 0;
  Scope           = GLOBAL;
  CoordSys        = UNDEF;
  Angle           = 0.0;
  FontType        = 1;
  Height          = 3.0;
  HeightUnits     = Units_Frame;
  LineThickness   = 0.4;
  LineSpacing     = 1.0;
  BoxFillColor    = 7;
  BoxOutlineColor = 0;
  BoxMargin       = 10;
  BoxType         = 0;
  TextAnchor      = TextAnchor_Left;

  GetToken(FALSE,TRUE,InFile);
  while ((CurToken == IdentToken) && PreplotIsOk)
    {
      if (CompareIdent(CurData,"T"))
        {
          if (RemoveEqualsSign(FALSE))
            {
              if ((CurToken == StringToken) || (CurToken == IdentToken))
                strcpy(TextString,CurData);
              else
                ErrorMessage("Expecting a character string",TRUE);
            }
          else
            ErrorMessage("Missing Equals sign in Text Assignment",TRUE);
        }

      else if (CompareIdent(CurData,"MFC"))
        {
          if (RemoveEqualsSign(FALSE))
            {
              if ((CurToken == StringToken) || (CurToken == IdentToken))
                strcpy(MacroString,CurData);
              else
                ErrorMessage("Expecting a character string",TRUE);
            }
          else
            ErrorMessage("Missing Equals sign in Text Assingment",TRUE);
        }

      else if (CompareIdent(CurData,"X"))
        {
          GetAReal(&XX,-LARGEDOUBLE,LARGEDOUBLE);
          XSet = TRUE;
        }
      else if (CompareIdent(CurData,"R")) /* use X to hold it */
        {
          GetAReal(&XX,-LARGEDOUBLE,LARGEDOUBLE);
          RSet = TRUE;
        }
      else if (CompareIdent(CurData,"Y"))
        {
          GetAReal(&YY,-LARGEDOUBLE,LARGEDOUBLE);
          YSet = TRUE;
        }
      else if (CompareIdent(CurData,"THETA")) /* use Y to hold it */
        {
          GetAReal(&YY,-LARGEDOUBLE,LARGEDOUBLE);
          ThetaSet = TRUE;
        }
      else if (CompareIdent(CurData,"Z"))
        {
          GetAReal(&ZZ,-LARGEDOUBLE,LARGEDOUBLE);
          ZSet = TRUE;
        }
      else if (CompareIdent(CurData,"CS") ||
               CompareIdent(CurData,"M"))
        {
          short FirstChar = CurData[0];
          GetCoordSys();
          if ((FirstChar == 'M') && (CoordSys == GRID))
            HeightUnits = Units_Grid;
        }
      else if (CompareIdent(CurData,"S"))
        GetScope();
      else if (CompareIdent(CurData,"AN"))
        GetTextAnchor();
      else if (CompareIdent(CurData,"HU"))
        GetHeightUnits();
      else if (CompareIdent(CurData,"LT"))
        GetAReal(&LineThickness,0.0001,100.0);
      else if (CompareIdent(CurData,"LS"))
        GetAReal(&LineSpacing,0.0,5.0);
      else if (CompareIdent(CurData,"A"))
        GetAReal(&Angle,-360.0,360.0);
      else if (CompareIdent(CurData,"ZN"))
        {
          GetAnInteger(&TGZone);
          TGZone--;
        }
      else if (CompareIdent(CurData,"BX"))
        {
          if (RemoveEqualsSign(FALSE))
            {
              if (CheckTokenStr("NOBOX"))
                BoxType = 0;
              else if (CheckTokenStr("FILLED"))
                BoxType = 1;
              else if (CheckTokenStr("HOLLOW"))
                BoxType = 2;
              else
                ErrorMessage("Invalid Box Type",TRUE);
            }
        }
      else if (CompareIdent(CurData,"BXF"))
        GetColor(&BoxFillColor);
      else if (CompareIdent(CurData,"BXO"))
        GetColor(&BoxOutlineColor);
      else if (CompareIdent(CurData,"BXM"))
        GetAReal(&BoxMargin,0.0,2000.0);
      else if (CompareIdent(CurData,"F"))
        {
          if (RemoveEqualsSign(FALSE))
            {
              if (CheckTokenStr("HELV"))
                FontType = 0;
              else if (CheckTokenStr("HELV-BOLD"))
                FontType = 1;
              else if (CheckTokenStr("GREEK"))
                FontType = 2;
              else if (CheckTokenStr("MATH"))
                FontType = 3;
              else if (CheckTokenStr("USER-DEF"))
                FontType = 4;
              else if (CheckTokenStr("TIMES"))
                FontType = 5;
              else if (CheckTokenStr("TIMES-ITALIC"))
                FontType = 6;
              else if (CheckTokenStr("TIMES-BOLD"))
                FontType = 7;
              else if (CheckTokenStr("TIMES-ITALIC-BOLD"))
                FontType = 8;
              else if (CheckTokenStr("COURIER"))
                FontType = 9;
              else if (CheckTokenStr("COURIER-BOLD"))
                FontType = 10;
              else
                ErrorMessage("Invalid Font Type",TRUE);
           }
        }
      else if (CompareIdent(CurData,"H"))
        GetAReal(&Height,0.0,LARGEDOUBLE);
      else if (CompareIdent(CurData,"C"))
        GetColor(&Color);
      else if (CompareIdent(CurData,"CLIPPING"))
        TextClipping = GetClipping();
      else
        ErrorMessage("Bad Identifier in Text header",TRUE);
      if (PreplotIsOk)
        GetToken(FALSE,TRUE,InFile);
    }


  if (PreplotIsOk)
    {
      switch (CoordSys)
        {
          case GRID        :
          case GRID3D      :
            {
            } break;
          case UNDEF       :
          case OLDWINDOW   :
          case FRAME       :
            {
              if (HeightUnits == Units_Grid)
                {
                  ErrorMessage("Cannot use GRID height units for text positioned using FRAME coordinates.",TRUE);
                }
            } break;
          default :
            {
              CHECK(FALSE);
            } break;
        }
    }

  if (PreplotIsOk &&
      (XSet || YSet || ZSet) &&
      (RSet || ThetaSet))
    {
      ErrorMessage("Cannot mix X,Y, and Z with R and THETA.",TRUE);
    }

  if (PreplotIsOk && Echo)
    {
      printf("\n");
      printf("TEXT HEADER: X= %G\n",XX);
      printf("             Y= %G\n",YY);
      printf("             Z= %G\n",ZZ);
      printf("             F= %d\n",(int)FontType);


      printf("            HU= ");
      switch (HeightUnits)
        {
          case Units_Grid  : printf("GRID\n");  break;
          case Units_Frame : printf("FRAME\n"); break;
          case Units_Point : printf("POINT\n"); break;
          case Units_AxisPercentage : /* not used */
          default          : CHECK(FALSE);      break;
        }

      printf("             H= %G\n",Height);
      printf("             A= %G\n",Angle);
      printf("            ZN= %d\n",(int)TGZone+1);
      printf("             C= ");
      ShowColor(Color);
      printf("             S= ");
      if (Scope == GLOBAL)
        printf("GLOBAL\n");
      else
        printf("LOCAL\n");

      printf("            CS= ");
      switch (CoordSys)
        {
          case GRID   : printf("GRID\n");    break;
          case UNDEF  : 
          case OLDWINDOW  : 
          case FRAME  : printf("FRAME\n");   break;
          case GRID3D : printf("GRID3D\n"); break;
          default     : CHECK(FALSE);      break;
        }

      printf("           MFC= %s\n",MacroString);
      printf("             T= %s",TextString);
    }
}



static void RecogCustomLabelHeader(void)
{
  LgIndex   I;

  /*Set Defaults*/
  NumCustomLabels = 0;

  /* Remove the equals sign if one is there and fetch the next token*/
  RemoveEqualsSign(FALSE);
  while (((CurToken == StringToken) || (CurToken == IdentToken)) && PreplotIsOk)
    {
      if (NumCustomLabels == MaxCustomLabels)
        ErrorMessage("Too many custom axis labels",TRUE);
      if (CustomLabel[NumCustomLabels] != NULL)
        FREE_ARRAY (CustomLabel[NumCustomLabels],"custom label");
      CustomLabel[NumCustomLabels] = ALLOC_ARRAY(strlen(CurData)+1,char,"custom label");
      if ( CustomLabel[NumCustomLabels] == NULL )
        ErrorMessage("Unable to allocate memory for custom axis labels",FALSE);
      strcpy(CustomLabel[NumCustomLabels],CurData);
      NumCustomLabels++;
      GetToken(FALSE,TRUE,InFile);
    }
  if (PreplotIsOk && Echo)
    {
      printf("\nCUSTOMLABEL HEADER: N= %d\n",NumCustomLabels);
      for (I = 0; I < NumCustomLabels; I++)
        printf("Label %2d: %s\n",(int)I,CustomLabel[I]);
    }
}

static void RecogUserRecHeader(void)
{
  RemoveEqualsSign(FALSE);
  if (CurToken != StringToken)
    {
      ErrorMessage("Expecting a string",TRUE);
    }

  if (PreplotIsOk)
    {
      UserRecString = ALLOC_ARRAY(strlen(CurData)+1,char,"user rec");
      if (UserRecString == NULL)
        ErrorMessage("Memory Alloc Error in USERREC",TRUE);

      strcpy(UserRecString,CurData);

      if (PreplotIsOk && Echo)
        printf("\nUSERREC = %s\n",UserRecString);

      GetToken(FALSE,TRUE,InFile);
    }
}





static void DumpString(char *S)
{
  int L = 0;
  if (PreplotIsOk)
    {
      while (S[L] != '\0')
        WriteI(PlotFile,(LgIndex)(unsigned char)S[L++]);
      WriteI(PlotFile,(LgIndex)0);
    }
}



#if defined PLOT3D
void Plot3D_DumpZoneStart(long *VarMinMaxOffset)
{
  int J;
  WriteR(PlotFile,ZONEMARKER,FieldDataType_Float);

  WriteR(BlckFile,ZONEMARKER,FieldDataType_Float);
  for (J = 0; J < NumVars; J++)
    WriteI(BlckFile,(LgIndex)FieldDataType_Float);
  WriteI(BlckFile,0);  /* has passive variables */
  WriteI(BlckFile,0);  /* no variable sharing */
  WriteI(BlckFile,-1); /* no connectivity sharing */

  /*
   * Instead of writing out the real min/max values here we wait until after
   * processing the values so that we can make only one pass through the data.
   */
  *VarMinMaxOffset = FTELL(BlckFile);
  PreplotIsOk = (*VarMinMaxOffset != -1);
  for (J = 0; J < NumVars; J++)
    {
      WriteR(BlckFile, 0.0, FieldDataType_Double);
      WriteR(BlckFile, 0.0, FieldDataType_Double);
    }
}

/**
 */
static void Plot3D_DumpConnectList(FILE   *F,
                                   LgIndex IGrid)
{
  LgIndex ConnectBase = Plot3DConnectivityBase[IGrid];
  LgIndex NumConnect;
  LgIndex I;
  if (Plot3DJDim[IGrid] > 0)
    NumConnect = Plot3DJDim[IGrid]*3;
  else
    NumConnect = Plot3DKDim[IGrid]*4;

  WriteI(BlckFile,0);   /* No Dup Connect */
  for (I = 0; I < NumConnect; I++)
    WriteI(BlckFile,(LgIndex)Plot3DConnectivityArray[ConnectBase+I]);
}



#endif /* PLOT3D */



static void StuffGenericVarName(char  **S,
                                int     I)
{
  char SS[10];
  sprintf(SS,"V%-4ld",(long)I+1);
  TrimAndStuffString(S,SS,MaxChrsVarName);
}


#if defined PLOT3D && !defined TECPLOTKERNEL
static void PrintBool(int I)
{
  if (I)
    printf("YES\n");
  else
    printf("NO\n");
}
#endif


static FILE *OpenPlot3DFile(char  *BaseName,
                            short  Extension)
{
  FILE *TFile;
  char *CPtr;
#ifdef PLOT3D
  const char *mode = Plot3DInputIsBinary ? "rb" : "r";
#else
  const char *mode = "r";
#endif


  strcpy(FinalInFileName,BaseName);
  CPtr = &FinalInFileName[strlen(FinalInFileName)];
  *CPtr++ = '.';
  *CPtr++ = (char)Extension;
  *CPtr = '\0';

#if defined TECPLOTKERNEL
  Open_File(&TFile,
            FinalInFileName,
            TRUE,   /* IsReading */
            FALSE,  /* IsAppending */
            FALSE,  /* ForceOpen */
            FALSE,  /* ShowErr */
            strcmp(mode,"r") == 0); /* IsAscii */
#else 
  TFile = FOPEN(FinalInFileName, mode);
#endif /* TECPLOTKERNEL */

  if (TFile == NULL)
    {
      char TString[120];
      sprintf(TString,"Cannot find input file %s\n",FinalInFileName);
      ErrorMessage(TString,FALSE);
    }
  return (TFile);
}



/**
 * Reads InFile for an auxiliary data record and adds it to the linked list.
 * If the linked list does not already exist it creates it. Actually the
 * list item can be any item in the list. The code will start from the current
 * list item, scan for the end of the list and add the new item it creates.
 *
 * SolutionTime is an optional parameter. If NULL it is ignored, otherwise it
 * is reference to the solution time. If the auxiliary data is Common.Time it
 * is converted to solution time instead of auxiliary data.
 */
static AuxDataListItem_s *GetAuxData(const char         *AuxDataTokenName,
                                     AuxDataListItem_s **AuxDataListItemRef,
                                     LgIndex            *StrandID,
                                     double             *SolutionTime)
{
  AuxDataListItem_s *NewAuxDataListItem = NULL;
  static char ErrorMsgBuffer[1023+1];

  REQUIRE(VALID_REF(AuxDataTokenName));
  REQUIRE(strlen(AuxDataTokenName) != 0);
  REQUIRE(VALID_REF(AuxDataListItemRef));
  REQUIRE(*AuxDataListItemRef == NULL ||
          VALID_REF(*AuxDataListItemRef));
  REQUIRE((StrandID == NULL && SolutionTime == NULL) ||
          (VALID_REF(StrandID) && VALID_REF(SolutionTime)));

  /* name string */
  GetToken(FALSE,TRUE,InFile);
  if (CurToken == IdentToken)
    {
      TrimLeadAndTrailSpaces(CurData);
      NewAuxDataListItem = ALLOC_ITEM(AuxDataListItem_s, "auxiliary_data");
      if (NewAuxDataListItem != NULL)
        {
          NewAuxDataListItem->ListItem.Next = NULL; /* initialize */
          NewAuxDataListItem->Value         = NULL; /* initialize */

          NewAuxDataListItem->Name = DupString(CurData);
          if (NewAuxDataListItem->Name != NULL)
            {
              /* = */
              if (RemoveEqualsSign(FALSE))
                {
                  /* value string */
                  if (CurToken == StringToken)
                    {
                      NewAuxDataListItem->Value = DupString(CurData);
                      if (NewAuxDataListItem->Value != NULL)
                        {
                          /*
                           * As of binary version 106 we convert Common.Time to
                           * solution time otherwise we just add the list.
                           */
                          if (SolutionTime != NULL && /* ...convert COMMON.TIME to SolutionTime? */
                              CompareIdent(NewAuxDataListItem->Name, "COMMON.TIME"))
                            {
                              char *EndPtr = NULL;
                              *SolutionTime = strtod(NewAuxDataListItem->Value, &EndPtr);
                              while (isspace(*EndPtr))
                                EndPtr++;
                              if (*EndPtr == '\0')
                                {
                                  /*
                                   * If the strand ID is yet unassigned, STRAND_ID_UNASSIGNED, change the
                                   * the value to STRAND_ID_PENDING indicating that we want Tecplot to
                                   * auto-assign strand ID's.
                                   */
                                  if (StrandID != NULL && *StrandID == STRAND_ID_UNASSIGNED)
                                    *StrandID = STRAND_ID_PENDING;
                                }
                              else
                                ErrorMessage("Invalid Common.Time auxiliary data value.", TRUE);
                              CleanupAuxDataListItem(&NewAuxDataListItem); /* ...no longer needed */
                            }
                          else
                            ListAddItem((ListItem_s **)AuxDataListItemRef,
                                        (ListItem_s *)NewAuxDataListItem);
                        }
                      else
                        {
                          ErrorMessage("Not enough memory for data set's "
                                 "auxiliary data.", TRUE);
                          CleanupAuxDataListItem(&NewAuxDataListItem);
                        }
                    }
                  else
                    {
                      sprintf(ErrorMsgBuffer,
                              "'%s' requires a name value pair.\n"
                              "For example: my_name=\"my value\".",
                              AuxDataTokenName);
                      ErrorMessage(ErrorMsgBuffer, TRUE);
                      CleanupAuxDataListItem(&NewAuxDataListItem);
                    }
                }
              else
                {
                  sprintf(ErrorMsgBuffer,
                          "'%s' name value pairs must be separated "
                          "by an equal sign.", AuxDataTokenName);
                  ErrorMessage(ErrorMsgBuffer, TRUE);
                  CleanupAuxDataListItem(&NewAuxDataListItem);
                }
            }
          else
            {
              ErrorMessage("Not enough memory for data set's "
                     "auxiliary data.", TRUE);
              CleanupAuxDataListItem(&NewAuxDataListItem);
            }
        }
      else
        {
          ErrorMessage("Not enough memory for data set's "
                 "auxiliary data.", TRUE);
        }
    }
  else
    {
      sprintf(ErrorMsgBuffer,
              "'%s' requires a name value pair.\n"
              "For example: my_name=\"my value\".",
              AuxDataTokenName);
      ErrorMessage(ErrorMsgBuffer, TRUE);
    }

  ENSURE(VALID_REF(NewAuxDataListItem) || NewAuxDataListItem == NULL);
  return NewAuxDataListItem;
}

/**
 * Reads InFile for a variable value location.
 *
 *   Old form (deprecated). Note that in the old form the variable value
 *   locations are assumed nodal unless otherwise specified. The square
 *   brackets in the syntax below indicate an optional value nnn can be
 *   supplied. If the nnn value is not supplied it is assumed the var-location
 *   assignment belongs to the next variable (i.e. N+1). The old form syntax is
 *   as follows:
 *
 *     VARLOCATION = ([nnn=]var-location,[nnn=]var-location,...)
 *                 ^
 *      current scan location
 *
 *   New form (Tecplot's default ASCII output). Unspecified variable value
 *   locations are still assumed nodal however in the new form the square
 *   brackets are part of the set notation and do not indicate optional
 *   parameters as they do in the old form above. To maintain compatability
 *   mixing of both the old and new forms is allowed. The new form syntax is as
 *   follows:
 *
 *     VARLOCATION = ([set]=var-location, [set]=var-location, ...)
 *                 ^
 *      current scan location
 */
static void GetVarLocation(void)
{
  /* this is a convenient block from which to break */
  do
    {
      LgIndex Variable;

      /* unset the entire array */
      for (Variable = 0; Variable < MaxNumVars; Variable++)
        VarIsCellCentered[Variable] = UNSET_BOOLEAN; /* unset */

      if (!RemoveEqualsSign(FALSE))
        {
          ErrorMessage("Missing equals sign in variable location assignment.", TRUE);
          break;
        }
      else if (CurToken != LeftParenToken)
        {
          ErrorMessage("Expecting a left parenthesis", TRUE);
          break;
        }

      Variable = 0;
      for (GetToken(FALSE, TRUE, InFile);
           CurToken != RightParenToken && PreplotIsOk;
           GetToken(FALSE, TRUE, InFile))
        {
#         define VARLOC_BUFFER_LEN 255
          int  SetVar;
          char VarLocBuffer[VARLOC_BUFFER_LEN+1];
          Boolean_t IsCellCentered;

          if (CurToken == SetToken) /* new form: [set]= */
            {
              if (!RemoveEqualsSign(FALSE))
                {
                  ErrorMessage("Missing equals sign after variable set in "
                               "variable location assignment.", TRUE);
                  break;
                }
            }
          else
            {
              /* old form: optional nnn= */
              if (CurToken == ValueToken)
                {
                  Variable = ROUND2(CurTValue) - 1;
                  if (!RemoveEqualsSign(FALSE))
                    {
                      ErrorMessage("Missing equals sign after variable number in "
                                   "variable location assignment.", TRUE);
                      break;
                    }
                }

              /*
               * The new form uses sets and the old form does not. Put the
               * variable value into the new set notation so that we can use
               * the same code below.
               */
              settonull(CurTSet,SetSize);
              addtoset(Variable, CurTSet);
            }

          /* var-location */
          if (CurToken != StringToken && CurToken != IdentToken)
            {
              ErrorMessage("Expecting variable value location of "
                           "NODAL or CELLCENTERED.", TRUE);
              break;
            }
          TrimAndCopyCurData(VarLocBuffer, VARLOC_BUFFER_LEN);
          if (CompareIdent(VarLocBuffer, "NODAL"))
            {
              IsCellCentered = FALSE;
            }
          else if (CompareIdent(VarLocBuffer, "CELLCENTERED"))
            {
              IsCellCentered = TRUE;
            }
          else
            {
              ErrorMessage("Expecting variable value location of "
                           "NODAL or CELLCENTERED.", TRUE);
              break;
            }

          /*
           * Assign the var-location to the specified set of variables.
           */
          for (SetVar = 0; SetVar < MaxNumVars && PreplotIsOk; SetVar++)
            if (inset(SetVar, CurTSet))
              {
                /*
                 * need to keep track of this for the old form of VARLOCATION
                 * which allows an optional variable number indicating the next
                 * variable. Note the advancing of this variable at the bottom
                 * of the GetToken for loop.
                 */
                Variable = SetVar;

                /*
                 * Verify that the variable has not already received an variable
                 * location value with a previous directive. 
                 */
                if (VarIsCellCentered[Variable] == UNSET_BOOLEAN) /* ...not yet assigned? */
                  VarIsCellCentered[Variable] = IsCellCentered;
                else
                  {
                    ErrorMessage("A variable's value location "
                                 "has been multiply defined.", TRUE);
                    break;
                  }
              }

          /*
           * Advance the variable number to allow compatability with the old
           * form which permits an optional variable number.
           */
          Variable++;
        }

      if (CurToken == RightParenToken && PreplotIsOk)
        {
          /* all unassigned variable value locations default to nodal */
          for (Variable = 0; Variable < MaxNumVars; Variable++)
            if (VarIsCellCentered[Variable] == UNSET_BOOLEAN)
              VarIsCellCentered[Variable] = FALSE;
        }

      if (!PreplotIsOk)
        break;

    } while (FALSE); /* do once */
}

/**
 * Reads InFile for a variable passivity.
 *   Unspecified variables are assumed active.
 *
 *     PASSIVEVARLIST = [set]
 *                    ^
 *          current scan location
 */
static void GetPassiveVarList(void)
{
  if (RemoveEqualsSign(FALSE))
    {
      if (CurToken == SetToken)
        {
          LgIndex Variable;
          for (Variable = 0; Variable < MaxNumVars && PreplotIsOk; Variable++)
            VarIsPassive[Variable] = inset(Variable, CurTSet);
        }
      else
        ErrorMessage("Missing set of passive variables.", TRUE);
    }
  else
    ErrorMessage("Missing equals sign in the passive variable list assignment.", TRUE);
}

/**
 * Reads in the face neighbor mode.
 *
 *   FACENEIGHBORMODE = [LOCALONETOONE,
 *                       LOCALONETOMANY,
 *                       GLOBALONETOONE,
 *                       GLOBALONETOMANY]
 *                    ^
 *           current scan location
 */
static void GetFaceNeighborMode(void)
{
  if (RemoveEqualsSign(FALSE))
    {
      FaceNeighborModeType Mode = (FaceNeighborModeType )-1;

      if (CurToken == StringToken || CurToken == IdentToken)
        {
#         define MODE_BUFFER_LEN 25
          char ModeBuffer[MODE_BUFFER_LEN+1];
          TrimAndCopyCurData(ModeBuffer, MODE_BUFFER_LEN);
          if (CompareIdent(ModeBuffer, "LOCALONETOONE"))
            Mode = LOCALONETOONE;
          else if (CompareIdent(ModeBuffer, "LOCALONETOMANY"))
            Mode = LOCALONETOMANY;
          else if (CompareIdent(ModeBuffer, "GLOBALONETOONE"))
            Mode = GLOBALONETOONE;
          else if (CompareIdent(ModeBuffer, "GLOBALONETOMANY"))
            Mode = GLOBALONETOMANY;
        }

      if (Mode != -1)
        {
          FaceNeighborMode = Mode;
        }
      else
        {
          ErrorMessage("Expecting a face neighbor mode: "
                 "LOCALONETOONE, LOCALONETOMANY, GLOBALONETOONE, "
                 "or GLOBALONETOMANY.", TRUE);
        }
    }
  else
    {
      ErrorMessage("Missing equals sign in face neighbor mode assignment.", TRUE);
    }
}

/**
 * Reads in the boolean indicating if the FE face neighbors are completely
 * specified.
 *
 *   FEFACENEIGHBORSCOMPLETE = [YES, NO]
 *                           ^
 *                  current scan location
 */
static void GetFEFaceNeighborsComplete(void)
{
  if (RemoveEqualsSign(FALSE))
    {
      Boolean_t Complete;
      Boolean_t IsOk = TRUE;
      if (CurToken == StringToken || CurToken == IdentToken)
        {
#         define BOOLEAN_BUFFER_LEN 25
          static char BooleanBuffer[BOOLEAN_BUFFER_LEN+1];
          TrimAndCopyCurData(BooleanBuffer, BOOLEAN_BUFFER_LEN);
          if (CompareIdent(BooleanBuffer, "YES"))
            Complete = TRUE;
          else if (CompareIdent(BooleanBuffer, "NO"))
            Complete = FALSE;
          else
            IsOk = FALSE;
        }
      else
        IsOk = FALSE;

      if (IsOk)
        FEFaceNeighborsComplete = Complete;
      else
        ErrorMessage("FEFACENEIGHBORSCOMPLETE is expecting YES or NO.", TRUE);
    }
  else
    ErrorMessage("FEFACENEIGHBORSCOMPLETE is expecting an equal sign "
                 "followed by YES or NO.", TRUE);
}

/**
 * VARSHARELIST = ([set-of-vars]=zzz, [set-of-vars]=zzz, ...)
 *              ^
 *     current scan location
 *
 *   Where 
 *      set-of-vars .... a set of variable numbers.
 *      =zzz ........... zone to share with.  If omitted assumes
 *                       the previous zone.
 *
 *
 *   Examples:
 *      VARSHARELIST = ([4-8,11] = 3, [20-50] = 1, [13,15])
 *
 *        Variables 4,5,6,7,11 in this zone share with zone 3.
 *        Variables 20,21,22....50 share with zone 1.
 *        Variables 13,15 share with previous zone.
 */
static void GetVarShareList(void)
{
  if (PreplotIsOk)
    {
      if (RemoveEqualsSign(FALSE))
        {
          if (CurToken == LeftParenToken)
            GetToken(FALSE,TRUE,InFile);
          else
            ErrorMessage("Expecting a left parenthesis for VARSHARELIST",TRUE);

          /* we are expecting at least one variable set */
          if (CurToken == SetToken && PreplotIsOk)
            {
              while (CurToken == SetToken && PreplotIsOk)
                {
                  Boolean_t NeedTokenAdvance = FALSE;
                  LgIndex SharedZone = -1;

                  GetToken(FALSE,TRUE,InFile);
                  if (CurToken == EqualsToken && PreplotIsOk)
                    {
                      /* get the specified zone from which to share */
                      GetToken(FALSE,TRUE,InFile);
                      if (CurToken == ValueToken && PreplotIsOk)
                        SharedZone = ROUND2(CurTValue) - 1;
                      else
                        ErrorMessage("Invalid shared zone specified for VARSHARELIST.", TRUE);

                      NeedTokenAdvance = TRUE;
                    }
                  else if ((CurToken == SetToken ||
                            CurToken == RightParenToken) && PreplotIsOk)
                    {
                      /* if not specified, share the previous zone */
                      SharedZone = CurZone - 1;
                    }
                  else
                    ErrorMessage("Invalid VARSHARELIST syntax", TRUE);

                  if (PreplotIsOk)
                    {
                      /* perform some additional error checking */
                      if (SharedZone < 0)
                        ErrorMessage("Invalid zone number specified for VARSHARELIST.", TRUE);
                      else if (SharedZone >= CurZone)
                        ErrorMessage("Variables can only share from a lower numbered zone.", TRUE);
                    }

                  /* fill the variable shared zone list */
                  if (PreplotIsOk)
                    {
                      LgIndex Var;
                      CHECK(MaxNumVars <= MaxNumSetMembers);
                      for (Var = 0; Var < MaxNumSetMembers; Var++)
                        if (inset(Var, CurTSet))
                          {
                            if (Var < MaxNumVars)
                              VarShareZone[Var] = SharedZone;
                            else
                              ErrorMessage("Invalid variable number for VARSHARELIST.", TRUE);
                          }

                      /*
                       * we had to wait until here to advance the token because
                       * the set get cleared and reset when another set token
                       * is found
                       */
                      if (NeedTokenAdvance)
                        GetToken(FALSE,TRUE, InFile);
                    }
                }
            }
          else
            ErrorMessage("Expecting a variable set for VARSHARELIST.", TRUE);
        }
      else
        ErrorMessage("Expecting equals sign",TRUE);
    }
}

/**
 */
static void DumpAuxDataItem(AuxDataListItem_s *AuxDataListItem)
{
  DumpString(AuxDataListItem->Name);
  WriteI(PlotFile,0); /* 0=AuxiliaryValueFormat_String */
  DumpString(AuxDataListItem->Value);
}

static Boolean_t DumpAuxDataItemIterator(ListItem_s *ListItem,
                                         void       *ClientData)
{
  WriteI(PlotFile,1); /* 1=auxiliary data follows */
  DumpAuxDataItem((AuxDataListItem_s *)ListItem);
  return PreplotIsOk;
}

/**
 */
static void DumpAuxDataItemList(AuxDataListItem_s *AuxDataListItemHead)
{
  ListIterate((ListItem_s *)AuxDataListItemHead,
              DumpAuxDataItemIterator, 0);
  WriteI(PlotFile,0); /* 0=no more auxiliary data follows */
}


static void DumpPlot3DZoneHeaderInfo(const char *CurZoneName,
                                     LgIndex     CurIMax,
                                     LgIndex     CurJMax,
                                     LgIndex     CurKMax)
{
  DumpString((char *)CurZoneName);
  WriteI(PlotFile, BAD_SET_VALUE);    /* ie. no ParentZone (zero based) */
  WriteI(PlotFile, STRAND_ID_STATIC); /* ie. static StrandID (zero based) */
  WriteR(PlotFile, 0.0,         /* zero time */
         FieldDataType_Double);
  WriteI(PlotFile,-1);          /* No Color */
  WriteI(PlotFile,(LgIndex)0);  /* Zone Type = Ordered */
  WriteI(PlotFile,(LgIndex)0);  /* Data Packing = Block */
  WriteI(PlotFile,(LgIndex)0);  /* Var Location, 0 = all data is at nodes */
  WriteI(PlotFile,(LgIndex)0);  /* are raw face neighbors available? */
  WriteI(PlotFile,(LgIndex)0);  /* Num User defined face neighbors. */
  WriteI(PlotFile,CurIMax);
  WriteI(PlotFile,CurJMax);
  WriteI(PlotFile,CurKMax);
  WriteI(PlotFile,(LgIndex)0); /* No more aux data name/value pairs. */
}





Boolean_t Preplot (int   argc,
                 char *argv[],
                 char **EString)
{
  LgIndex  I,J,K,N,VarsProcessed,LastI;
  LgIndex  L;
  LgIndex  JJMax;
  Boolean_t  InFileFound;
  Boolean_t  CreatePlotName;
  Boolean_t  Fetch;
  Boolean_t  IndexIsGood;
  Boolean_t  VariablesIdentified = FALSE;
  Boolean_t  ZoneHeaderParsed    = FALSE; 

  UserRecString              = NULL;
  NodeVar                    = -1;
  RepeatLength_g             = 0;
  RepeatLength_q             = 0;
  BlckFile                   = NULL;
  PlotFile                   = NULL;
  InFile                     = NULL;
  NodeVarList                = NULL;
  ErrProcessed               = FALSE;
  CurByte                    = 0;
  CurBit                     = 0;
  LastNodeInList             = 0;
  PreplotIsOk                = TRUE;
  LineNumber                 = 0;
  StopAfterLastZone          = FALSE;
  ReverseOutputBytes         = FALSE;
  LastZone                   = -1;
  CurZone                    = 0;
#if !defined TECPLOTKERNEL
  NumWarns                   = 0;
#endif
#if defined TECPLOTKERNEL
  GetCount                   = 0;
#endif

  CurToken                   = NullToken;
  CurData[0]                 = '\0';
  CurTValue                  = 0.0;
  CurTSeqStart               = 0;
  CurTSeqEnd                 = -1;
  CurTSet                    = NULL;
  CurByte                    = '\0';
  CurBit                     = 0;

  PreplotIsOk = AllocatePreplotStuff();


  if (PreplotIsOk)
    {
      settonull (ZoneSet,SetSize);
      for (I = 0; I < MaxCustomLabels; I++)
        CustomLabel[I] = NULL;

      for (I = 0; I < MaxNumZones; I++)
        {
          ZoneName[I] = NULL;
          ConnectivityShareZone[I] = -1; /* not shared */
        }

      for (I = 0; I < MaxNumVars; I++)
        VarName[I] = NULL;

      PlotFileName[0] = '\0';
      BlckFName = NULL;


#if !defined TECPLOTKERNEL
      printf(VersionString);
#endif

      GetRandomFileName(&BlckFName);

      if ( BlckFName )
#if defined TECPLOTKERNEL
        Open_File(&BlckFile,
                   BlckFName,
                   FALSE,       /* IsReading */
                   FALSE,       /* IsAppending */
                   TRUE,        /* ForceOpen */
                   FALSE,       /* ShowErr */
                   FALSE);      /* IsAscii */
#else        
        BlckFile = FOPEN(BlckFName,"wb");
#endif /* TECPLOTKERNEL */

      if (BlckFile == NULL)
        ErrorMessage("Unable to create temp scratch file.\nCheck Directory permissions",FALSE);

      CreatePlotName       = TRUE;
      InFileFound          = FALSE;
      Echo                 = 0;

#if defined PLOT3D
      IJKSetSet                  = FALSE;
      InputIsPlot3D              = FALSE;
      Plot3DVarFormat            = Var_GridAndQ;
      Plot3DIsMultiGrid          = FALSE;
      Plot3DHasIBlank            = 0;
      Plot3DInputIsBinary        = FALSE;
      InFile_q                   = NULL;
      InFile_f                   = NULL;
      Plot3DInputHasRecordMarks  = FALSE;
      Plot3DMode                 = MODE_Unknown;
      Plot3DNumGrids             = 1;
      Plot3DIsForeign            = FALSE;
#if !defined TECPLOTKERNEL
      Plot3DBadBlockCount        = 0;
#endif
      Plot3DCollapseIJK          = FALSE;

      for (I = 0; I < MaxPlot3DVars+8; I++)
        Plot3DVarArray[I] = NULL;

      Plot3DConnectivityArray = NULL;

      for (I = 0; I < MaxNumZones; I++)
        {
          Plot3DIDim[I] = 1;
          Plot3DJDim[I] = 1;
          Plot3DKDim[I] = 1;
        }
      settonull(Plot3DKSet,SetSize);
      settonull(Plot3DJSet,SetSize);
      settonull(Plot3DISet,SetSize);
#endif

      for (I = 0; I < MaxNumZones; I++)
        {
          IStart[I] = 1;
          IEnd[I]   = 0;
          ISkip[I]  = 1;
          JStart[I] = 1;
          JEnd[I]   = 0;
          JSkip[I]  = 1;
          KStart[I] = 1;
          KEnd[I]   = 0;
          KSkip[I]  = 1;
        }

#if defined TECPLOTKERNEL
      I = 0;
#else
      I = 1;
#endif
    }

  while (PreplotIsOk && (I < argc))
    {
      if (strcmp(argv[I],"-d") == 0 || strcmp(argv[I],"-D") == 0)
        Echo = 1;
      else if ((argv[I][0] == '-') &&
               ((argv[I][1] == 'd') || (argv[I][1] == 'D')) &&
               (isdigit(argv[I][2])))
        Echo = argv[I][2] - '0';
      else if (strcmp(argv[I],"-iset") == 0 || strcmp(argv[I],"-ISET") == 0)
        {
          I++;
          PreplotIsOk = SetIJLimits(IStart,IEnd,ISkip,argv[I]);
        }
      else if (strcmp(argv[I],"-jset") == 0 || strcmp(argv[I],"-JSET") == 0)
        {
          I++;
          PreplotIsOk = SetIJLimits(JStart,JEnd,JSkip,argv[I]);
        }
      else if (strcmp(argv[I],"-kset") == 0 || strcmp(argv[I],"-KSET") == 0)
        {
          I++;
          PreplotIsOk = SetIJLimits(KStart,KEnd,KSkip,argv[I]);
        }
      else if (strcmp(argv[I],"-stopafterlastzone") == 0 || strcmp(argv[I],"-STOPAFTERLASTZONE") == 0)
        StopAfterLastZone = TRUE;
      else if (strcmp(argv[I],"-foreignplt") == 0 || strcmp(argv[I],"-FOREIGNPLT") == 0)
        ReverseOutputBytes = TRUE;
      else if (strcmp(argv[I],"-zonelist") == 0 || strcmp(argv[I],"-ZONELIST") == 0)
        {
          I++;
          if (argv[I])
            {
              if (!GetSet(argv[I],ZoneSet,"ZoneList"))
                ErrorMessage("Bad zoneset",TRUE);
            }
        }
#if !defined (PLOT3D)
      else if (strcmp(argv[I],"-plot3d") == 0 || strcmp(argv[I],"-PLOT3D") == 0)
        {
          ErrorMessage("Err: Plot-3D files not supported.\nPreplot is not compiled with -DPLOT3D flag.",FALSE);
        }
#endif
#if defined PLOT3D
      else if (strcmp(argv[I],"-plot3d") == 0 || strcmp(argv[I],"-PLOT3D") == 0)
        InputIsPlot3D = TRUE;
      else if (strcmp(argv[I],"-m") == 0 || strcmp(argv[I],"-M") == 0)
        Plot3DIsMultiGrid = TRUE;
      else if (strcmp(argv[I],"-foreign") == 0 || strcmp(argv[I],"-FOREIGN") == 0)
        Plot3DIsForeign = TRUE;

      else if (strcmp(argv[I],"-i") == 0 || strcmp(argv[I],"-I") == 0)
#if defined OLDCRAY && !defined CRAYIEEE
        {
          ErrorMessage("IBlanking does not work properly when\nrunning preplot on a CRAY: Compile using\nCRAYIEEE.",FALSE);
        }
#else
        Plot3DHasIBlank = 1;
#endif
      else if (strcmp(argv[I],"-b") == 0 || strcmp(argv[I],"-B") == 0)
        Plot3DInputIsBinary = TRUE;
      else if (strcmp(argv[I],"-f") == 0 || strcmp(argv[I],"-F") == 0)
        Plot3DInputHasRecordMarks = TRUE;
      else if (strcmp(argv[I],"-collapseijk") == 0 || strcmp(argv[I],"-COLLAPSEIJK") == 0)
        Plot3DCollapseIJK = TRUE;
      else if (strcmp(argv[I],"-unstructured") == 0 || strcmp(argv[I],"-UNSTRUCTURED") == 0)
        Plot3DMode = MODE_UNSTRUCTURED;
      else if (strcmp(argv[I],"-1d") == 0 || strcmp(argv[I],"-1D") == 0)
        Plot3DMode = MODE_1D;
      else if (strcmp(argv[I],"-2d") == 0 || strcmp(argv[I],"-2D") == 0)
        Plot3DMode = MODE_2D;
      else if (strcmp(argv[I],"-3dw") == 0 || strcmp(argv[I],"-3DW") == 0)
        Plot3DMode = MODE_3DW;
      else if (strcmp(argv[I],"-3dp") == 0 || strcmp(argv[I],"-3DP") == 0)
        Plot3DMode = MODE_3DP;
      else if (strcmp(argv[I],"-gridonly") == 0 || strcmp(argv[I],"-GRIDONLY") == 0)
        Plot3DVarFormat = Var_GridOnly;
      else if (strcmp(argv[I],"-function") == 0 || strcmp(argv[I],"-FUNCTION") == 0)
        Plot3DVarFormat = Var_GridAndFunction;
      else if (strcmp(argv[I],"-functionandq") == 0 || strcmp(argv[I],"-FUNCTIONANDQ") == 0)
        Plot3DVarFormat = Var_GridAndFunctionAndQ;
      else if (strcmp(argv[I],"-kp") == 0 || strcmp(argv[I],"-KP") == 0)
        {
          IJKSetSet = TRUE;
          I++;
          if (argv[I])
            {
              if (!GetSet(argv[I],Plot3DKSet,"KSet"))
                ErrorMessage("Bad -kp list",TRUE);
            }
        }
      else if (strcmp(argv[I],"-jp") == 0 || strcmp(argv[I],"-JP") == 0)
        {
          IJKSetSet = TRUE;
          I++;
          if (argv[I])
            {
              if (!GetSet(argv[I],Plot3DJSet,"JSet"))
                ErrorMessage("Bad -jp list",TRUE);
            }
        }
      else if (strcmp(argv[I],"-ip") == 0 || strcmp(argv[I],"-IP") == 0)
        {
          IJKSetSet = TRUE;
          I++;
          if (argv[I])
            {
              if (!GetSet(argv[I],Plot3DISet,"ISet"))
                ErrorMessage("Bad -ip list",TRUE);
            }
        }
#endif /*PLOT3D*/

      else
        {
          if ((*argv[I] == '-') && (strlen(argv[I]) > 1))
            ErrorMessage("invalid flag",TRUE);
          else
            {
              if (!InFileFound)
                {
                  strcpy(InFileName,argv[I]);
                  InFileFound = TRUE;
                }
              else if (CreatePlotName)
                {
                  strcpy(PlotFileName,argv[I]);
                  CreatePlotName = FALSE;
                }
            }
        }
      I++;
    }

  if (ZoneSet)
    LastZone = getlastsetmember(ZoneSet);

#if defined PLOT3D

  if (Plot3DInputHasRecordMarks)
    Plot3DInputIsBinary = TRUE;

  if (InputIsPlot3D)
    {
      if (Plot3DMode == MODE_Unknown)
        ErrorMessage("PLOT3D Mode not set",FALSE);
      if (((Plot3DMode != MODE_3DW) && (Plot3DMode != MODE_3DP)) &&
           IJKSetSet)
        ErrorMessage("PlotMode must be -3dw or -3dp when -ip,-jp,-kp are used",FALSE);
      if ((Plot3DMode == MODE_UNSTRUCTURED) &&
          (Plot3DVarFormat != Var_GridOnly))
        ErrorMessage("Current version can only process grid files when plot3d unstructured data is converted.  Include the -gridonly flag",FALSE);
    }
#endif

  if (!InFileFound)
    PreplotIsOk = FALSE;

  if (PreplotIsOk)
    {
      strcpy(FinalInFileName,InFileName);
#if defined PLOT3D
      if (InputIsPlot3D)
        {
          PreplotIsOk = (InFile = OpenPlot3DFile(InFileName,'g')) != NULL;

          if (PreplotIsOk &&
              ((Plot3DVarFormat == Var_GridAndQ) ||
               (Plot3DVarFormat == Var_GridAndFunctionAndQ)))
            PreplotIsOk = (InFile_q = OpenPlot3DFile(InFileName,'q')) != NULL;

          if (PreplotIsOk &&
              ((Plot3DVarFormat == Var_GridAndFunction) ||
               (Plot3DVarFormat == Var_GridAndFunctionAndQ)))
            PreplotIsOk = (InFile_f = OpenPlot3DFile(InFileName,'f')) != NULL;
        }
      else
#endif
        {
          if (strcmp(FinalInFileName,"-") != 0)
            {
#ifdef TECPLOTKERNEL
              Open_File(&InFile,FinalInFileName,
                TRUE,   /* IsReading */
                FALSE,  /* IsAppending */
                FALSE,  /* ForceOpen */
                FALSE,  /* ShowErr */
                TRUE);  /* IsAscii */
              PreplotIsOk = InFile != NULL;
#else
              PreplotIsOk = ((InFile = FOPEN(FinalInFileName,"r")) != 0);
#endif /* TECPLOTKERNEL */
              if (!PreplotIsOk)
                {
                  strcat(FinalInFileName,".dat");
#ifdef TECPLOTKERNEL
                  Open_File(&InFile,FinalInFileName,
                    TRUE,   /* IsReading */
                    FALSE,  /* IsAppending */
                    FALSE,  /* ForceOpen */
                    FALSE,  /* ShowErr */
                    TRUE);  /* IsAscii */
                  PreplotIsOk = InFile != NULL;
#else
                  PreplotIsOk = ((InFile = FOPEN(FinalInFileName,"r")) != 0);
#endif /* TECPLOTKERNEL */
                }
            }
          else
            InFile = stdin;
          if (!PreplotIsOk)
            ErrFile(FinalInFileName);
        }
    }

  if (PreplotIsOk && Echo)
    printf("Temporary scratch file = %s\n",BlckFName);

/******************** to be added later **************
-cp -cs ........................... cp converts R,theta to X,Y.  cs converts\n\
                                    R,theta,phi to X,Y,Z\n\
*/

#if !defined TECPLOTKERNEL
  if (!PreplotIsOk)
    {
      printf("\n"
             "Usage: preplot infile [outfile] [flags]\n"
             "Where [flags] are:\n"
             "-d -d2 -d3 ........................ Debug echo add 2 or 3 for more output\n"
             "-iset [zone],[start],[end],[skip].. restrict the i-index.\n"
             "If zone is omitted then do all zones.\n"
             "start and skip default to 1.  end \n"
             "defaults to imax.\n"
             "-jset [zone],[start],[end],[skip].. same as iset except for j index\n"
             "-kset [zone],[start],[end],[skip].. same as iset except for k index\n"
             "-zonelist start[:end[:skip]],...    restrict the zones to process. You can\n"
             "use more than one specification.\n"
             "-stopafterlastzone ................ stop processing after last zone in zonelist.\n"
             "-foreignplt ....................... Reverse bytes of output plot file.\n\n");

#if defined PLOT3D
printf("PLOT3D input ONLY:\n"
       "-plot3d ........ Input is plot3d format. -1d ........ Input is 1d            \n"
       "-m ............. Input is multi-grid     -2d ........ Input is 2d            \n"
       "-b ............. Input is binary         -3dp ....... Input is 3d-planar     \n"
       "-f ............. Input is binary-FORTRAN -3dw ....... Input is 3d-whole      \n"
       "-ip ilist ...... zones come from ilist.  -i ......... Input contains IBlanking.\n"
       "-jp jlist ...... zones come from jlist.  NOTES:  ilist, jlist, and klist are \n"
       "-kp klist ...... zones come from klist.          of the form:\n"
       "-gridonly ...... Read in the grid only.          start[:end[:skip]],...\n"
       "-function ...... Read in a .f \"Function\" file instead of a .q file.\n"
       "-functionandq .. Read in .f \"Function\" file and .q file\n"
       "-foreign ....... Reverse bytes of input Plot3D file.\n");
#endif
    }
#if defined PLOT3D
  else if (InputIsPlot3D)
    {
      printf("\n\n               PLOT3D FLAG SETTINGS\n");
      printf("MULTIGRID          : "); PrintBool(Plot3DIsMultiGrid);
      printf("IBLANKING          : "); PrintBool(Plot3DHasIBlank);
      printf("BINARY             : "); PrintBool(Plot3DInputIsBinary);
      printf("USES RECORD MARKERS: "); PrintBool(Plot3DInputHasRecordMarks);
      printf("DIMENSIONING       : ");
      switch (Plot3DMode)
        {
          case MODE_UNSTRUCTURED  : printf("Unstructured\n");  break;
          case MODE_1D            : printf("1D\n");            break;
          case MODE_2D            : printf("2D\n");            break;
          case MODE_3DP           : printf("3D-Planar\n");     break;
          case MODE_3DW           : printf("3D-Whole\n");      break;
        }
      printf("FORMAT             : ");
      switch (Plot3DVarFormat)
        {
          case Var_GridAndQ     : printf("Grid and Q-Files\n");  break;
          case Var_GridOnly     : printf("Grid-Only\n"); break;
          case Var_GridAndFunction     : printf("Grid and \"Function\"-Files\n"); break;
          case Var_GridAndFunctionAndQ : printf("Grid, Q- and \"Function\"-Files\n"); break;
        }
    }
#endif
#endif  /* not TECPLOTKERNEL */

  if (CreatePlotName && PreplotIsOk)
    {
      if (strcmp(InFileName,"-") != 0)
        {
          LgIndex Len = (int)strlen(InFileName);
          J = Len;
          /*
           * Plot3D grid and solutions files must be specified without an
           * extension so InFileName already contains an extension-less name.
           */
#ifdef PLOT3D
          if (!InputIsPlot3D)
#endif
            {
              /*
               * Find the last '.' in the file name. Make sure not to check the
               * first character as a '.' in the first character is not an
               * extension but a hidden file... at least for Unix.
               */
              for (I = 1; I < Len; I++)
                if (InFileName[I] == '.')
                  J = I;
            }
          if (J <= MaxCharsBaseName)
            {
              InFileName[J] = '\0';
              strcpy(PlotFileName,InFileName);
              strcat(PlotFileName,".plt");
              if (strlen(PlotFileName) > MaxCharsFileName)
                PlotFileName[MaxCharsBaseName] = '\0';
              if (strcmp(PlotFileName,InFileName) == 0)
                ErrorMessage("Cannot create .plt filename extension",FALSE);
            }
          else
            ErrorMessage("Input filename too long to generate .plt extension",FALSE);
        }
      else
        strcpy(PlotFileName,"-");
    }

  if (PreplotIsOk)
    {
      if (strcmp(PlotFileName,"-") != 0)
        {
          if (strcmp(FinalInFileName,PlotFileName) == 0)
            {
              /* Zero out PlotFileName so the cleanup process does not delete it */
              *PlotFileName = '\0';
              ErrorMessage("Input filename and output filename are identical!",FALSE);
            }
          else
            {
#ifdef TECPLOTKERNEL
              Open_File (&PlotFile,
                         PlotFileName,
                         FALSE, /* IsReading */
                         FALSE, /* IsAppending */
                         TRUE,  /* ForceOpen */
                         FALSE, /* ShowErr */
                         FALSE); /* IsAscii */
              PreplotIsOk = (PlotFile != NULL);
#else
              PreplotIsOk = ((PlotFile = FOPEN(PlotFileName,"wb")) != 0);
#endif /* TECPLOTKERNEL */

              if (!PreplotIsOk)
                ErrFile(PlotFileName);
            }
        }
      else
        PlotFile = stdout;
    }

#if defined TECBUFSIZE
  setvbuf(InFile,(char *)NULL,_IOFBF,TECBUFSIZE);
  setvbuf(BlckFile,(char *)NULL,_IOFBF,TECBUFSIZE);
  setvbuf(PlotFile,(char *)NULL,_IOFBF,TECBUFSIZE);
#endif

  ParenTokenNestLevel = 0;
  BracketNestLevel = 0;

#if defined TECPLOTKERNEL
  _Gr_CheckInterrupt(NULL,__FILE__,__LINE__);
  if (Interrupted && !(IsInterfaceSuspended() || InBatchMode))
    PreplotIsOk = FALSE;
#endif

  if (PreplotIsOk)
    {
#if defined PLOT3D
      if (!InputIsPlot3D)
#endif
        {
          if (InFile)
            {
              GetNextLine(InFile);
              LinePos = 0;
              GetToken(FALSE,TRUE,InFile);
            }
          else
            ErrorMessage("Cannot find input file",FALSE);
        }
      TextString[0]   = '\0';
      MacroString[0]  = '\0';
      HeaderString[0] = '\0';

    /*Start Parsing the input*/

    }
  if (PreplotIsOk)
    {
#if defined PLOT3D
      if (InputIsPlot3D)
        {
          NumVars        = 0;
          Plot3DNumFVars = 0;
          Plot3DNumQVars = 0;
          Plot3DNumGrids = 1;

          if (Plot3DIsMultiGrid)
            {
              if (Plot3DInputHasRecordMarks)     /* Header Rec */
                Plot3D_GetAllRecordMarks();

              Plot3D_GetToken(InFile,TRUE);
              if (PreplotIsOk)
                {
                  Plot3DNumGrids = AssignLgIndex(CurTValue);
                  if (Echo)
                    printf("MultiGrid, NumG=%d\n",Plot3DNumGrids);
                  if (Plot3DVarFormat != Var_GridOnly)
                    {
                      if (InFile_q)
                        {
                          Plot3D_GetToken(InFile_q,TRUE);
                          if (Plot3DNumGrids != AssignLgIndex(CurTValue))
                            ErrorMessage("inconsistent .g and .q files",FALSE);
                        }
                      if (InFile_f)
                        {
                          Plot3D_GetToken(InFile_f,TRUE);
                          if (Plot3DNumGrids != AssignLgIndex(CurTValue))
                            ErrorMessage("inconsistent .g and .f files",FALSE);
                        }
                    }
                  if ((Plot3DNumGrids > MaxNumZones) &&
                      (Plot3DMode != MODE_3DW))
                    {
                      printf("Err: Too many Grids in Plot3d file, G= %d, Max=%d\n",
                             Plot3DNumGrids,MaxNumZones);
                      PreplotIsOk = FALSE;
                    }
                }
#if !defined OLDCRAY || defined CRAYIEEE
              if (Plot3DInputHasRecordMarks)   /* Trailer Rec */
                Plot3D_GetAllRecordMarks();
#endif
            }

          if (Plot3DInputHasRecordMarks)      /* Header Rec */
            Plot3D_GetAllRecordMarks();



          for (I = 0; I < Plot3DNumGrids && PreplotIsOk; I++)
            {
              if (InFile_q)
                Plot3D_GetToken(InFile_q,TRUE);
              if (InFile_f)
                Plot3D_GetToken(InFile_f,TRUE);

              Plot3D_GetToken(InFile,TRUE);
              Plot3DIDim[I] = AssignLgIndex(CurTValue);   /* NumPoints if Unstructured */
              if (((short)Plot3DMode > (short)MODE_1D))
                {
                  if (InFile_q)
                    Plot3D_GetToken(InFile_q,TRUE);
                  if (InFile_f)
                    Plot3D_GetToken(InFile_f,TRUE);
                  Plot3D_GetToken(InFile,TRUE);
                  Plot3DJDim[I] = AssignLgIndex(CurTValue);  /* NumTriangles if Unstructured */
                }
              if ((short)Plot3DMode > (short)MODE_2D)
                {
                  if (InFile_q)
                    Plot3D_GetToken(InFile_q,TRUE);
                  if (InFile_f)
                    Plot3D_GetToken(InFile_f,TRUE);
                  Plot3D_GetToken(InFile,TRUE);
                  Plot3DKDim[I] = AssignLgIndex(CurTValue);  /* NumTetrahedrons if Unstructured */
                }
              if (InFile_f)
                {
                  Plot3D_GetToken(InFile_f,TRUE);
                  if ((I > 0) &&
                      (Plot3DNumFVars != AssignLgIndex(CurTValue)))
                    {
                      ErrorMessage("Each grid in multi-grid files must have the same number of variables",FALSE);
                    }
                  Plot3DNumFVars = AssignLgIndex(CurTValue);
                  if (Plot3DNumFVars > MaxPlot3DVars)
                    ErrorMessage("Too many vars in PLOT3D Function file.  Increase MaxPlot3DVars in preplot.c",FALSE);
                }
              if ((short)Plot3DMode == (short)MODE_UNSTRUCTURED)
                {
                  /*
                   * I must be > 0
                   * only one of J or K must be > 0
                   */
                  if ((Plot3DIDim[I] <= 0)                           ||
                      ((Plot3DJDim[I] <= 0) && (Plot3DKDim[I] <= 0)) ||
                      ((Plot3DJDim[I] >  0) && (Plot3DKDim[I] >  0)))
                    PreplotIsOk = FALSE;

                  if (Echo)
                    {
                      if ((Plot3DJDim[I] >  0) && (Plot3DKDim[I] >  0))
                        printf("Cannot have triangles and tetrahedrons in the same zone\n");
                      printf("G=%d,  NPts=%d,  NTri=%d,  NTet=%d\n",
                              I+1,Plot3DIDim[I],Plot3DJDim[I],Plot3DKDim[I]);
                    }
                }
              else
                {
                  if ((Plot3DIDim[I] <= 0) ||
                      (Plot3DJDim[I] <= 0) ||
                      (Plot3DKDim[I] <= 0))
                    PreplotIsOk = FALSE;

                  if (Echo)
                    {
                      printf("G=%d,  ID=%d,  JD=%d,  KD=%d\n",
                              I+1,Plot3DIDim[I],Plot3DJDim[I],Plot3DKDim[I]);
                    }
                }

              if (!PreplotIsOk)
                {
                  ErrorMessage("Error in PLOT3D dimensions.",FALSE);
                }
            }

#if !defined OLDCRAY || defined CRAYIEEE
          if (PreplotIsOk && Plot3DInputHasRecordMarks)       /* Trailer Rec */
            Plot3D_GetAllRecordMarks();
#endif

          EndOfHeader = TRUE;

          VariablesIdentified = TRUE;
          if (PreplotIsOk && (short)Plot3DMode > (short)MODE_2D)
            {
              Plot3DNumPVars = 3;
              if (Plot3DVarFormat == Var_GridOnly)
                {
                  NumVars = Plot3DNumPVars+Plot3DHasIBlank;
                  TrimAndStuffString(&VarName[0],"X",MaxChrsVarName);
                  TrimAndStuffString(&VarName[1],"Y",MaxChrsVarName);
                  TrimAndStuffString(&VarName[2],"Z",MaxChrsVarName);
                  TrimAndStuffString(&VarName[3],"IBlnk",MaxChrsVarName);
                }
              else if (Plot3DVarFormat == Var_GridAndFunction)
                {
                  int i;
                  NumVars = Plot3DNumPVars+Plot3DNumFVars+Plot3DHasIBlank;
                  TrimAndStuffString(&VarName[0],"X",MaxChrsVarName);
                  TrimAndStuffString(&VarName[1],"Y",MaxChrsVarName);
                  TrimAndStuffString(&VarName[2],"Z",MaxChrsVarName);
                  TrimAndStuffString(&VarName[3],"IBlnk",MaxChrsVarName);
                  for (i = 0; i < Plot3DNumFVars; i++)
                    StuffGenericVarName(&VarName[3+Plot3DHasIBlank+i],i);
                }
              else
                {
                  Plot3DNumQVars = 5;
                  NumVars = Plot3DNumPVars+Plot3DNumQVars+Plot3DHasIBlank;
                  if (Plot3DVarFormat == Var_GridAndFunctionAndQ)
                    NumVars += Plot3DNumFVars;
                  TrimAndStuffString(&VarName[0],"X",MaxChrsVarName);
                  TrimAndStuffString(&VarName[1],"Y",MaxChrsVarName);
                  TrimAndStuffString(&VarName[2],"Z",MaxChrsVarName);
                  TrimAndStuffString(&VarName[3],"IBlnk",MaxChrsVarName);
                  TrimAndStuffString(&VarName[3+Plot3DHasIBlank],"RHO",MaxChrsVarName);
                  TrimAndStuffString(&VarName[4+Plot3DHasIBlank],"RHO-U",MaxChrsVarName);
                  TrimAndStuffString(&VarName[5+Plot3DHasIBlank],"RHO-V",MaxChrsVarName);
                  TrimAndStuffString(&VarName[6+Plot3DHasIBlank],"RHO-W",MaxChrsVarName);
                  TrimAndStuffString(&VarName[7+Plot3DHasIBlank],"E",MaxChrsVarName);
                  if (Plot3DVarFormat == Var_GridAndFunctionAndQ)
                    {
                      int i;
                      for (i = 0; i < Plot3DNumFVars; i++)
                        StuffGenericVarName(&VarName[8+Plot3DHasIBlank+i],i);
                    }
                }
            }
          else if (PreplotIsOk && (short)Plot3DMode == (short)MODE_2D)
            {
              Plot3DNumPVars = 2;
              if (Plot3DVarFormat == Var_GridOnly)
                {
                  NumVars = Plot3DNumPVars+Plot3DHasIBlank;
                  TrimAndStuffString(&VarName[0],"X",MaxChrsVarName);
                  TrimAndStuffString(&VarName[1],"Y",MaxChrsVarName);
                  TrimAndStuffString(&VarName[2],"IBlnk",MaxChrsVarName);
                }
              else if (Plot3DVarFormat == Var_GridAndFunction)
                {
                  int i;
                  NumVars = Plot3DNumPVars+Plot3DNumFVars+Plot3DHasIBlank;
                  TrimAndStuffString(&VarName[0],"X",MaxChrsVarName);
                  TrimAndStuffString(&VarName[1],"Y",MaxChrsVarName);
                  TrimAndStuffString(&VarName[2],"IBlnk",MaxChrsVarName);
                  for (i = 0; i < Plot3DNumFVars; i++)
                    StuffGenericVarName(&VarName[2+Plot3DHasIBlank+i],i);
                }
              else
                {
                  Plot3DNumQVars = 4;
                  NumVars = Plot3DNumPVars+Plot3DNumQVars+Plot3DHasIBlank;
                  if (Plot3DVarFormat == Var_GridAndFunctionAndQ)
                    NumVars += Plot3DNumFVars;
                  TrimAndStuffString(&VarName[0],"X",MaxChrsVarName);
                  TrimAndStuffString(&VarName[1],"Y",MaxChrsVarName);
                  TrimAndStuffString(&VarName[2],"IBlnk",MaxChrsVarName);
                  TrimAndStuffString(&VarName[2+Plot3DHasIBlank],"RHO",MaxChrsVarName);
                  TrimAndStuffString(&VarName[3+Plot3DHasIBlank],"RHO-U",MaxChrsVarName);
                  TrimAndStuffString(&VarName[4+Plot3DHasIBlank],"RHO-V",MaxChrsVarName);
                  TrimAndStuffString(&VarName[5+Plot3DHasIBlank],"E",MaxChrsVarName);
                  if (Plot3DVarFormat == Var_GridAndFunctionAndQ)
                    {
                      int i;
                      for (i = 0; i < Plot3DNumFVars; i++)
                        StuffGenericVarName(&VarName[6+Plot3DHasIBlank+i],i);
                    }
                }
            }
          else if (PreplotIsOk && (short)Plot3DMode == (short)MODE_1D)
            {
              Plot3DNumPVars = 1;
              if (Plot3DVarFormat == Var_GridAndFunction)
                {
                  int i;
                  NumVars = Plot3DNumPVars+Plot3DNumFVars;
                  TrimAndStuffString(&VarName[0],"X",MaxChrsVarName);
                  for (i = 0; i < Plot3DNumFVars; i++)
                    StuffGenericVarName(&VarName[i+1],i);
                }
              else
                {
                  Plot3DNumQVars = 3;
                  NumVars = Plot3DNumPVars+Plot3DNumQVars;
                  if (Plot3DVarFormat == Var_GridAndFunctionAndQ)
                    NumVars += Plot3DNumFVars;
                  TrimAndStuffString(&VarName[0],"X",MaxChrsVarName);
                  TrimAndStuffString(&VarName[1],"V1",MaxChrsVarName);
                  TrimAndStuffString(&VarName[2],"V2",MaxChrsVarName);
                  TrimAndStuffString(&VarName[3],"V3",MaxChrsVarName);
                  if (Plot3DVarFormat == Var_GridAndFunctionAndQ)
                    {
                      int i;
                      for (i = 0; i < Plot3DNumFVars; i++)
                        StuffGenericVarName(&VarName[4+i],i);
                    }
                }
            }
        }
      else
#endif
        {
          EndOfHeader = FALSE;
          do
            {
              if (CurToken == TITLEToken)
                {
                  if (RemoveEqualsSign(FALSE))
                    {
                      if ((CurToken == StringToken) ||
                          (CurToken == IdentToken))
                        {
                          TrimAndCopyCurData(HeaderString,MaxChrsDatasetTitle);
                          GetToken(FALSE,TRUE,InFile);
                        }
                      else
                        ErrorMessage("Expecting a string",TRUE);
                    }
                  else
                    ErrorMessage("Missing Equals Sign after 'TITLE' in header",TRUE);
                }
              else if (CurToken == VARIABLESToken)
                {
                  RecogVarNames();
                  VariablesIdentified = TRUE;
                }
              else if ((CurToken == TEXTToken)           ||
                       (CurToken == GEOMETRYToken)       ||
                       (CurToken == DATASETAUXDATAToken) ||
                       (CurToken == VARAUXDATAToken)     ||
                       (CurToken == CUSTOMLABELToken)    ||
                       (CurToken == ZONEToken)           ||
                       (CurToken == USERRECToken)        ||
                       (CurToken == ValueToken))
                {
                  EndOfHeader = TRUE;
                }
              else if (CurToken == EndofFileToken)
                {
                  ErrorMessage("Unexpected End of File in Datafile header",FALSE);
                }
              else
                {
                  WarnMsg("Expecting Record Marker or Data.  Skipping Current token", FALSE);
                  SkipToken(InFile);
                  GetToken(FALSE,TRUE,InFile);
                }
            }
          while (!EndOfHeader && PreplotIsOk);
        } /* else if Is Plot3D */

      if (PreplotIsOk)
        {
/*Write out header information*/
          char VerBuf[5];
          sprintf(VerBuf,"V%-3d",TecplotBinaryFileVersion);
          CHECK(strlen(VerBuf) == 4);
          fprintf(PlotFile,"#!TD%s",VerBuf);
          WriteI(PlotFile,1);
          DumpString(HeaderString);

          /* initialize zone number */
          CurZone = 0;

          if (!VariablesIdentified)
            {
              if (CurToken == ZONEToken)
                {
                  RecogZoneHeader();
                  if (PreplotIsOk && DataPacking[CurZone] == BLOCKPACKING)
                    ErrorMessage("VARIABLES= statement must be used if\nfirst zone format is not POINT",FALSE);
                  ZoneHeaderParsed = TRUE;
                }
              if (PreplotIsOk && (CurToken == ValueToken))
                {
                  NumVars = 0;
                  while (PreplotIsOk && CurToken == ValueToken)
                    {
                      GetToken(FALSE,FALSE,InFile);
                      NumVars++;
                      if ( NumVars >= MaxNumVars )
                        ErrorMessage("Maximum number of variables exceeded (increase MaxNumVars)",FALSE);
                    }
                  if (PreplotIsOk && (CurToken != EndofVarLineToken))
                    ErrorMessage("Bad value",TRUE);
                  LinePos = 0;
                  GetToken(FALSE,TRUE,InFile);
                }
              else
                {
                  NumVars = 2;
                }
              for (I = 0; I < NumVars && PreplotIsOk; I++)
                {
                  StuffGenericVarName(&VarName[I],I);
                }
            }

          if (PreplotIsOk)
            WriteI(PlotFile,(LgIndex)NumVars);

          if ( PreplotIsOk && (NodeVar >= NumVars ))
            ErrorMessage("NV is set greater than the number of variables",TRUE);

          I = 0;
          while (PreplotIsOk && (I < NumVars))
            {
              DumpString(VarName[I]);
              I++;
            }
#if defined PLOT3D
          if (PreplotIsOk && InputIsPlot3D)
            {
              /* first need to split up the .g and .q files into
                 many single variable arrays */
              for (L = 0; L < NumVars && PreplotIsOk; L++)
                {
                  Index = 0;
                  for (I = 0; I < Plot3DNumGrids; I++)
                    {
                      Plot3DGridBase[I] = Index;
                      if (Plot3DMode == MODE_UNSTRUCTURED)
                        Index += Plot3DIDim[I];
                      else
                        {
                          Index += Plot3DIDim[I]*
                                   Plot3DJDim[I]*
                                   Plot3DKDim[I];
                        }
                    }

                  if (Echo)
                    printf("Allocating space for %d values\n",Index);
                  Plot3DVarArray[L]         = ALLOC_ARRAY(Index,float,"plot 3d Var array");
                  Plot3DVarArrayCurIndex[L] = 0;
                  if (Plot3DVarArray[L] == NULL)
                    ErrorMessage("Ran out of swap space processing PLOT3D data",FALSE);
                }

              if (Plot3DMode == MODE_UNSTRUCTURED)
                {
                  Index = 0;
                  for (I = 0; I < Plot3DNumGrids; I++)
                    {
                      Plot3DConnectivityBase[I] = Index;
                      if (Plot3DJDim[I] > 0)
                        Index += Plot3DJDim[I]*3;
                      else
                        Index += Plot3DKDim[I]*4;
                    }
                  Plot3DConnectivityArray = ALLOC_ARRAY(Index,LgIndex,"Plot 3D Connectivity Array");
                }

              /* put case in here to divvy up the variables */
              if (PreplotIsOk && Echo)
                printf("Transferring Data for Plot3DVarArrays ....\n");
              for (I = 0; PreplotIsOk && (I < Plot3DNumGrids); I++)
                {
                  int M;
                  if (InFile_q)
                    {
                      if (Plot3DInputHasRecordMarks)      /* Header Rec */
                        Plot3D_GetRecordMarks(InFile_q);
                      printf("Removing constants ...\n");
                      Plot3D_GetToken(InFile_q,FALSE);
                      printf("FSMACH = %G\n",CurTValue);
                      Plot3D_GetToken(InFile_q,FALSE);
                      printf("ALPHA  = %G\n",CurTValue);
                      Plot3D_GetToken(InFile_q,FALSE);
                      printf("RE     = %G\n",CurTValue);
                      Plot3D_GetToken(InFile_q,FALSE);
                      printf("TIME   = %G\n",CurTValue);
#if !defined OLDCRAY || defined CRAYIEEE
                      if (Plot3DInputHasRecordMarks) /* Trailer Rec */
                        Plot3D_GetRecordMarks(InFile_q);
#endif
                    }

                  if (Plot3DInputHasRecordMarks &&
                      (Plot3DMode != MODE_3DP))  /* Header Rec */
                    Plot3D_GetAllRecordMarks();

                  /*
                   *  Load the variables....
                   */
                  M = 0;
                  switch (Plot3DMode)
                    {
                      case MODE_1D :
                        {
                          Plot3D_LoadVar(InFile,FALSE,M++,Plot3DIDim[I]);
                          for (J = 0; J < Plot3DNumQVars; J++)
                            Plot3D_LoadVar(InFile_q,FALSE,M++,Plot3DIDim[I]);
                          for (J = 0; J < Plot3DNumFVars; J++)
                            Plot3D_LoadVar(InFile_f,FALSE,M++,Plot3DIDim[I]);
                        } break;
                      case MODE_2D :
                        {
                          Index = Plot3DIDim[I]*Plot3DJDim[I];
                          for (J = 0; J < Plot3DNumPVars; J++)
                            Plot3D_LoadVar(InFile,FALSE,M++,Index);

                          if (Plot3DHasIBlank)
                            Plot3D_LoadVar(InFile,TRUE,M++,Index);

                          for (J = 0; J < Plot3DNumQVars; J++)
                            Plot3D_LoadVar(InFile_q,FALSE,M++,Index);
                          for (J = 0; J < Plot3DNumFVars; J++)
                            Plot3D_LoadVar(InFile_f,FALSE,M++,Index);
                        } break;
                      case MODE_3DP :
                        {
                          Index = Plot3DIDim[I]*Plot3DJDim[I];
                          for (K = 0; K < Plot3DKDim[I]; K++)
                            {
                              M = 0;
                              if (Plot3DInputHasRecordMarks)
                                Plot3D_GetAllRecordMarks();

                              for (J = 0; J < Plot3DNumPVars; J++)
                                Plot3D_LoadVar(InFile,FALSE,M++,Index);
                              if (Plot3DHasIBlank)
                                Plot3D_LoadVar(InFile,TRUE,M++,Index);
                              for (J = 0; J < Plot3DNumQVars; J++)
                                Plot3D_LoadVar(InFile_q,FALSE,M++,Index);
                              for (J = 0; J < Plot3DNumFVars; J++)
                                Plot3D_LoadVar(InFile_f,FALSE,M++,Index);
#if !defined OLDCRAY || defined CRAYIEEE
                              if (Plot3DInputHasRecordMarks)
                                Plot3D_GetAllRecordMarks();
#endif
                            }
                        } break;
                      case MODE_3DW :
                        {
                          Index = Plot3DIDim[I]*Plot3DJDim[I]*Plot3DKDim[I];
                          for (J = 0; J < Plot3DNumPVars; J++)
                            Plot3D_LoadVar(InFile,FALSE,M++,Index);
                          if (Plot3DHasIBlank)
                            Plot3D_LoadVar(InFile,TRUE,M++,Index);
                          for (J = 0; J < Plot3DNumQVars; J++)
                            Plot3D_LoadVar(InFile_q,FALSE,M++,Index);
                          for (J = 0; J < Plot3DNumFVars; J++)
                            Plot3D_LoadVar(InFile_f,FALSE,M++,Index);
                        } break;
                      case MODE_UNSTRUCTURED :
                        {
                          Index = Plot3DIDim[I];
                          for (J = 0; J < 3; J++)
                            Plot3D_LoadVar(InFile,FALSE,M++,Index);
                          if (Plot3DHasIBlank)
                            Plot3D_LoadVar(InFile,TRUE,M++,Index);
                          Plot3D_LoadConnectAndFlags(InFile,I);
                        } break;
                      default :
                        {
                          CHECK(FALSE);
                        } break;
                    }
#if !defined OLDCRAY || defined CRAYIEEE
                  if (Plot3DInputHasRecordMarks &&
                      (Plot3DMode != MODE_3DP))
                    Plot3D_GetAllRecordMarks();
#endif
                }

        /*  Next pull data from var files and stuff into BlckFile */

              Plot3DCurGrid = 0;
              while (PreplotIsOk && (Plot3DCurGrid < Plot3DNumGrids))
                {
                  switch (Plot3DMode)
                    {
                      case MODE_1D :
                        {
                          long VarMinMaxOffset;
                          Plot3D_DumpZoneStart(&VarMinMaxOffset);
                          printf("\nZone : %3d\n",CurZone+1);
                          /*Set Defaults*/
                          TrimAndStuffString(&ZoneName[CurZone],"ZONE xxx",MaxChrsZnTitle);
                          ZoneName[CurZone][5] = '0' + (CurZone+1) / 100;
                          ZoneName[CurZone][6] = '0' + ((CurZone+1) % 100) / 10;
                          ZoneName[CurZone][7] = '0' + (CurZone+1) % 10;
                          IMax[CurZone] = Plot3DIDim[Plot3DCurGrid];
                          JMax[CurZone] = 1;
                          KMax[CurZone] = 1;
                          DumpPlot3DZoneHeaderInfo(ZoneName[CurZone],
                                                   IMax[CurZone],
                                                   JMax[CurZone],
                                                   KMax[CurZone]);

                          Index = IMax[CurZone]*JMax[CurZone];
                          printf("Var  : ");
                          for (J = 0; J < NumVars; J++)
                            {
                              Plot3DVarMin[J] =  LARGEDOUBLE;
                              Plot3DVarMax[J] = -LARGEDOUBLE;
                              Plot3D_ExtractBlock(BlckFile,J,2,Plot3DCurGrid,' ',&Plot3DVarMin[J],&Plot3DVarMax[J]);
                            }
                          Plot3D_RewriteVarMinMaxValues(BlckFile,VarMinMaxOffset,Plot3DVarMin,Plot3DVarMax);
                          CurZone++;
                        } break; /* MODE_1D */
                      case MODE_2D :
                        {
                          long VarMinMaxOffset;
                          Plot3D_DumpZoneStart(&VarMinMaxOffset);
                          printf("\nZone : %3d\n",CurZone+1);
                          /*Set Defaults*/
                          TrimAndStuffString(&ZoneName[CurZone],"ZONE xxx",MaxChrsZnTitle);
                          ZoneName[CurZone][5] = '0' + (CurZone+1) / 100;
                          ZoneName[CurZone][6] = '0' + ((CurZone+1) % 100) / 10;
                          ZoneName[CurZone][7] = '0' + (CurZone+1) % 10;
                          IMax[CurZone] = Plot3DIDim[Plot3DCurGrid];
                          JMax[CurZone] = Plot3DJDim[Plot3DCurGrid];
                          KMax[CurZone] = 1;
                          DumpPlot3DZoneHeaderInfo(ZoneName[CurZone],
                                                   IMax[CurZone],
                                                   JMax[CurZone],
                                                   KMax[CurZone]);

                          Index = IMax[CurZone]*JMax[CurZone];
                          printf("Var  : ");
                          for (J = 0; J < NumVars; J++)
                            {
                              Plot3DVarMin[J] =  LARGEDOUBLE;
                              Plot3DVarMax[J] = -LARGEDOUBLE;
                              Plot3D_ExtractBlock(BlckFile,J,0,Plot3DCurGrid,' ',&Plot3DVarMin[J],&Plot3DVarMax[J]);
                            }
                          Plot3D_RewriteVarMinMaxValues(BlckFile,VarMinMaxOffset,Plot3DVarMin,Plot3DVarMax);
                          CurZone++;
                        } break; /* MODE_2D  */
                      case MODE_3DP :
                      case MODE_3DW :
                        {
                          if (IJKSetSet)
                            {
                              /* I planes */
                              for (I = 0; I < Plot3DIDim[Plot3DCurGrid]; I++)
                                {
                                  if (inset(I,Plot3DISet))
                                    {
                                      long VarMinMaxOffset;
                                      Plot3D_DumpZoneStart(&VarMinMaxOffset);
                                      printf("\nZone=%-3d,  I=%d\n",CurZone+1,I+1);
                                      /*Set Defaults*/
                                      sprintf(CurData,"G%-3d,P%-3d ",(int)Plot3DCurGrid+1,(int)I+1);
                                      TrimAndStuffString(&ZoneName[CurZone],CurData,MaxChrsZnTitle);
                                      if (Echo)
                                        printf("Zone Name ->%s<-\n",ZoneName[CurZone]);
                                      IMax[CurZone] = Plot3DJDim[Plot3DCurGrid];
                                      JMax[CurZone] = Plot3DKDim[Plot3DCurGrid];
                                      KMax[CurZone] = 1;
                                      DumpPlot3DZoneHeaderInfo(ZoneName[CurZone],
                                                               IMax[CurZone],
                                                               JMax[CurZone],
                                                               KMax[CurZone]);
                                      if (Echo)
                                        printf("Var Plane\n");
                                      else
                                        printf("Var:");
                                      for (N = 0; N < NumVars; N++)
                                        {
                                          Plot3DVarMin[N] =  LARGEDOUBLE;
                                          Plot3DVarMax[N] = -LARGEDOUBLE;
                                          Plot3D_ExtractBlock(BlckFile,N,I,Plot3DCurGrid,'I',&Plot3DVarMin[N],&Plot3DVarMax[N]);
                                        }
                                      Plot3D_RewriteVarMinMaxValues(BlckFile,VarMinMaxOffset,Plot3DVarMin,Plot3DVarMax);
                                      CurZone++;
                                    }
                                } /* for I */

                              /* J Planes */
                              for (J = 0; J < Plot3DJDim[Plot3DCurGrid]; J++)
                                {
                                  if (inset(J,Plot3DJSet))
                                    {
                                      long VarMinMaxOffset;
                                      Plot3D_DumpZoneStart(&VarMinMaxOffset);
                                      printf("\nZone=%-3d,  J=%d\n",CurZone+1,J+1);
                                      /*Set Defaults*/
                                      sprintf(CurData,"G%-3d,P%-3d ",(int)Plot3DCurGrid+1,(int)J+1);
                                      TrimAndStuffString(&ZoneName[CurZone],CurData,MaxChrsZnTitle);
                                      if (Echo)
                                        printf("Zone Name ->%s<-\n",ZoneName[CurZone]);
                                      IMax[CurZone] = Plot3DIDim[Plot3DCurGrid];
                                      JMax[CurZone] = Plot3DKDim[Plot3DCurGrid];
                                      KMax[CurZone] = 1;
                                      DumpPlot3DZoneHeaderInfo(ZoneName[CurZone],
                                                               IMax[CurZone],
                                                               JMax[CurZone],
                                                               KMax[CurZone]);
                                      if (Echo)
                                        printf("Var Plane\n");
                                      else
                                        printf("Var:");
                                      for (N = 0; N < NumVars; N++)
                                        {
                                          Plot3DVarMin[N] =  LARGEDOUBLE;
                                          Plot3DVarMax[N] = -LARGEDOUBLE;
                                          Plot3D_ExtractBlock(BlckFile,N,J,Plot3DCurGrid,'J',&Plot3DVarMin[N],&Plot3DVarMax[N]);
                                        }
                                      Plot3D_RewriteVarMinMaxValues(BlckFile,VarMinMaxOffset,Plot3DVarMin,Plot3DVarMax);
                                      CurZone++;
                                    }
                                } /* for J */

                              /* K Planes */
                              for (K = 0; K < Plot3DKDim[Plot3DCurGrid]; K++)
                                {
                                  Fetch = inset(K,Plot3DKSet);
                                  if (Fetch)
                                    {
                                      long VarMinMaxOffset;
                                      Plot3D_DumpZoneStart(&VarMinMaxOffset);
                                      printf("\nZone=%-3d,  K=%d\n",CurZone+1,K+1);
                                      /*Set Defaults*/
                                      sprintf(CurData,"G%-3d,P%-3d ",(int)Plot3DCurGrid+1,(int)K+1);
                                      TrimAndStuffString(&ZoneName[CurZone],CurData,MaxChrsZnTitle);
                                      if (Echo)
                                        printf("Zone Name ->%s<-\n",ZoneName[CurZone]);
                                      IMax[CurZone] = Plot3DIDim[Plot3DCurGrid];
                                      JMax[CurZone] = Plot3DJDim[Plot3DCurGrid];
                                      KMax[CurZone] = 1;
                                      DumpPlot3DZoneHeaderInfo(ZoneName[CurZone],
                                                               IMax[CurZone],
                                                               JMax[CurZone],
                                                               KMax[CurZone]);
                                      if (Echo)
                                        printf("Var Plane\n");
                                      else
                                        printf("Var:");
                                      for (N = 0; N < NumVars; N++)
                                        {
                                          Plot3DVarMin[N] =  LARGEDOUBLE;
                                          Plot3DVarMax[N] = -LARGEDOUBLE;
                                          Plot3D_ExtractBlock(BlckFile,N,K,Plot3DCurGrid,'K',&Plot3DVarMin[N],&Plot3DVarMax[N]);
                                        }
                                      Plot3D_RewriteVarMinMaxValues(BlckFile,VarMinMaxOffset,Plot3DVarMin,Plot3DVarMax);
                                      CurZone++;
                                    }
                                }
                            }
                          else
                            { /* IJK zone */
                              long VarMinMaxOffset;
                              Plot3D_DumpZoneStart(&VarMinMaxOffset);
                              printf("\nZone=%-3d ",CurZone+1);
                              /*Set Defaults*/
                              sprintf(CurData,"G%-3d",(int)Plot3DCurGrid+1);
                              TrimAndStuffString(&ZoneName[CurZone],CurData,MaxChrsZnTitle);
                              if (Echo)
                                printf("Zone Name ->%s<-\n",ZoneName[CurZone]);
                              IMax[CurZone] = Plot3DIDim[Plot3DCurGrid];
                              JMax[CurZone] = Plot3DJDim[Plot3DCurGrid];
                              KMax[CurZone] = Plot3DKDim[Plot3DCurGrid];
                              if (Plot3DCollapseIJK)
                                {
                                  if (JMax[CurZone] == 1)
                                    {
                                      JMax[CurZone] = KMax[CurZone];
                                      KMax[CurZone] = 1;
                                    }
                                  if (IMax[CurZone] == 1)
                                    {
                                      IMax[CurZone] = JMax[CurZone];
                                      JMax[CurZone] = KMax[CurZone];
                                      KMax[CurZone] = 1;
                                    }
                                }
                              DumpPlot3DZoneHeaderInfo(ZoneName[CurZone],
                                                       IMax[CurZone],
                                                       JMax[CurZone],
                                                       KMax[CurZone]);
                              if (Echo)
                                printf("Var Plane\n");
                              else
                                printf("Var:");
                              for (N = 0; N < NumVars; N++)
                                {
                                  Plot3DVarMin[N] =  LARGEDOUBLE;
                                  Plot3DVarMax[N] = -LARGEDOUBLE;
                                  for (K = 0; K < Plot3DKDim[Plot3DCurGrid]; K++)
                                    Plot3D_ExtractBlock(BlckFile,N,K,Plot3DCurGrid,'K',&Plot3DVarMin[N],&Plot3DVarMax[N]);
                                }
                              Plot3D_RewriteVarMinMaxValues(BlckFile,VarMinMaxOffset,Plot3DVarMin,Plot3DVarMax);
                              CurZone++;
                            }
                        } break; /* MODE_3Dx */
                      case MODE_UNSTRUCTURED :
                        {
                          LgIndex GridBase = Plot3DGridBase[Plot3DCurGrid];
                          long VarMinMaxOffset;
                          Plot3D_DumpZoneStart(&VarMinMaxOffset);
                          printf("\nZone=%-3d ",CurZone+1);
                          /*Set Defaults*/
                          sprintf(CurData,"G%-3d US",(int)Plot3DCurGrid+1);
                          TrimAndStuffString(&ZoneName[CurZone],CurData,MaxChrsZnTitle);
                          if (Echo)
                            printf("Zone Name ->%s<-\n",ZoneName[CurZone]);

                          /* Dump the unstructured zone header */
                          DumpString(ZoneName[CurZone]);
                          WriteI(PlotFile, BAD_SET_VALUE);    /* ie. no ParentZone (zero based) */
                          WriteI(PlotFile, STRAND_ID_STATIC); /* ie. static StrandID (zero based) */
                          WriteR(PlotFile, 0.0,         /* zero time */
                                 FieldDataType_Double);
                          WriteI(PlotFile,-1);          /* No Color */
                          if (Plot3DJDim[Plot3DCurGrid] > 0)
                            WriteI(PlotFile,(LgIndex)FETRIANGLE);
                          else
                            WriteI(PlotFile,(LgIndex)FETETRAHEDRON);
                          WriteI(PlotFile,(LgIndex)0);  /* Data Packing = Block */
                          WriteI(PlotFile,(LgIndex)0);  /* Var Location, 0 = all data is at nodes */
                          WriteI(PlotFile,(LgIndex)0);  /* are raw face neighbors available? */
                          WriteI(PlotFile,(LgIndex)0);  /* Num User defined face neighbors. */
                          IMax[CurZone] = Plot3DIDim[Plot3DCurGrid];
                          WriteI(PlotFile,IMax[CurZone]);
                          if (Plot3DJDim[Plot3DCurGrid] > 0)
                            WriteI(PlotFile,Plot3DJDim[Plot3DCurGrid]);
                          else
                            WriteI(PlotFile,Plot3DKDim[Plot3DCurGrid]);
                          WriteI(PlotFile,0); /* ICellDim:unused */
                          WriteI(PlotFile,0); /* JCellDim:unused */
                          WriteI(PlotFile,0); /* KCellDim:unused */
                          WriteI(PlotFile,(LgIndex)0); /* No more aux data name/value pairs. */

#if !defined TECPLOTKERNEL
                          printf("Var:");
#endif
                          for (N = 0; N < NumVars; N++)
                            {
                              LgIndex I;
                              Plot3DVarMin[N] =  LARGEDOUBLE;
                              Plot3DVarMax[N] = -LARGEDOUBLE;
                              for (I = 0; I < IMax[CurZone]; I++)
                                {
                                  double VarValue = Plot3DVarArray[N][GridBase+I];
                                  WriteR(BlckFile, VarValue, FieldDataType_Float);
                                  if (VarValue < Plot3DVarMin[N])
                                    Plot3DVarMin[N] = VarValue;
                                  if (VarValue > Plot3DVarMax[N])
                                    Plot3DVarMax[N] = VarValue;
                                }
#if !defined TECPLOTKERNEL
                              printf("%d,",N+1);
                              fflush(stdout);
#endif
                            }
#if !defined TECPLOTKERNEL
                          putchar('\n');
#endif
                          Plot3D_DumpConnectList(BlckFile,
                                                 Plot3DCurGrid);
                          Plot3D_RewriteVarMinMaxValues(BlckFile,VarMinMaxOffset,Plot3DVarMin,Plot3DVarMax);
                          CurZone++;
                        } break; /* Unstructured */
                      default :
                        {
                          CHECK(FALSE);
                        } break;
                    } /* switch Plot3DMode */
                  Plot3DCurGrid++;
                } /*While CurGrid */
            }
          else
#endif /*PLOT3D*/
            {
              CurZone = 0;
              while (PreplotIsOk && (CurToken != EndofFileToken))
                {
                  if ((CurToken == ZONEToken) ||
                      ((CurZone == 0) && (CurToken == ValueToken)))
                    {
                      Boolean_t ZoneIsEnabled;
                      ZoneIsEnabled = ZoneIsOk(CurZone);
#ifdef TECPLOTKERNEL                      
                      PreplotChecksum[CurZone] = 0;
#endif

                      if (PreplotIsOk)
                        {
                          if (ZoneIsEnabled)
                            {
                              WriteR(PlotFile,ZONEMARKER,FieldDataType_Float);
                              WriteR(BlckFile,ZONEMARKER,FieldDataType_Float);
                            }
                          if (!ZoneHeaderParsed)
                            RecogZoneHeader();
                          ZoneHeaderParsed = FALSE;

                          if (ZoneIsEnabled)
                            {
                              Boolean_t IsAnyVarPassive = FALSE;
                              Boolean_t IsAnyVarShared = FALSE;
                              for (N = 0; PreplotIsOk && (N < NumVars); N++)
                                {
                                  /* output the variable data type */
                                  WriteI(BlckFile,(LgIndex)VarDataType[N]);

                                  /* determine if any variables are passive or shared */
                                  if (VarIsPassive[N])
                                    IsAnyVarPassive = TRUE;
                                  if (VarShareZone[N] != -1)
                                    IsAnyVarShared = TRUE;
                                }
                              if (IsAnyVarPassive)
                                {
                                  /* one or more variables are passive */
                                  WriteI(BlckFile, 1);
                                  for (N = 0; PreplotIsOk && (N < NumVars); N++)
                                    WriteI(BlckFile,(LgIndex)VarIsPassive[N]);
                                }
                              else
                                {
                                  /* no variables are passive */
                                  WriteI(BlckFile, 0);
                                }

                              if (IsAnyVarShared)
                                {
                                  /* one or more variables are sharing */
                                  WriteI(BlckFile, 1);
                                  for (N = 0; PreplotIsOk && (N < NumVars); N++)
                                    WriteI(BlckFile,(LgIndex)VarShareZone[N]);
                                }
                              else
                                {
                                  /* no variables are sharing */
                                  WriteI(BlckFile, 0);
                                }

                              /* ordered and FE connectivity sharing (node map and face neighbor) */
                              WriteI(BlckFile, ConnectivityShareZone[CurZone]);
                            }

                          if (PreplotIsOk)
                            {
                              if (ZoneType[CurZone] != ORDERED)
                                JJMax = 1;
                              else
                                JJMax = JMax[CurZone];

                              if (NodeVar >= 0)
                                if ( VarShareZone[NodeVar] == -1 )
                                  Reset_NodeList(IMax[CurZone]+1);
                            }

                          if (PreplotIsOk &&
                              (IMax[CurZone] != 0 ||
                               JMax[CurZone] != 0 ||
                               KMax[CurZone] != 0))
                            {
                              long VarMinMaxOffset = -1;
                              if (ZoneIsEnabled)
                                {
                                  /*
                                   * Keep track of where to put the variable
                                   * min/max values (once we know them) and
                                   * then fill in the min/max values with
                                   * placeholders.
                                   */
                                  VarMinMaxOffset = FTELL(BlckFile);
                                  PreplotIsOk = (VarMinMaxOffset != -1);
                                  for (N = 0; (N < NumVars) && PreplotIsOk; N++)
                                    {
                                      if (VarIsPassive[N] == FALSE && VarShareZone[N] == -1)
                                        {
                                          WriteR(BlckFile, 0.0, FieldDataType_Double);
                                          WriteR(BlckFile, 0.0, FieldDataType_Double);
                                        }
                                    }
                                }

                              if (IStart[CurZone] == 0)
                                IStart[CurZone] = IMax[CurZone];
                              if (JStart[CurZone] == 0)
                                JStart[CurZone] = JMax[CurZone];
                              if (KStart[CurZone] == 0)
                                KStart[CurZone] = KMax[CurZone];
                              if (IEnd[CurZone] == 0)
                                IEnd[CurZone] = IMax[CurZone];
                              if (JEnd[CurZone] == 0)
                                JEnd[CurZone] = JMax[CurZone];
                              if (KEnd[CurZone] == 0)
                                KEnd[CurZone] = KMax[CurZone];
                              if (Echo)
                                {
                                  printf("IStart=%5d, IEnd=%5d, ISkip=%5d, IMax=%d\n",
                                          IStart[CurZone],IEnd[CurZone],ISkip[CurZone],IMax[CurZone]);
                                  printf("JStart=%5d, JEnd=%5d, JSkip=%5d, JMax=%d\n",
                                          JStart[CurZone],JEnd[CurZone],JSkip[CurZone],JJMax);
                                  printf("KStart=%5d, KEnd=%5d, KSkip=%5d, KMax=%d\n",
                                          KStart[CurZone],KEnd[CurZone],KSkip[CurZone],KMax[CurZone]);
                                }

                              /* read/write data section */

                              if (DataPacking[CurZone] == BLOCKPACKING)
                                {
#if !defined TECPLOTKERNEL
                                  if (!Echo)
                                    printf("Var  : ");
                                  fflush(stdout);
#endif
                                  for (N = 0; (N < NumVars) && PreplotIsOk; N++)
                                    {
                                      if (Echo)
                                        printf("\nReading Var: %d\n",(int)N+1);
#if !defined TECPLOTKERNEL
                                      else if (ZoneIsEnabled)
                                        printf("%3d",N+1);
                                      fflush(stdout);
#endif
                                      if (VarIsPassive[N] == FALSE && VarShareZone[N] == -1)
                                        {
                                          GetBlock(BlckFile,ZoneIsEnabled,
                                                            IStart[CurZone],
                                                            IEnd[CurZone],
                                                            ISkip[CurZone],
                                                            IMax[CurZone],
                                                            JStart[CurZone],
                                                            JEnd[CurZone],
                                                            JSkip[CurZone],
                                                            JMax[CurZone],
                                                            KStart[CurZone],
                                                            KEnd[CurZone],
                                                            KSkip[CurZone],
                                                            KMax[CurZone],
                                                            N,
                                                            VarDataType[N],
                                                            VarIsCellCentered[N],
                                                            1.0,
                                                            &VarMin[N],
                                                            &VarMax[N]);
                                        }
                                    }
                                }
                              else if ((IEnd[CurZone] != 0) &&
                                       (JEnd[CurZone] != 0) &&
                                       (KEnd[CurZone] != 0))
                                {
                                  Index = 0;
                                  Done  = FALSE;
                                  K     = 0;
                                  for (N = 0; N < NumVars; N++)
                                    {
                                      VarMin[N] =  LARGEDOUBLE;
                                      VarMax[N] = -LARGEDOUBLE;
                                    }
                                  do
                                    {
                                      K++;
                                      J = 0;
                                      do
                                        {
                                          J++;
                                          I = 0;
                                          do
                                            {
                                              I++;
                                              IndexIsGood = ((ZoneType[CurZone] != ORDERED) ||
                                                             ((IStart[CurZone] <= I && I <= IEnd[CurZone]) &&
                                                              (JStart[CurZone] <= J && J <= JEnd[CurZone]) &&
                                                              (KStart[CurZone] <= K && K <= KEnd[CurZone]) &&
                                                              (I == IEnd[CurZone] || (((I-IStart[CurZone]) % ISkip[CurZone]) == 0)) &&
                                                              (J == JEnd[CurZone] || (((J-JStart[CurZone]) % JSkip[CurZone]) == 0)) &&
                                                              (K == KEnd[CurZone] || (((K-KStart[CurZone]) % KSkip[CurZone]) == 0))));

                                              if (IndexIsGood)
                                                LastI = I;

                                              VarsProcessed = 0;
                                              for (N = 0; (N < NumVars) && PreplotIsOk && !Done; N++)
                                                {
                                                  if (VarIsPassive[N] == FALSE && VarShareZone[N] == -1)
                                                    {
                                                      if (ZoneType[CurZone] == ORDERED &&
                                                          DataPacking[CurZone] == POINTPACKING)
                                                        Done = (CurToken != ValueToken);
                                                      if (!Done)
                                                        {
                                                          PreplotIsOk = (CurToken == ValueToken);
                                                          if (PreplotIsOk)
                                                            {
                                                              if (IndexIsGood)
                                                                {
                                                                  if (ZoneIsEnabled)
                                                                    {
                                                                      WriteR(BlckFile,
                                                                             CurTValue,
                                                                             VarDataType[N]);

                                                                      /* keep track of the min/max value for variables */
                                                                      if (CurTValue < VarMin[N])
                                                                        VarMin[N] = CurTValue;
                                                                      if (CurTValue > VarMax[N])
                                                                        VarMax[N] = CurTValue;
                                                                    }

                                                                  if ( N == NodeVar )
                                                                    Add_To_NodeList(I, CurTValue);
                                                                }
                                                              GetToken(FALSE,TRUE,InFile);
                                                            }
                                                          VarsProcessed++;
                                                        }
                                                    }
                                                  else
                                                    VarsProcessed++;
                                                }

                                              if (!Done)
                                                {
                                                  if (ZoneType[CurZone] == ORDERED)
                                                    Done = (CurToken != ValueToken &&
                                                            IMax[CurZone] == LargestIndex);
                                                  if (ZoneType[CurZone] != ORDERED)
                                                    Done = (I == IMax[CurZone]);
                                                }

                                              if (ZoneIsEnabled && ((++Index % 250) == 0))
                                                {
#if !defined TECPLOTKERNEL
                                                  putchar('.');
                                                  if ((Index % 10000) == 0)
                                                    {
                                                      printf("%d\n",I);
                                                    }
                                                  fflush(stdout);
#endif
                                                }
                                            }
                                          while (!Done                              &&
                                                 (IMax[CurZone] == LargestIndex ||
                                                  I < IMax[CurZone])                &&
                                                 PreplotIsOk);
                                        }
                                      while (!Done && (J < JJMax) && PreplotIsOk);
                                    }
                                  while (!Done             &&
                                         K < KMax[CurZone] &&
                                         PreplotIsOk);

                                  if (VarsProcessed != NumVars)
                                    PreplotIsOk = FALSE;
                                  if (PreplotIsOk)
                                    {
                                      /*
                                       * Check to make sure that the correct
                                       * number of values were read in
                                       */
                                      if (ZoneType[CurZone] == ORDERED &&
                                          DataPacking[CurZone] == POINTPACKING)
                                        {
                                          if (IMax[CurZone] != LargestIndex)
                                            PreplotIsOk = (I == IMax[CurZone]) &&
                                                   (J == JJMax) &&
                                                   (K == KMax[CurZone]);
                                          else
                                            {
                                              PreplotIsOk = (J == JMax[CurZone] &&
                                                             K == KMax[CurZone]);
                                              if (PreplotIsOk)
                                                {
                                                  if (I < IEnd[CurZone])
                                                    IEnd[CurZone] = LastI;
                                                }
                                            }
                                        }
                                    }
                                  if (!PreplotIsOk)
                                    {
                                      char EMsg[120];
                                      if (CurToken == EndofFileToken)
                                        {
                                          sprintf(EMsg,"Unexpected end of file after location I,J,K,Var = %d,%d,%d,%d",I,J,K,VarsProcessed);
                                          ErrorMessage(EMsg,FALSE);
                                        }
                                      else
                                        {
                                          sprintf(EMsg,"Expecting a value after location I,J,K,Var = %d,%d,%d,%d",I,J,K,VarsProcessed);
                                          ErrorMessage(EMsg,TRUE);
                                        }
                                    }
                                }

                              if (ZoneIsEnabled && PreplotIsOk)
                                {
                                  /* go back and re-write the var min/max values */
                                  long CurrentOffset = FTELL(BlckFile);
                                  PreplotIsOk = (CurrentOffset != -1 &&
                                                 FSEEK(BlckFile, VarMinMaxOffset, SEEK_SET) != -1);
                                  for (N = 0; (N < NumVars) && PreplotIsOk; N++)
                                    {
                                      if (VarIsPassive[N] == FALSE && VarShareZone[N] == -1)
                                        {
                                          WriteR(BlckFile, VarMin[N], FieldDataType_Double);
                                          WriteR(BlckFile, VarMax[N], FieldDataType_Double);
                                        }
                                    }
                                  if (PreplotIsOk)
                                    PreplotIsOk = (FSEEK(BlckFile, CurrentOffset, SEEK_SET) != -1);
                                }

                              /* write FE connectivity */
                              if (ZoneType[CurZone] != ORDERED && PreplotIsOk)
                                {
                                  if (ConnectivityShareZone[CurZone] == -1)
                                    {
                                      switch (ZoneType[CurZone])
                                        {
                                          case FELINESEG       : L = 2;        break;
                                          case FETRIANGLE      : L = 3;        break;
                                          case FEQUADRILATERAL : L = 4;        break;
                                          case FETETRAHEDRON   : L = 4;        break;
                                          case FEBRICK         : L = 8;        break;
                                          default              : CHECK(FALSE); break;
                                        }
                                      J = 0;
                                      while ((CurToken == ValueToken) && (J < JMax[CurZone]))
                                        {
                                          J++;
                                          for (I = 0; PreplotIsOk && (I < L); I++)
                                            {
                                              char TString[80];
                                              if (CurToken != ValueToken)
                                                {
                                                  sprintf(TString,"Err: Bad or Missing FE Cell Indices for Cell %d\n",J);
                                                  ErrorMessage(TString,TRUE);
                                                }

                                              if (PreplotIsOk && (NodeVar >= 0))
                                                {
                                                  LgIndex   NN;
                                                  NN = Find_In_NodeList(CurTValue);
                                                  if ( NN == 0)
                                                    {
                                                      sprintf(TString,"Err: FE Cell %d has index of %d not found in Node Variable\n",J,(int)CurTValue);
                                                      ErrorMessage(TString,TRUE);
                                                    }
                                                  if (ZoneIsEnabled)
                                                    WriteI(BlckFile,NN-1); /* as of version 103 binary node values are zero based */
                                                }
                                              else if (PreplotIsOk)
                                                {
                                                  if ( (CurTValue < 1) || (CurTValue > IMax[CurZone]) )
                                                    {
                                                      sprintf(TString,"Err: FE Cell %d has bad index of %d\n",J,(int)CurTValue);
                                                      ErrorMessage(TString,TRUE);
                                                    }
                                                  if (ZoneIsEnabled)
                                                    WriteI(BlckFile,ROUND2(CurTValue)-1); /* as of version 103 binary node values are zero based */
                                                }

                                              GetToken(FALSE,TRUE,InFile);
                                            }
                                        }
                                      if (JMax[CurZone] == LargestIndex)
                                        JMax[CurZone] = J;
                                      else if (J != JMax[CurZone])
                                        ErrorMessage("Not enough elements in Connectivity list",TRUE);
                                    }
                                }

                              /* write FE raw face neighbor array */
                              if (WriteRawFaceNeighborArray      && 
                                  ZoneType[CurZone] != ORDERED   &&
                                  ZoneType[CurZone] != FELINESEG && PreplotIsOk)
                                {
                                  /*
                                   * As of binary version 108 Tecplot introduced
                                   * the ability to output its auto-generated face
                                   * neighbor array in its raw form. For now
                                   * preplot will always decline to perform this
                                   * step and instead fall back to the delivering
                                   * one neighbor at a time.
                                   */
                                  CHECK(FALSE); /* ...should never get here */
                                }

                              /*
                               * Miscellaneous face neighbor connection have the
                               * following format for both ASCII and binary:
                               *
                               *   LOCALONETOONE     3         cz,fz,cz
                               *   LOCALONETOMANY    nz+4      cz,fz,oz,nz,cz1,cz2,...,czn
                               *   GLOBALONETOONE    4         cz,fz,ZZ,CZ
                               *   GLOBALONETOMANY   2*nz+4    cz,fz,oz,nz,ZZ1,CZ1,ZZ2,CZ2,...,ZZn,CZn
                               *  
                               *   Where:
                               *       cz = cell in current zone
                               *       fz = face of cell in current zone
                               *       oz = face obsuration flag (only applies to one-to-many):
                               *              0 = face partially obscured
                               *              1 = face entirely obscured
                               *       nz = number of cell or zone/cell associations (only applies to one-to-many)
                               *       ZZ = remote Zone
                               *       CZ = cell in remote zone
                               */
                              if (ConnectivityShareZone[CurZone] == -1 &&
                                  FaceNeighborConnections != 0         &&
                                  PreplotIsOk)
                                {
                                  LgIndex Connection = 0;
                                  while (Connection < FaceNeighborConnections && PreplotIsOk)
                                    {
                                      const char *Message = "Invalid face neighbor tuple.";
                                      LgIndex NeighborZone = -1;
                                      LgIndex IValue;

                                      /* cz */
                                      Boolean_t IsOk = (PreplotIsOk && CurToken == ValueToken);
                                      if (IsOk)
                                        {
                                          if (ZoneIsEnabled)
                                            WriteI(BlckFile,ROUND2(CurTValue)-1); /* as of version 103 binary cell and zone values are zero based */

                                          GetToken(FALSE,TRUE,InFile);
                                        }
                                      /* fz */
                                      IsOk = IsOk && (PreplotIsOk && CurToken == ValueToken);
                                      if (IsOk)
                                        {
                                          if (ZoneIsEnabled)
                                            WriteI(BlckFile,ROUND2(CurTValue)-1); /* as of version 103 binary cell and zone values are zero based */

                                          GetToken(FALSE,TRUE,InFile);
                                        }
                                      /*
                                       * LOCALONETOONE:   cz
                                       * LOCALONETOMANY:  oz
                                       * GLOBALONETOONE:  ZZ
                                       * GLOBALONETOMANY: oz
                                       */
                                      IsOk = IsOk && (PreplotIsOk && CurToken == ValueToken);
                                      IValue = ROUND2(CurTValue);
                                      if (FaceNeighborMode == LOCALONETOONE || FaceNeighborMode == GLOBALONETOONE)
                                        IValue--; /* as of version 103 binary cell and zone values are zero based */

                                      if (IsOk && FaceNeighborMode == GLOBALONETOONE)
                                        {
                                          NeighborZone = IValue;
                                          if (NeighborZone == CurZone)
                                            {
                                              IsOk = FALSE;
                                              Message =
                                                  "The current zone for a user defined face "
                                                  "neighbor must be identified by a 0 and not "
                                                  "the current zone number.";
                                            }
                                        }

                                      if (IsOk)
                                        {
                                          if (ZoneIsEnabled)
                                            WriteI(BlckFile,IValue);

                                          GetToken(FALSE,TRUE,InFile);
                                        }

                                      if (FaceNeighborMode != LOCALONETOONE && IsOk)
                                        {
                                          LgIndex IValue = ROUND2(CurTValue);
                                          /*
                                           * LOCALONETOMANY:  nz
                                           * GLOBALONETOONE:  CZ
                                           * GLOBALONETOMANY: nz
                                           */
                                          IsOk = IsOk && (PreplotIsOk && CurToken == ValueToken);
                                          if (FaceNeighborMode == GLOBALONETOONE)
                                            IValue--; /* as of version 103 binary cell and zone values are zero based */
                                          if (IsOk && FaceNeighborMode == GLOBALONETOONE)
                                            {
                                              LgIndex NeighborElement = IValue;
                                              if (NeighborElement == -1 && NeighborZone != -1)
                                                {
                                                  IsOk = FALSE;
                                                  Message =
                                                      "If the element's face neighbor is defined "
                                                      "as a boundary then the zone must be 0.";
                                                }
                                            }

                                          if (IsOk)
                                            {
                                              if (ZoneIsEnabled)
                                                WriteI(BlckFile,IValue);

                                              GetToken(FALSE,TRUE,InFile);

                                            }

                                          if (FaceNeighborMode != GLOBALONETOONE && IsOk)
                                            {
                                              LgIndex Assoc;
                                              LgIndex NumAssociations = IValue;
                                              if (FaceNeighborMode == LOCALONETOMANY)
                                                for (Assoc = 0;
                                                     Assoc < NumAssociations && IsOk && PreplotIsOk;
                                                     Assoc++)
                                                  {
                                                    /* czn */
                                                    IsOk = IsOk && (PreplotIsOk && CurToken == ValueToken);
                                                    if (IsOk)
                                                      {
                                                        if (ZoneIsEnabled)
                                                          WriteI(BlckFile,ROUND2(CurTValue)-1); /* as of version 103 binary cell and zone values are zero based */

                                                        GetToken(FALSE,TRUE,InFile);
                                                      }
                                                  }
                                              else if (FaceNeighborMode == GLOBALONETOMANY)
                                                for (Assoc = 0;
                                                     Assoc < NumAssociations && IsOk && PreplotIsOk;
                                                     Assoc++)
                                                  {
                                                    /* ZZn */
                                                    LgIndex IValue = ROUND2(CurTValue)-1; /* as of version 103 binary cell and zone values are zero based */
                                                    IsOk = IsOk && (PreplotIsOk && CurToken == ValueToken);
                                                    NeighborZone = IValue;
                                                    if (IsOk && NeighborZone == CurZone)
                                                      {
                                                        IsOk = FALSE;
                                                        Message =
                                                            "The current zone for a user defined face "
                                                            "neighbor must be identified by a 0 and not "
                                                            "the current zone number.";
                                                      }

                                                    if (IsOk)
                                                      {
                                                        if (ZoneIsEnabled)
                                                          WriteI(BlckFile,IValue);

                                                        GetToken(FALSE,TRUE,InFile);
                                                      }
                                                    /* CZn */
                                                    IValue = ROUND2(CurTValue)-1; /* as of version 103 binary cell and zone values are zero based */
                                                    IsOk = IsOk && (PreplotIsOk && CurToken == ValueToken);
                                                    if (IsOk)
                                                      {
                                                        LgIndex NeighborElement = IValue;
                                                        if (NeighborElement == -1 && NeighborZone != -1)
                                                          {
                                                            IsOk = FALSE;
                                                            Message =
                                                                "If the element's face neighbor is defined "
                                                                "as a boundary then the zone must be 0.";
                                                          }
                                                      }
                                                    if (IsOk)
                                                      {
                                                        if (ZoneIsEnabled)
                                                          WriteI(BlckFile,IValue);

                                                        GetToken(FALSE,TRUE,InFile);
                                                      }
                                                  }
                                              else
                                                CHECK(FALSE);

                                              if (IsOk)
                                                Connection += NumAssociations;
                                            }
                                          else if (IsOk) /* FaceNeighborMode == GLOBALONETOONE */
                                            Connection += 1;
                                        }
                                      else if (IsOk) /* FaceNeighborMode == LOCALONETOONE */
                                        Connection += 1;

                                      if (!IsOk)
                                        ErrorMessage(Message, TRUE);
                                    }
                                }
                            }

                          if (PreplotIsOk && ZoneIsEnabled)
                            {
                              LgIndex Var;
                              Boolean_t AnyVarIsCellCentered;
#if !defined TECPLOTKERNEL
                              printf("\n");
#endif

                              /*Write out zone header information*/
                              DumpString(ZoneName[CurZone]);
                              WriteI(PlotFile,ParentZone[CurZone]);
                              WriteI(PlotFile,StrandID[CurZone]);
                              WriteR(PlotFile,SolutionTime[CurZone],FieldDataType_Double);
                              WriteI(PlotFile,ZoneColor);
                              WriteI(PlotFile,ZoneType[CurZone]);
                              WriteI(PlotFile,DataPacking[CurZone]);

                              for (Var = 0, AnyVarIsCellCentered = FALSE;
                                   Var < NumVars && !AnyVarIsCellCentered;
                                   Var++)
                                {
                                  AnyVarIsCellCentered = VarIsCellCentered[Var];
                                }
                              WriteI(PlotFile, (AnyVarIsCellCentered ? 1 : 0));

                              for (Var = 0;
                                   Var < NumVars && AnyVarIsCellCentered && PreplotIsOk;
                                   Var++)
                                {
                                  WriteI(PlotFile,(VarIsCellCentered[Var] ? 1 : 0));
                                }

                              /*
                               * As of binary version 108 Tecplot introduced
                               * the ability to output its auto-generated face
                               * neighbor array in its raw form. For now
                               * preplot will always decline to perform this
                               * step and instead fall back to the delivering
                               * one neighbor at a time.
                               */
                              CHECK(!WriteRawFaceNeighborArray);
                              if (ZoneType[CurZone] != ORDERED && ZoneType[CurZone] != FELINESEG)
                                WriteI(PlotFile, WriteRawFaceNeighborArray);
                              else
                                WriteI(PlotFile, FALSE);

                              WriteI(PlotFile, FaceNeighborConnections);
                              if (FaceNeighborConnections != 0)
                                {
                                  if (PreplotIsOk)
                                    WriteI(PlotFile, (LgIndex)FaceNeighborMode);
                                  if (ZoneType[CurZone] != ORDERED && PreplotIsOk)
                                    WriteI(PlotFile, (LgIndex)FEFaceNeighborsComplete);
                                }

                              if ((IMax[CurZone] != 0) || (JMax[CurZone] != 0) || (KMax[CurZone] != 0))
                                {
                                  if (ZoneType[CurZone] != ORDERED)
                                    {
                                      KMax[CurZone] = L; /* points per element */
                                    }
                                  else
                                    {
                                      IMax[CurZone] = 1+(IEnd[CurZone]-IStart[CurZone])/ISkip[CurZone];
                                      if (((IEnd[CurZone]-IStart[CurZone]) % ISkip[CurZone]) != 0)
                                        IMax[CurZone]++;
                                      JMax[CurZone] = 1+(JEnd[CurZone]-JStart[CurZone])/JSkip[CurZone];
                                      if (((JEnd[CurZone]-JStart[CurZone]) % JSkip[CurZone]) != 0)
                                        JMax[CurZone]++;
                                      KMax[CurZone] = 1+(KEnd[CurZone]-KStart[CurZone])/KSkip[CurZone];
                                      if (((KEnd[CurZone]-KStart[CurZone]) % KSkip[CurZone]) != 0)
                                        KMax[CurZone]++;
                                    }
                                }
                              if (Echo)
                                printf("Actual Dimension Used %d %d %d\n",
                                       IMax[CurZone],JMax[CurZone],KMax[CurZone]);
                              WriteI(PlotFile,IMax[CurZone]);
                              WriteI(PlotFile,JMax[CurZone]);
                              if (ZoneType[CurZone] != ORDERED)
                                {
                                  WriteI(PlotFile,ICellDim);
                                  WriteI(PlotFile,JCellDim);
                                  WriteI(PlotFile,KCellDim);
                                }
                              else
                                {
                                  WriteI(PlotFile,KMax[CurZone]);
                                }
                            }

                          if (PreplotIsOk && ZoneIsEnabled)
                            DumpAuxDataItemList(ZoneAuxDataListItemHead);
                          CleanupAuxDataList(&ZoneAuxDataListItemHead);
                        }
                      if (StopAfterLastZone && (LastZone != -1) && (CurZone >= LastZone))
                        CurToken = EndofFileToken;

                      CurZone++;
                    }
                  else if (CurToken == GEOMETRYToken)
                    {
                      double  CSScaleFact = 1.0;
                      LgIndex NumSegments;
                      LgIndex NumPtsSeg1;
                      Boolean_t IsOldWindow = (CoordSys == OLDWINDOW);
                      double  T1,T2;

#if !defined TECPLOTKERNEL
                      printf("Geometry\n");
#endif
                      RecogGeometryHeader();

/*
 * Pre-Read start of geometry to see if it is violating
 * FRAME coordinate system rules.
 */
                      if (((GeomType == RECTANGLE) ||
                           (GeomType == ELLIPSE)))
                        {
                          CheckIfValue();
                          T1 = CurTValue;
                          GetToken(FALSE,TRUE,InFile);
                          CheckIfValue();
                          T2 = CurTValue;
                          GetToken(FALSE,TRUE,InFile);
                          if (PreplotIsOk && (CoordSys == UNDEF))
                            {
                              if ((ABS(T1) < 1.0) && (ABS(T2) < 1.0))
                                IsOldWindow = TRUE;
                            }
                        }
                      else if ((GeomType == CIRCLE) ||
                               (GeomType == SQUARE))
                        {
                          CheckIfValue();
                          T1 = CurTValue;
                          GetToken(FALSE,TRUE,InFile);
                          if (PreplotIsOk && (CoordSys == UNDEF))
                            {
                              if (ABS(T1) < 1.0)
                                IsOldWindow = TRUE;
                            }
                        }
                      else if ((GeomType == LINE) ||
                               (GeomType == LINE3D))
                        {
                          if (PreplotIsOk &&
                              (CurToken == ValueToken) &&
                              (CurTValue < 32000.0))
                            {
                              if (CurTValue < 1.0)
                                ErrorMessage("Geometry has invalid number of polylines.",TRUE);
                              else if (CurTValue > MaxGeomSegments)
                                ErrorMessage("Geometry has too many polylines.\nUse separate geometries for each polyline.",TRUE);
                              if (PreplotIsOk)
                                NumSegments = (LgIndex)CurTValue;
                            }
                          else
                            ErrorMessage("Bad value for Number of Polylines in Geometry",TRUE);

                          GetToken(FALSE,TRUE,InFile);

                          if (PreplotIsOk &&
                              ((CurTValue < 1.0) ||
                               (CurTValue > MaxGeometryPts)))
                            ErrorMessage("Geometry segment has invalid number of points",TRUE);
                          else if (PreplotIsOk)
                            NumPtsSeg1 = AssignLgIndex(CurTValue);

                          GetToken(FALSE,TRUE,InFile);

                          /* to determine if we are using the old version 6 */
                          /* window mode (i.e. fractional values indicating */
                          /* a percentage of the window) we only test the   */
                          /* first point of the block data --not very good, */
                          /* but hey, its old!                              */
                          if (PreplotIsOk && (CoordSys == UNDEF) &&
                              (ABS(CurTValue) < 1.0) && (CurTValue != 0.0))
                            {
                              IsOldWindow = TRUE;
                            }
                        }

                      if (PreplotIsOk)
                        {
                          if (CoordSys == UNDEF)
                            {
                              if (IsOldWindow &&
                                  ((XX > 0.0) && (XX < 1.0)) &&
                                  ((YY > 0.0) && (YY < 1.0)))
                                {
                                  WarnMsg("Geometry appears to use old WINDOW coordinates of 0-1", FALSE);
                                }
                              else
                                CSScaleFact = 0.01;
                              CoordSys = FRAME;
                            }
                          else if (CoordSys == OLDWINDOW)
                            {
                              CoordSys = FRAME;
                            }
                          else if (CoordSys == FRAME)
                            {
                              CSScaleFact = 0.01;
                            }
                        }

                      if (PreplotIsOk &&
                          (CoordSys == FRAME) &&
                          ((XX*CSScaleFact < 0.0) || (XX*CSScaleFact > 1.0) ||
                           (YY*CSScaleFact < 0.0) || (YY*CSScaleFact > 1.0)))
                        ErrorMessage("Frame coordinate Geometry is anchored outside of frame", TRUE);

                      WriteR(PlotFile,GEOMMARKER,FieldDataType_Float);
                      WriteI(PlotFile,(LgIndex)CoordSys);
                      WriteI(PlotFile,(LgIndex)Scope);
                      WriteI(PlotFile,(LgIndex)DrawOrder);
                      WriteR(PlotFile,CSScaleFact*XX,FieldDataType_Double);
                      WriteR(PlotFile,CSScaleFact*YY,FieldDataType_Double);
                      WriteR(PlotFile,ZZ,FieldDataType_Double);
                      WriteI(PlotFile,TGZone);
                      WriteI(PlotFile,Color);
                      WriteI(PlotFile,FillColor);
                      WriteI(PlotFile,IsFilled);
                      WriteI(PlotFile,(LgIndex)GeomType);
                      WriteI(PlotFile,(LgIndex)LinePattern);
                      WriteR(PlotFile,0.01*PatternLength,FieldDataType_Double);
                      WriteR(PlotFile,0.01*LineThickness,FieldDataType_Double);
                      WriteI(PlotFile,NumEllipsePts);
                      WriteI(PlotFile,(LgIndex)ArrowheadStyle);
                      WriteI(PlotFile,(LgIndex)ArrowheadAttachment);
                      WriteR(PlotFile,0.01*ArrowheadSize,FieldDataType_Double);
                      WriteR(PlotFile,ArrowheadAngle/DEGPERRADIANS,FieldDataType_Double);
                      DumpString(MacroString);
                      MacroString[0] = '\0';
                      WriteI(PlotFile,(LgIndex)GeomDataType);
                      WriteI(PlotFile,(LgIndex)GeomClipping);

                      if ((GeomType == RECTANGLE) ||
                          (GeomType == ELLIPSE))
                        {
                          WriteR(PlotFile,CSScaleFact*T1,GeomDataType);
                          WriteR(PlotFile,CSScaleFact*T2,GeomDataType);
                        }
                      else if ((GeomType == CIRCLE) ||
                               (GeomType == SQUARE))
                        {
                          WriteR(PlotFile,CSScaleFact*T1,GeomDataType);
                        }
                      else if (PreplotIsOk && GeomType == LINE)
                        {
                          if (Echo && PreplotIsOk)
                            printf("NumSegments = %d\n",NumSegments);

                          if (PreplotIsOk)
                            WriteI(PlotFile,NumSegments);

                          for (I = 0; (I < NumSegments) && PreplotIsOk; I++)
                            {
                              if (I > 0)
                                {
                                  if ((CurTValue < 1.0) ||
                                      (CurTValue > MaxGeometryPts))
                                    ErrorMessage("Geometry segment has invalid number of points",TRUE);
                                  if (PreplotIsOk)
                                    Index = AssignLgIndex(CurTValue);
                                }
                              else
                                Index = NumPtsSeg1;

                              if (Echo)
                                printf("NumPts = %d\n",Index);

                              WriteI(PlotFile,Index);
                              if (I > 0)
                                GetToken(FALSE,TRUE,InFile);
                              if (PreplotIsOk && GeomDataPacking == BLOCKPACKING)
                                {
                                  if (Echo)
                                    printf("Reading X\n");
                                  GetBlock(PlotFile,TRUE,
                                                    (LgIndex)1,
                                                    Index,
                                                    (LgIndex)1,
                                                    Index,
                                                    (LgIndex)1,
                                                    (LgIndex)1,
                                                    (LgIndex)1,
                                                    (LgIndex)1,
                                                    (LgIndex)1,
                                                    (LgIndex)1,
                                                    (LgIndex)1,
                                                    (LgIndex)1,
                                                    (LgIndex)-1,
                                                    GeomDataType,
                                                    FALSE,
                                                    CSScaleFact,
                                                    NULL, NULL);
                                  if (Echo)
                                    printf("Reading Y\n");
                                  GetBlock(PlotFile,TRUE,
                                                    (LgIndex)1,
                                                    Index,
                                                    (LgIndex)1,
                                                    Index,
                                                    (LgIndex)1,
                                                    (LgIndex)1,
                                                    (LgIndex)1,
                                                    (LgIndex)1,
                                                    (LgIndex)1,
                                                    (LgIndex)1,
                                                    (LgIndex)1,
                                                    (LgIndex)1,
                                                    (LgIndex)-1,
                                                    GeomDataType,
                                                    FALSE,
                                                    CSScaleFact,
                                                    NULL, NULL);
                                  if (GeomType == LINE &&
                                      CoordSys == GRID3D)
                                    {
                                      if (Echo)
                                        printf("Reading Z\n");
                                      GetBlock(PlotFile,TRUE,
                                                        (LgIndex)1,
                                                        Index,
                                                        (LgIndex)1,
                                                        Index,
                                                        (LgIndex)1,
                                                        (LgIndex)1,
                                                        (LgIndex)1,
                                                        (LgIndex)1,
                                                        (LgIndex)1,
                                                        (LgIndex)1,
                                                        (LgIndex)1,
                                                        (LgIndex)1,
                                                        (LgIndex)-1,
                                                        GeomDataType,
                                                        FALSE,
                                                        CSScaleFact,
                                                        NULL, NULL);
                                    }
                                }
                              else
                                {
                                  L = 0;
                                  while ((L < Index) && PreplotIsOk)
                                    {
                                      L++;
                                      if (CurToken == ValueToken)
                                        {
                                          WriteR(PlotFile,CSScaleFact*CurTValue,GeomDataType);
                                          GetToken(FALSE,TRUE,InFile);
                                          if (PreplotIsOk && (CurToken == ValueToken))
                                            {
                                              YGeometryValues[L] = CurTValue;
                                              GetToken(FALSE,TRUE,InFile);
                                            }
                                          else
                                            ErrorMessage("Bad value for Y Geometry",TRUE);
                                          if (PreplotIsOk &&
                                              GeomType == LINE && CoordSys == GRID3D)
                                            {
                                              if (CurToken == ValueToken)
                                                {
                                                  ZGeometryValues[L] = CurTValue;
                                                  GetToken(FALSE,TRUE,InFile);
                                                }
                                              else
                                                ErrorMessage("Bad value for Z Geometry",TRUE);
                                            }
                                        }
                                      else
                                        ErrorMessage("Bad value for X in Geometry",TRUE);
                                    }
                                  if (PreplotIsOk)
                                    {
                                      for (L = 1; L <= Index; L++)
                                        WriteR(PlotFile,CSScaleFact*YGeometryValues[L],
                                                        GeomDataType);
                                      if (GeomType == LINE && CoordSys == GRID3D)
                                        for (L = 1; L <= Index; L++)
                                          WriteR(PlotFile,CSScaleFact*ZGeometryValues[L],
                                                          GeomDataType);
                                    }
                                }
                            }
                        }
                    }
                  else if (CurToken == TEXTToken)
                    {
                      RecogTextHeader();
                      if (PreplotIsOk)
                        {
                          double ScaleFact;
#if !defined TECPLOTKERNEL
                          printf("Text\n");
#endif
                          WriteR(PlotFile,TEXTMARKER,FieldDataType_Float);
                          if ((CoordSys == UNDEF) || (CoordSys == OLDWINDOW))
                            WriteI(PlotFile,(LgIndex)FRAME);
                          else
                            WriteI(PlotFile,(LgIndex)CoordSys);
                          WriteI(PlotFile,(LgIndex)Scope);
                          if ((CoordSys == OLDWINDOW)   ||
                              (CoordSys == GRID)        ||
                              (CoordSys == GRID3D)      ||
                              (CoordSys == FRAMEOFFSET))
                            ScaleFact = 1.0;
                          else if (CoordSys == FRAME)
                            ScaleFact = 0.01;
                          else
                            {
                              if ((XX > 0.0) && (XX < 1.0) &&
                                  (YY > 0.0) && (YY < 1.0))
                                {
                                  WarnMsg("TEXT appears to use old WINDOW coordinates of 0-1", FALSE);
                                  ScaleFact = 1.0;
                                }
                              else
                                ScaleFact = 0.01;
                            }
                          if (PreplotIsOk &&
                              (CoordSys == FRAME) &&
                              ((XX*ScaleFact > 1.0) ||
                               (YY*ScaleFact > 1.0)))
                            WarnMsg("Frame coordinate Text appears to be anchored outside of frame", FALSE);

                          WriteR(PlotFile,XX*ScaleFact,FieldDataType_Double);
                          WriteR(PlotFile,YY*ScaleFact,FieldDataType_Double);
                          WriteR(PlotFile,ZZ,FieldDataType_Double);
                          WriteI(PlotFile,(LgIndex)FontType);
                          WriteI(PlotFile,(LgIndex)HeightUnits);
                          if (PreplotIsOk && (HeightUnits == Units_Frame))
                            {
                              /* Old data files in "window units" have height in "window units" */
                              if (CoordSys == OLDWINDOW)
                                WriteR(PlotFile, Height,FieldDataType_Double);
                              else
                                WriteR(PlotFile,0.01*Height,FieldDataType_Double);
                            }
                          else
                            WriteR(PlotFile,Height,FieldDataType_Double);
                          WriteI(PlotFile,BoxType);
                          WriteR(PlotFile,0.01*BoxMargin,FieldDataType_Double);
                          WriteR(PlotFile,0.01*LineThickness,FieldDataType_Double);
                          WriteI(PlotFile,BoxOutlineColor);
                          WriteI(PlotFile,BoxFillColor);
                          WriteR(PlotFile,Angle/DEGPERRADIANS,FieldDataType_Double);
                          WriteR(PlotFile,LineSpacing,FieldDataType_Double);
                          WriteI(PlotFile,(LgIndex)TextAnchor);
                          WriteI(PlotFile,TGZone);
                          WriteI(PlotFile,Color);
                          DumpString(MacroString);
                          MacroString[0] = '\0';
                          WriteI(PlotFile,(LgIndex)TextClipping);
                          DumpString(TextString);
                        }
                    }
                  else if (CurToken == CUSTOMLABELToken)
                    {
                      RecogCustomLabelHeader();
#if !defined TECPLOTKERNEL
                      printf("Customlabel set\n");
#endif
                      WriteR(PlotFile,CUSTOMLABELMARKER,FieldDataType_Float);
                      WriteI(PlotFile,(LgIndex)NumCustomLabels);
                      for (I = 0; I < NumCustomLabels; I++)
                        DumpString(CustomLabel[I]);
                    }
                  else if (CurToken == USERRECToken)
                    {
                      RecogUserRecHeader();
#if !defined TECPLOTKERNEL
                      printf("UserRec\n");
#endif
                      WriteR(PlotFile,USERRECMARKER,FieldDataType_Float);
                      DumpString(UserRecString);
                      FREE_ARRAY(UserRecString,"user rec");
                      UserRecString = NULL;
                    }
                  else if (CurToken == DATASETAUXDATAToken)
                    {
                      AuxDataListItem_s *DataSetAuxDataListItem = NULL;
                      GetAuxData("DATASETAUXDATA", &DataSetAuxDataListItem, NULL, NULL);
                      if (PreplotIsOk)
                        {
                          WriteR(PlotFile,DATASETAUXDATAMARKER,FieldDataType_Float);
                          DumpAuxDataItem(DataSetAuxDataListItem);

                          /*
                           * Unlike some of the other GetXxxx functions the
                           * next token is scaned for here instead of inside
                           * the GetXxxx function. The reason is that
                           * GetAuxData is also used for zone header parsing
                           * which expects to advance to the next token outside
                           * of the function.
                           */
                          GetToken(FALSE,TRUE,InFile);
                        }
                      CleanupAuxDataList(&DataSetAuxDataListItem);
                    }
                  else if (CurToken == VARAUXDATAToken)
                    {
                      /* scan for variable index, e.g. VARAUXDATA 5 */
                      LgIndex VarIndex = -1;
                      GetToken(FALSE,TRUE,InFile);
                      CheckIfValue();
                      if (PreplotIsOk)
                        VarIndex = AssignLgIndex(CurTValue);
                      if (PreplotIsOk && (VarIndex < 1 || NumVars < VarIndex))
                        ErrorMessage("VARAUXDATA variable index is not a valid variable.", TRUE);

                      /* now scan for the actual name/value pair */
                      if (PreplotIsOk)
                        {
                          AuxDataListItem_s *VarAuxDataListItem = NULL;
                          GetAuxData("VARAUXDATA", &VarAuxDataListItem, NULL, NULL);
                          if (PreplotIsOk)
                            {
                              WriteR(PlotFile,VARAUXDATAMARKER,FieldDataType_Float);
                              WriteI(PlotFile,VarIndex-1);
                              DumpAuxDataItem(VarAuxDataListItem);

                              /*
                               * Unlike some of the other GetXxxx functions the
                               * next token is scaned for here instead of inside
                               * the GetXxxx function. The reason is that
                               * GetAuxData is also used for zone header parsing
                               * which expects to advance to the next token outside
                               * of the function.
                               */
                              GetToken(FALSE,TRUE,InFile);
                            }
                          CleanupAuxDataList(&VarAuxDataListItem);
                        }
                    }
                  else
                    {
                      WarnMsg("Expecting Record Marker, Skipping current line...", FALSE);
                      if (GetNextLine(InFile))
                        {
                          LinePos = 0;
                          GetToken(FALSE,TRUE,InFile);
                        }
                      else
                        CurToken = EndofFileToken;
                    }
                } /* non plot3d while */
            } /* Else */
        }
    }

  if (PreplotIsOk)
    {
      short C;
      WriteR(PlotFile,EOHMARKER,FieldDataType_Float);

      if ( BlckFile )
#       if defined TECPLOTKERNEL
          Close_File(&BlckFile,FALSE);
#       else
          FCLOSE(BlckFile);
#       endif

#if defined TECPLOTKERNEL
      Open_File(&BlckFile,
                 BlckFName,
                 TRUE,  /* IsReading */
                 FALSE, /* IsAppending */
                 FALSE, /* ForceOpen */
                 FALSE, /* ShowErr */
                 FALSE); /* IsAscii */
#else
      BlckFile = FOPEN(BlckFName,"rb");
#endif /* TECPLOTKERNEL */

#if defined TECBUFSIZE
      setvbuf(BlckFile,(char *)NULL,_IOFBF,TECBUFSIZE);
#endif

#if defined TECPLOTKERNEL
      _Gr_CheckInterrupt(NULL,__FILE__,__LINE__);
      if (Interrupted && !(IsInterfaceSuspended() || InBatchMode))
        PreplotIsOk = FALSE;
#endif

      while (PreplotIsOk &&
             (C = getc(BlckFile)) != EOF)
        {
          if (fputc(C,PlotFile) == EOF)
            {
              DiskIOError();
              break;
            }

#if defined TECPLOTKERNEL
          if (CheckTimeOut())
            {
              _Gr_CheckInterrupt(NULL,__FILE__,__LINE__);
              if (Interrupted && !(IsInterfaceSuspended() || InBatchMode))
                PreplotIsOk = FALSE;
            }
#endif
        }
      if ( PlotFile )
        {
          if ( PlotFile != stdin )
#           if defined TECPLOTKERNEL
              Close_File(&PlotFile,FALSE);
#           else
              FCLOSE(PlotFile);
#           endif
          PlotFile = NULL;
        }
    }

  if ( InFile )
    {
      if ( InFile != stdin )
#       if defined TECPLOTKERNEL
          Close_File(&InFile,FALSE);
#       else
          FCLOSE(InFile);
#       endif
      InFile = NULL;
    }
  CleanUp(PreplotIsOk);

#if !defined TECPLOTKERNEL
  if (NumWarns > 0)
    printf("\nWarnings issued: %d\n",NumWarns);

#if defined PLOT3D
  if (Plot3DBadBlockCount)
    printf("\nMarker Blocks encountered = %d\n\n",Plot3DBadBlockCount);
#endif
#endif


# if defined TECPLOTKERNEL
    {
      if (Interrupted && EString != NULL)
        {
          const char *Message = "Conversion interrupted.";
          *EString = ALLOC_ARRAY(strlen(Message)+1,char,"Error string");
          if (*EString != NULL)
            strcpy(*EString, Message);
        }
      else if (!PreplotIsOk && EString != NULL)
        {
          *EString = ALLOC_ARRAY(strlen(ErrString)+1,char,"Error string");
          if (*EString != NULL)
            strcpy(*EString,ErrString);
        }
    }
# else
    {
      if (!PreplotIsOk && EString != NULL)
        {
          *EString = ALLOC_ARRAY(strlen(ErrString)+1,char,"Error string");
          if (*EString != NULL)
            strcpy(*EString,ErrString);
        }
    }
# endif

  return (PreplotIsOk);
}



#if !defined TECPLOTKERNEL
int main (int argc,
          char *argv[])
{
  int return_value;
  if ( Preplot(argc,argv,(char **)NULL) )
    return_value = 0;
  else
    return_value = -1;

#if defined MSWIN && defined _DEBUG
  scanf("%*c");
#endif

  return return_value;
}
#endif

/* Tecplot binary data file format now documented at the top of this file. */
