#include "importSzPltFile.h"
#include "ThirdPartyHeadersBegin.h"
#  include <cctype>
#  include <cfloat>
#  include <locale>
#  include <string>
#  include <boost/assign.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "MASTER.h"
#include "GLOBAL.h"
#include "CszConnectivity.h"
#include "FECellSubzoneCompressor.h"
#include "FEZoneInfo.h"
#include "fileStuff.h"
#include "FileReaderInterface.h"
#include "gatherOffsets.h"
#include "IJK.h"
#include "IJKPartitionTree.h"
#include "IJKZoneInfo.h"
#include "PartitionMetadata.h"
#include "Scanner.h"
#include "readValueArray.h"
#include "xyz.h"
#include "ZoneMetadata.h"
#include "ZoneVarMetadata.h"
#include "zoneUtil.h"
namespace tecplot { namespace ___3931 { ___372 readDataFileHeader( ___1397& file, ___1386&     ___1385, uint64_t&            byteOrderIndicator, uint64_t&            dataSetHeaderLocation) { ___372 ___2037 = ___4224; char textOrBinary = '\0'; if (!file.___3458()) ___2037 = ___1184("Can't read SZPLT file."); tecplot::___3439 headerScanner; size_t const headerBufferSize = 128; char headerBuffer[headerBufferSize]; if (___2037 && !(file.fgets(headerBuffer, headerBufferSize) != NULL && headerBuffer[strlen(headerBuffer)-1] == '\n')) ___2037 = ___1184("SZPLT file has incorrect header. Cannot parse file header info."); uint32_t  fileVersion = 0; if (___2037) { headerScanner.reset(headerBuffer); char const* const fileTypeID = "#!" SZPLT_FILE_TYPE; if (___2037 && !(headerScanner.next(strlen(fileTypeID)) == fileTypeID && headerScanner.next(1) == " ")) ___2037 = ___1184("SZPLT file has incorrect header. File type is not correct."); if (___2037 && !headerScanner.hasNextInt64Token("BT")) ___2037 = ___1184("SZPLT file has incorrect header. Version format is not correct."); if (___2037) fileVersion = static_cast<uint32_t>(headerScanner.nextInt64Token("BT")); if (___2037 && fileVersion < SZPLT_MIN_READ_VERSION) ___2037 = ___1184("SZPLT file is an older version %" PRIu32 " that is no longer supported.", fileVersion); if (___2037 && fileVersion > SZPLT_MAX_READ_VERSION ) ___2037 = ___1184("SZPLT file is an newer version %" PRIu32 " that is not supported by the current loader. Try updating your Tecplot.", fileVersion); if (___2037 && !headerScanner.hasNextChar()) ___2037 = ___1184("SZPLT file has incorrect header. Missing text or binary designator."); if (___2037) textOrBinary = headerScanner.nextChar(); if (___2037 && textOrBinary != 'B' && textOrBinary != 'T') ___2037 = ___1184("SZPLT file has incorrect header. Cannot determine binary or text file type."); } ___372 ___2000 = ___1303; DataFileType_e ___842 = ___845; if (___2037) { ___2000 = textOrBinary == 'T'; ___842 = ___843; if (fileVersion >= 105) { char dataFileTypeChar = '\0'; ___2037 = headerScanner.hasNextChar(); if (___2037) dataFileTypeChar = headerScanner.nextChar(); if (___2037) { if (dataFileTypeChar == 'F') ___842 = ___843; else if (dataFileTypeChar == 'G') ___842 = ___844; else if (dataFileTypeChar == 'S') ___842 = ___846; else ___2037 = ___1184("SZPLT file has incorrect header. Expected data file type identifier."); } else { ___2037 = ___1184("SZPLT file has incorrect header. Expected data file type identifier."); } } } uint32_t codeRevision = 0; if (___2037 && headerScanner.hasNextToken() && headerScanner.nextToken() == " $Revision: " && headerScanner.hasNextInt64Token()) codeRevision = static_cast<uint32_t>(headerScanner.nextInt64Token()); else codeRevision = 0; if (___2037) { file.___3492(___2000); file.setDataFileType(___842); ___1385.setFileVersion(fileVersion); ___1385.___3492(___2000);
___1385.setDataFileType(___842); ___1385.setCodeRevision(codeRevision); } byteOrderIndicator = 0; ___2037 = ___2037 && readValue<uint64_t, true>(file, byteOrderIndicator, IODescription(___1384)); ___476(IMPLICATION(___2037, byteOrderIndicator == ___1383)); dataSetHeaderLocation = 0; ___2037 = ___2037 && readValue<uint64_t, true>(file, dataSetHeaderLocation, IODescription(___893)); ___476(IMPLICATION(___2037, dataSetHeaderLocation != 0)); return ___2037; } namespace { ___372 readTagList( ___1397& file, ___3940&   tagDescriptionMap, ___3943&         ___3942) { uint16_t numTags; ___372 ___2037 = readValue<uint16_t, false>(file, numTags, IODescription(___2837)); UInt16Array tagArray; size_t arraySize = static_cast<size_t>(numTags); ___2037 = ___2037 && tagArray.alloc(arraySize); ___2037 = ___2037 && readValueArray<uint16_t, false, 0>(file, 0, arraySize, tagArray, IODescription(___3941)); try { for(size_t i = 0; ___2037 && i < arraySize; ++i) { uint16_t tag = tagArray[i]; ___3940::const_iterator it = tagDescriptionMap.find(tag); if (it == tagDescriptionMap.end()) { ___2037 = ___1929("Unrecognized tag while reading file header: %d. Attempting to continue...", tag); if (___2037) { if (file.___2000()) { int c = file.getc(); while(!file.feof() && c != '\n') c = file.getc(); if (file.feof()) ___2037 = ___1184("End-of-file encountered attempting to skip unrecognized tag."); } else { uint64_t unused; if (file.fread(&unused, sizeof(unused), size_t(1)) != 1) ___2037 = ___1184("Read error while attempting to skip unrecognized tag."); } } } else { ___2037 = ___2037 && readValue<uint64_t, true>(file, ___3942[tag], IODescription(tagDescriptionMap[tag].c_str())); } } } catch(...) { ___2037 = ___1184("Error while reading file tags, possibly out of memory."); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { ___372 ensureRequiredHeaderTagValuesArePresent( const char* headerTypeString, ___3943 const& ___3942, ___3940& tagDescriptionMap, std::vector<uint16_t> const& tagList) { for (std::vector<uint16_t>::const_iterator tag = tagList.begin(); tag != tagList.end(); ++tag) { ___3943::const_iterator it = ___3942.find(*tag); if (it == ___3942.end()) return ___1184("Missing required %s header tag %" PRIu64 ", '%s'.", headerTypeString, uint64_t(*tag), tagDescriptionMap[*tag].c_str()); } return ___4224; } } namespace { template <typename T> ___372 retrieveRequiredNonZeroValue(___3943 const& ___3942, uint16_t tag, char const* ___2683, T& ___4312) { ___372 ___2037 = ___4224; ___3943::const_iterator it = ___3942.find(tag); if (it == ___3942.end()) ___2037 = ___1184("Missing value for '%s' while reading file header.", ___2683); else ___4312 = static_cast<T>(it->second); if (___2037 && ___4312 == static_cast<T>(0)) ___2037 = ___1184("Invalid value (0) for '%s' while reading file header.", ___2683); ENSURE(VALID_BOOLEAN(___2037));
return ___2037; } } ___372 readDataSetHeaderTags( ___1397& file, ___1386&     ___1385, ___3943&         ___3942) { REQUIRE(file.___2039()); ___3940 tagDescriptionMap = DATSET_HEADER_TAG_DESCRIPTIONS_MAP_INITIALIZER; std::vector<uint16_t> tagList; tagList.reserve(tagDescriptionMap.size()); for (___3940::const_iterator it = tagDescriptionMap.begin(); it != tagDescriptionMap.end(); ++it) if (it->first != DATA_SET_TITLE_TAG && it->first != NUM_PARTITION_FILES_TAG) tagList.push_back(it->first); ___372 ___2037 = readTagList(file, tagDescriptionMap, ___3942); ___2037 = ___2037 && ensureRequiredHeaderTagValuesArePresent("file", ___3942, tagDescriptionMap, tagList); if (___2037) { ___81 subzoneMaxISize = 0; ___81 subzoneMaxJSize = 0; ___81 subzoneMaxKSize = 0; ___2088::ItemOffset_t subzoneMaxFESize = 0; if (retrieveRequiredNonZeroValue(___3942, SUBZONE_MAX_I_SIZE_TAG, SUBZONE_MAX_I_SIZE_DESCRIPTION, subzoneMaxISize) && retrieveRequiredNonZeroValue(___3942, SUBZONE_MAX_J_SIZE_TAG, SUBZONE_MAX_J_SIZE_DESCRIPTION, subzoneMaxJSize) && retrieveRequiredNonZeroValue(___3942, SUBZONE_MAX_K_SIZE_TAG, SUBZONE_MAX_K_SIZE_DESCRIPTION, subzoneMaxKSize) && retrieveRequiredNonZeroValue(___3942, SUBZONE_MAX_FE_SIZE_TAG, SUBZONE_MAX_FE_SIZE_DESCRIPTION, subzoneMaxFESize)) { ___1385.setMaxIJKSubzoneSize(___1842(subzoneMaxISize, subzoneMaxJSize, subzoneMaxKSize)); ___1385.setMaxFESubzoneSize(subzoneMaxFESize); } else { ___2037 = ___1303; } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } namespace { template <typename T> ___372 retrieveRequiredValue(___3943 const& ___3942, uint16_t tag, char const* ___2683, T& ___4312) { ___372 ___2037 = ___4224; ___3943::const_iterator it = ___3942.find(tag); if (it == ___3942.end()) ___2037 = ___1184("Missing value for '%s' while reading file header.", ___2683); else ___4312 = static_cast<T>(it->second); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } ___372 applyDataSetHeaderScalarTagValues( ___3943 const& ___3942, ___4350& ___2841, ___4634& ___2844) { ___372 ___2037 = retrieveRequiredValue(___3942, ___2843, NUM_VARS_DESCRIPTION, ___2841); ___2037 = ___2037 && retrieveRequiredValue(___3942, ___2847, NUM_ZONES_DESCRIPTION, ___2844); if (___2841 > MAX_NUM_VARS) ___2037 = ___1184("File exceeds SZL variable limit"); else if (___2844 > MAX_NUM_ZONES) ___2037 = ___1184("File exceeds SZL zone limit"); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 readDatasetTitle( ___1397& file, ___3943&         ___3942, std::string&         datasetTitle) { REQUIRE(file.___2039()); if (___3942.find(DATA_SET_TITLE_TAG) == ___3942.end()) return ___4224; ___372 ___2037 = file.___3457(___3942[DATA_SET_TITLE_TAG]); uint32_t titleLength = 0; ___2037 = ___2037 && readValue<uint32_t, false>(file, titleLength, IODescription(DATA_SET_TITLE_LENGTH)); if (___2037 && titleLength > 0) { try { ___471 ___4175;
___2037 = ___2037 && ___4175.alloc(titleLength); ___2037 = ___2037 && readString(file, titleLength, ___4175, IODescription(DATA_SET_TITLE_DESCRIPTION)); if ( ___2037 ) datasetTitle = std::string(&___4175[0], titleLength); } catch (std::bad_alloc const&) { ___2037 = ___1184("Out-of-memory error while reading dataset title."); } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 readPerVarFileHeader( ___1397& file, ___3943&         ___3942, ___4350           varOffset, ___3814&         varNameArray) { REQUIRE(file.___2039()); ___372 ___2037 = ___4224; try { size_t ___2841 = static_cast<size_t>(___3942[___2843]); if (___2841 == 0) return ___4224; REQUIRE(IMPLICATION(varNameArray.empty(), varOffset == 0)); REQUIRE(IMPLICATION(!varNameArray.empty(), varOffset+___2841 <= varNameArray.size())); uint64_t varNameLocation = ___3942[___4363]; if (varNameLocation == 0) { ___2037 = ___1184("Missing file header tag %" PRIu64 " '%s'.", uint64_t(___4363), VAR_NAME_FILE_LOC_DESCRIPTION); } else { ___2037 = file.___3457(varNameLocation); ___2037 = ___2037 && readStringArray(file, varOffset, ___2841, varNameArray, IODescription(___4362)); } } catch(std::bad_alloc const&) { ___2037 = ___1184("Out-of-memory error while reading file header."); } catch(...) { ___2037 = ___1184("Unrecoverable error while reading file header."); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } namespace { ___372 readZoneHeaderFileLocArray( ___1397& file, ___4634          zoneOffset, ___4634          ___2844, ___1390&        zoneFileLocArray) { REQUIRE(file.___2039()); REQUIRE(___2844>0); REQUIRE(IMPLICATION(zoneFileLocArray.empty(), zoneOffset == 0)); REQUIRE(IMPLICATION(!zoneFileLocArray.empty(), size_t(zoneOffset+___2844) <= zoneFileLocArray.size())); REQUIRE("file is at correct file loc"); ___372 ___2037 = readValueArray<uint64_t, true, 0>(file, zoneOffset, ___2844, zoneFileLocArray, IODescription(___4626)); if ( ___2037 ) { if ( zoneFileLocArray[zoneOffset] == ___1391(0) || zoneFileLocArray[zoneOffset] == ___330 || zoneFileLocArray[zoneOffset + ___2844/2] == ___1391(0) || zoneFileLocArray[zoneOffset + ___2844/2] == ___330 || zoneFileLocArray[zoneOffset + ___2844-1] == ___1391(0) || zoneFileLocArray[zoneOffset + ___2844-1] == ___330 ) { ___2037 = ___1184("This file has invalid zone file locations."); } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } ___372 readPerZoneFileHeader( ___1397&             file, ___3943&                     ___3942, ___4634                      zoneOffset, ___1390&                    ___4627, ___2238<ZoneMetadata>& zoneMetadata, ___2238<___4634>&  zoneShareConnectivityArray) { REQUIRE(file.___2039()); REQUIRE(IMPLICATION(___4627.empty(), zoneOffset == 0)); REQUIRE(IMPLICATION(!___4627.empty(), ___3942[___2847] <= ___4627.size()));
REQUIRE(IMPLICATION(zoneShareConnectivityArray.empty(), zoneOffset == 0)); REQUIRE(IMPLICATION(!zoneShareConnectivityArray.empty(), zoneOffset+___3942[___2847] <= zoneShareConnectivityArray.size())); REQUIRE(zoneMetadata.size() == ___3942[___2847]); ___372 ___2037 = ___4224; try { size_t const ___2844 = size_t(___3942[___2847]); if (___2844 == 0) return ___4224; if ( ___2037 && ___3942[___4628] == 0 ) ___2037 = ___1184("File does not contain zone header file locations."); ___2037 = ___2037 && file.___3457(___3942[___4628]); ___2037 = ___2037 && readZoneHeaderFileLocArray(file, 0, ___4634(___2844), ___4627); ___3814 zoneNameArray; ___471 zoneTypeArray; UInt8Array faceNeighborModeArray; ___1103 solutionTimeArray; UInt32Array strandIDArray; ___1963 parentZoneArray; UInt64Array iMaxOrNumNodesArray; UInt64Array jMaxOrNumCellsArray; UInt64Array kMaxOrNumCornersArray; static ___3940 tagDescriptionMap = DATSET_HEADER_TAG_DESCRIPTIONS_MAP_INITIALIZER; static std::vector<uint16_t> const tagList = boost::assign::list_of (___4649) (ZONE_TYPE_FILE_LOC_TAG) (___4608) (___4674) (___4684) (___4668) (ZONE_IMAX_OR_NUM_NODES_FILE_LOC_TAG) (ZONE_JMAX_OR_NUM_CELLS_FILE_LOC_TAG) (ZONE_KMAX_OR_NUM_CORNERS_FILE_LOC_TAG) (___4672); ___2037 = ___2037 && ensureRequiredHeaderTagValuesArePresent("file", ___3942, tagDescriptionMap, tagList); ___2037 = ___2037 && zoneNameArray.alloc(___2844) && file.___3457(___3942[___4649]) && readStringArray(file, 0, ___2844, zoneNameArray, IODescription(___4648)) && zoneTypeArray.alloc(___2844) && file.___3457(___3942[ZONE_TYPE_FILE_LOC_TAG]) && readValueArray<char, false, 0>(file, 0, ___2844, zoneTypeArray, IODescription(___4692)) && faceNeighborModeArray.alloc(___2844) && file.___3457(___3942[___4608]) && readValueArray<uint8_t, false, 0>(file, 0, ___2844, faceNeighborModeArray, IODescription(___4607)) && solutionTimeArray.alloc(___2844) && file.___3457(___3942[___4674]) && readValueArray<double, false, 0>(file, 0, ___2844, solutionTimeArray, IODescription(___4673)) && strandIDArray.alloc(___2844) && file.___3457(___3942[___4684]) && readValueArray<uint32_t, false, 0>(file, 0, ___2844, strandIDArray, IODescription(___4683)) && parentZoneArray.alloc(___2844) && file.___3457(___3942[___4668]) && readValueArray<int32_t, false, 0>(file, 0, ___2844, parentZoneArray, IODescription(___4667)) && iMaxOrNumNodesArray.alloc(___2844) && file.___3457(___3942[ZONE_IMAX_OR_NUM_NODES_FILE_LOC_TAG]) &&
readValueArray<uint64_t, false, 0>(file, 0, ___2844, iMaxOrNumNodesArray, IODescription(ZONE_IMAX_OR_NUM_NODES_ARRAY_DESCRIPTION)) && jMaxOrNumCellsArray.alloc(___2844) && file.___3457(___3942[ZONE_JMAX_OR_NUM_CELLS_FILE_LOC_TAG]) && readValueArray<uint64_t, false, 0>(file, 0, ___2844, jMaxOrNumCellsArray, IODescription(ZONE_JMAX_OR_NUM_CELLS_ARRAY_DESCRIPTION)) && kMaxOrNumCornersArray.alloc(___2844) && file.___3457(___3942[ZONE_KMAX_OR_NUM_CORNERS_FILE_LOC_TAG]) && readValueArray<uint64_t, false, 0>(file, 0, ___2844, kMaxOrNumCornersArray, IODescription(ZONE_KMAX_OR_NUM_CORNERS_ARRAY_DESCRIPTION)); if (zoneShareConnectivityArray.empty()) ___2037 = ___2037 && zoneShareConnectivityArray.alloc(___2844); ___2037 = ___2037 && file.___3457(___3942[___4672]) && readValueArray<int32_t, false, 0>(file, zoneOffset, ___2844, zoneShareConnectivityArray, IODescription(___4671)); if (___2037 && zoneOffset != 0) { for (___4634 zone = 0; zone < ___4634(___2844); ++zone) if (zoneShareConnectivityArray[zoneOffset + zone] != NOT_SHARED) zoneShareConnectivityArray[zoneOffset + zone] += zoneOffset; } static std::map<char, ZoneType_e> zoneTypeMap = boost::assign::map_list_of<char, ZoneType_e> (___4703, ___4702) (ZONETYPE_FETRIANGLE_CHAR, ___4700) (ZONETYPE_FEQUAD_CHAR, ___4698) (ZONETYPE_FETETRA_CHAR, ___4699) (ZONETYPE_FEBRICK_CHAR, ___4693) (ZONETYPE_FELINESEG_CHAR, ___4694) (ZONETYPE_FEPOLYGON_CHAR, ___4696) (ZONETYPE_FEPOLYHEDRON_CHAR, ___4697) (ZONETYPE_FEMIXEDVOLUME_CHAR, ___4695); if (___2037) { for(size_t zone = 0; zone < ___2844; ++zone) { ZoneType_e ___4690 = zoneTypeMap[static_cast<char>(std::tolower(zoneTypeArray[zone]))]; zoneMetadata[zone].setZone(static_cast<___4634>(zone)); zoneMetadata[zone].setZoneType(___4690); if (___4690 == ___4702) { ___1842 ___1841( static_cast<___81>(iMaxOrNumNodesArray[zone]), static_cast<___81>(jMaxOrNumCellsArray[zone]), static_cast<___81>(kMaxOrNumCornersArray[zone])); zoneMetadata[zone].setIJKMax(___1841); } else { zoneMetadata[zone].setFEDescription( static_cast<___463>(jMaxOrNumCellsArray[zone]), static_cast<___680>(kMaxOrNumCornersArray[zone]), static_cast<___2716>(iMaxOrNumNodesArray[zone])); } zoneMetadata[zone].setIsSZL(isupper(zoneTypeArray[zone]) ? true : false); zoneMetadata[zone].setName(zoneNameArray[zone]); zoneMetadata[zone].setFaceNeighborMode(static_cast<FaceNeighborMode_e>(faceNeighborModeArray[zone])); zoneMetadata[zone].setSolutionTime(solutionTimeArray[zone]); zoneMetadata[zone].setStrandID(strandIDArray[zone]); zoneMetadata[zone].setParentZone(zoneOffset + parentZoneArray[zone]); } } } catch(std::bad_alloc const&) { ___2037 = ___1184("Out-of-memory error while reading file header."); } catch(...) { ___2037 = ___1184("Unrecoverable error while reading file header.");
} ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 readPerVarZoneFileHeader( ___1397&       file, ___3943&               ___3942, ___4350                 varOffset, ___4634                zoneOffset, VarZoneMinMaxArray&        varZoneMinMaxArray, ___4389& varZoneValueLocationArray, ___4380& varZoneFieldDataTypeArray, ___4383&     varZoneIsPassiveArray, ___4386&         varZoneShareArray) { REQUIRE(file.___2039()); REQUIRE(IMPLICATION(varZoneMinMaxArray.empty(), varOffset == 0)); REQUIRE(IMPLICATION(!varZoneMinMaxArray.empty(), varOffset+___3942[___2843] <= varZoneMinMaxArray.size())); REQUIRE(varZoneValueLocationArray.size() == varZoneMinMaxArray.size()); REQUIRE(varZoneFieldDataTypeArray.size() == varZoneMinMaxArray.size()); REQUIRE(varZoneIsPassiveArray.size() == varZoneMinMaxArray.size()); REQUIRE(varZoneShareArray.size() == varZoneMinMaxArray.size()); ___372 ___2037 = ___4224; try { ___4350 ___2841 = static_cast<___4350>(___3942[___2843]); ___4634 ___2844 = static_cast<___4634>(___3942[___2847]); if (___2841 == 0 || ___2844 == 0) return ___4224; static ___3940 tagDescriptionMap = DATSET_HEADER_TAG_DESCRIPTIONS_MAP_INITIALIZER; static std::vector<uint16_t> const tagList = boost::assign::list_of (VAR_ZONE_MIN_MAX_FILE_LOC_TAG) (___4391) (___4382) (___4385) (___4388); ___2037 = ___2037 && ensureRequiredHeaderTagValuesArePresent("file", ___3942, tagDescriptionMap, tagList); ___2037 = ___2037 && file.___3457(___3942[___4382]); for (___4350 ___4334 = 0; ___2037 && ___4334 < ___2841; ___4334++) ___2037 = ___2037 && readValueArray<uint8_t, false, 0>(file, zoneOffset, ___2844, varZoneFieldDataTypeArray[varOffset + ___4334], IODescription(VAR_ZONE_FIELD_DATA_TYPE_FILE_LOC_DESCRIPTION,___4334)); ___2037 = ___2037 && file.___3457(___3942[VAR_ZONE_MIN_MAX_FILE_LOC_TAG]); if (___2037) { bool minMaxesAreDouble = false; for (___4350 ___4334 = 0; !minMaxesAreDouble && ___4334 < ___2841; ++___4334) { for (___4634 zone = 0; !minMaxesAreDouble && zone < ___2844; ++zone) { FieldDataType_e ___1361 = (FieldDataType_e)varZoneFieldDataTypeArray[varOffset + ___4334][zoneOffset + zone]; if (___1361 == FieldDataType_Double || ___1361 == FieldDataType_Int32) minMaxesAreDouble = true; } } if (minMaxesAreDouble) { for (___4350 ___4334 = 0; ___2037 && ___4334 < ___2841; ___4334++) ___2037 = ___2037 && readMinMaxArray<double>(file, zoneOffset, ___2844, varZoneMinMaxArray[varOffset + ___4334], IODescription(VAR_ZONE_MIN_MAX_FILE_LOC_DESCRIPTION, ___4334)); } else { for (___4350 ___4334 = 0; ___2037 && ___4334 < ___2841; ___4334++) ___2037 = ___2037 && readMinMaxArray<float>(file, zoneOffset, ___2844, varZoneMinMaxArray[varOffset + ___4334], IODescription(VAR_ZONE_MIN_MAX_FILE_LOC_DESCRIPTION, ___4334)); } } ___2037 = ___2037 && file.___3457(___3942[___4391]);
for (___4350 ___4334 = 0; ___2037 && ___4334 < ___2841; ___4334++) ___2037 = ___2037 && readValueArray<uint8_t, false, 0>(file, zoneOffset, ___2844, varZoneValueLocationArray[varOffset + ___4334], IODescription(VAR_ZONE_VALUE_LOCATION_FILE_LOC_DESCRIPTION,___4334)); ___2037 = ___2037 && file.___3457(___3942[___4385]); for (___4350 ___4334 = 0; ___2037 && ___4334 < ___2841; ___4334++) ___2037 = ___2037 && readValueArray<uint8_t, false, 0>(file, zoneOffset, ___2844, varZoneIsPassiveArray[varOffset + ___4334], IODescription(VAR_ZONE_IS_PASSIVE_FILE_LOC_DESCRIPTION,___4334)); ___2037 = ___2037 && file.___3457(___3942[___4388]); for (___4350 ___4334 = 0; ___2037 && ___4334 < ___2841; ___4334++) ___2037 = ___2037 && readValueArray<int32_t, false, 0>(file, zoneOffset, ___2844, varZoneShareArray[varOffset + ___4334], IODescription(VAR_ZONE_SHARE_FILE_LOC_DESCRIPTION,___4334)); if (___2037 && zoneOffset != 0) { for (___4350 ___4334 = 0; ___4334 < ___2841; ++___4334) for (___4634 zone = 0; zone < ___2844; ++zone) if (varZoneShareArray[varOffset + ___4334][zoneOffset + zone] != NOT_SHARED) varZoneShareArray[varOffset + ___4334][zoneOffset + zone] += zoneOffset; } } catch(std::bad_alloc const&) { ___2037 = ___1184("Out-of-memory error while reading file header."); } catch(...) { ___2037 = ___1184("Unrecoverable error while reading file header."); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 readDataSetHeader( ___1397& file, ___3943&         ___3942, std::string&         datasetTitle, ___4705&     ___4704, ___1390&        ___4627) { REQUIRE(file.___2039()); REQUIRE(!___3942.empty()); REQUIRE(___4627.empty() || ___3942[___2847] <= ___4627.size()); ___372 ___2037 = readDatasetTitle(file, ___3942, datasetTitle); if (___2037) { try { ___4350 const ___2841 = static_cast<___4350>(___3942[___2843]); if (___2841 > 0) { uint64_t varNameLocation = ___3942[___4363]; if (varNameLocation == 0) { ___2037 = ___1184("Missing file header tag %" PRIu64 " '%s'.", uint64_t(___4363), VAR_NAME_FILE_LOC_DESCRIPTION); } else { ___2037 = file.___3457(varNameLocation); ___2037 = ___2037 && readStringArray(file, 0, ___2841, ___4704.m_varNames, IODescription(___4362)); } } ___4634 const ___2844 = static_cast<___4634>(___3942[___2847]); if (___2844 > 0) { ___4704.m_numZones = ___2844; ___4704.m_numVars  = ___2841; if (___2037 && ___3942[___4628] == 0) ___2037 = ___1184("File does not contain zone header file locations."); ___2037 = ___2037 && file.___3457(___3942[___4628]); ___2037 = ___2037 && readZoneHeaderFileLocArray(file, 0, ___4634(___2844), ___4627); ___2037 = ___2037 && ___4704.m_zoneNames.alloc(___2844) && file.___3457(___3942[___4649]) && readStringArray(file, 0, ___2844, ___4704.m_zoneNames, IODescription(___4648)) &&
___4704.m_zoneTypes.alloc(___2844) && file.___3457(___3942[ZONE_TYPE_FILE_LOC_TAG]) && readValueArray<char, false, 0>(file, 0, ___2844, ___4704.m_zoneTypes, IODescription(___4692)) && ___4704.m_zoneFaceNeighborModes.alloc(___2844) && file.___3457(___3942[___4608]) && readValueArray<uint8_t, false, 0>(file, 0, ___2844, ___4704.m_zoneFaceNeighborModes, IODescription(___4607)) && ___4704.m_zoneSolutionTimes.alloc(___2844) && file.___3457(___3942[___4674]) && readValueArray<double, false, 0>(file, 0, ___2844, ___4704.m_zoneSolutionTimes, IODescription(___4673)) && ___4704.m_zoneStrandIDs.alloc(___2844) && file.___3457(___3942[___4684]) && readValueArray<uint32_t, false, 0>(file, 0, ___2844, ___4704.m_zoneStrandIDs, IODescription(___4683)) && ___4704.m_zoneParentZones.alloc(___2844) && file.___3457(___3942[___4668]) && readValueArray<int32_t, false, 0>(file, 0, ___2844, ___4704.m_zoneParentZones, IODescription(___4667)) && ___4704.m_zoneIMaxOrNumNodes.alloc(___2844) && file.___3457(___3942[ZONE_IMAX_OR_NUM_NODES_FILE_LOC_TAG]) && readValueArray<uint64_t, false, 0>(file, 0, ___2844, ___4704.m_zoneIMaxOrNumNodes, IODescription(ZONE_IMAX_OR_NUM_NODES_ARRAY_DESCRIPTION)) && ___4704.m_zoneJMaxOrNumCells.alloc(___2844) && file.___3457(___3942[ZONE_JMAX_OR_NUM_CELLS_FILE_LOC_TAG]) && readValueArray<uint64_t, false, 0>(file, 0, ___2844, ___4704.m_zoneJMaxOrNumCells, IODescription(ZONE_JMAX_OR_NUM_CELLS_ARRAY_DESCRIPTION)) && ___4704.m_zoneKMaxOrNumCorners.alloc(___2844) && file.___3457(___3942[ZONE_KMAX_OR_NUM_CORNERS_FILE_LOC_TAG]) && readValueArray<uint64_t, false, 0>(file, 0, ___2844, ___4704.m_zoneKMaxOrNumCorners, IODescription(ZONE_KMAX_OR_NUM_CORNERS_ARRAY_DESCRIPTION)) && ___4704.m_zoneShareConnectivityWithZone.alloc(___2844) && file.___3457(___3942[___4672]) && readValueArray<int32_t, false, 0>(file, 0, ___2844, ___4704.m_zoneShareConnectivityWithZone, IODescription(___4671)); } if (___2844 > 0 && ___2841 > 0) { ___2037 = ___2037 && file.___3457(___3942[___4382]) && ___4704.m_vzFieldDataTypes.alloc(___2841); for (___4350 ___4334 = 0; ___2037 && ___4334 < ___2841; ___4334++) ___2037 = ___2037 && readValueArray<uint8_t, false, 0>(file, 0, ___2844, ___4704.m_vzFieldDataTypes[___4334], IODescription(VAR_ZONE_FIELD_DATA_TYPE_FILE_LOC_DESCRIPTION, ___4334)); ___2037 = ___2037 && file.___3457(___3942[VAR_ZONE_MIN_MAX_FILE_LOC_TAG]) && ___4704.m_vzMinMaxes.alloc(___2841); if (___2037) { bool minMaxesAreDouble = false;
for (___4350 ___4334 = 0; !minMaxesAreDouble && ___4334 < ___2841; ++___4334) { for (___4634 zone = 0; !minMaxesAreDouble && zone < ___2844; ++zone) { FieldDataType_e ___1361 = (FieldDataType_e)___4704.m_vzFieldDataTypes[___4334][zone]; if (___1361 == FieldDataType_Double || ___1361 == FieldDataType_Int32) minMaxesAreDouble = true; } } if (minMaxesAreDouble) { for (___4350 ___4334 = 0; ___2037 && ___4334 < ___2841; ___4334++) ___2037 = ___2037 && readMinMaxArray<double>(file, 0, ___2844, ___4704.m_vzMinMaxes[___4334], IODescription(VAR_ZONE_MIN_MAX_FILE_LOC_DESCRIPTION, ___4334)); } else { for (___4350 ___4334 = 0; ___2037 && ___4334 < ___2841; ___4334++) ___2037 = ___2037 && readMinMaxArray<float>(file, 0, ___2844, ___4704.m_vzMinMaxes[___4334], IODescription(VAR_ZONE_MIN_MAX_FILE_LOC_DESCRIPTION, ___4334)); } } ___2037 = ___2037 && file.___3457(___3942[___4391]) && ___4704.m_vzValueLocations.alloc(___2841); for (___4350 ___4334 = 0; ___2037 && ___4334 < ___2841; ___4334++) ___2037 = ___2037 && readValueArray<uint8_t, false, 0>(file, 0, ___2844, ___4704.m_vzValueLocations[___4334], IODescription(VAR_ZONE_VALUE_LOCATION_FILE_LOC_DESCRIPTION, ___4334)); ___2037 = ___2037 && file.___3457(___3942[___4385]) && ___4704.m_vzIsPassive.alloc(___2841); for (___4350 ___4334 = 0; ___2037 && ___4334 < ___2841; ___4334++) ___2037 = ___2037 && readValueArray<uint8_t, false, 0>(file, 0, ___2844, ___4704.m_vzIsPassive[___4334], IODescription(VAR_ZONE_IS_PASSIVE_FILE_LOC_DESCRIPTION, ___4334)); ___2037 = ___2037 && file.___3457(___3942[___4388]) && ___4704.m_vzShareVarWithZone.alloc(___2841); for (___4350 ___4334 = 0; ___2037 && ___4334 < ___2841; ___4334++) ___2037 = ___2037 && readValueArray<int32_t, false, 0>(file, 0, ___2844, ___4704.m_vzShareVarWithZone[___4334], IODescription(VAR_ZONE_SHARE_FILE_LOC_DESCRIPTION, ___4334)); } } catch (std::bad_alloc const&) { ___2037 = ___1184("Out-of-memory error while reading data set header."); } catch (...) { ___2037 = ___1184("Unrecoverable error while reading data set header."); } } return ___2037; } ZoneType_e zoneTypeFromFileChar(char c) { char lowerCaseChar = static_cast<char>(tolower(c)); std::map<char, ZoneType_e> zoneTypeMap = boost::assign::map_list_of<char, ZoneType_e> (___4703, ___4702) (ZONETYPE_FETRIANGLE_CHAR, ___4700) (ZONETYPE_FEQUAD_CHAR, ___4698) (ZONETYPE_FETETRA_CHAR, ___4699) (ZONETYPE_FEBRICK_CHAR, ___4693) (ZONETYPE_FELINESEG_CHAR, ___4694) (ZONETYPE_FEPOLYGON_CHAR, ___4696) (ZONETYPE_FEPOLYHEDRON_CHAR, ___4697) (ZONETYPE_FEMIXEDVOLUME_CHAR, ___4695); REQUIRE(zoneTypeMap.find(lowerCaseChar) != zoneTypeMap.end()); return zoneTypeMap[lowerCaseChar]; } void storeZoneMetadata( ___4705 const& ___4704, ___4634            zone, ___4634            targetBaseZoneOffset, ZoneMetadata&          zoneMetadata) { zoneMetadata.setZone(zone);
ZoneType_e ___4690 = zoneTypeFromFileChar(___4704.m_zoneTypes[zone]); zoneMetadata.setZoneType(___4690); if (___4690 == ___4702) { ___1842 ___1841( static_cast<___81>(___4704.m_zoneIMaxOrNumNodes[zone]), static_cast<___81>(___4704.m_zoneJMaxOrNumCells[zone]), static_cast<___81>(___4704.m_zoneKMaxOrNumCorners[zone])); zoneMetadata.setIJKMax(___1841); } else { zoneMetadata.setFEDescription( static_cast<___463>  (___4704.m_zoneJMaxOrNumCells[zone]), static_cast<___680>(___4704.m_zoneKMaxOrNumCorners[zone]), static_cast<___2716>  (___4704.m_zoneIMaxOrNumNodes[zone])); } zoneMetadata.setIsSZL(isupper(___4704.m_zoneTypes[zone]) ? true : false); zoneMetadata.setName(___4704.m_zoneNames[zone]); zoneMetadata.setFaceNeighborMode(static_cast<FaceNeighborMode_e>(___4704.m_zoneFaceNeighborModes[zone])); zoneMetadata.setSolutionTime(___4704.m_zoneSolutionTimes[zone]); zoneMetadata.setStrandID(___4704.m_zoneStrandIDs[zone]); zoneMetadata.setParentZone(targetBaseZoneOffset + ___4704.m_zoneParentZones[zone]); } namespace { ___372 readAuxDataItem( ___1397& file, ___4350           varOffset, ___4634          zoneOffset, ___230&             auxData) { uint8_t auxDataLocation = 0; uint32_t auxDataEntity = 0; uint32_t auxDataNameLength = 0; ___471 auxDataName; uint8_t auxDataType = 0; uint32_t auxDataValueLength = 0; ___471 auxDataValue; ___372 ___2037 = readValue<uint8_t, false>(file, auxDataLocation, IODescription(___252)); ___2037 = ___2037 && readValue<uint32_t, false>(file, auxDataEntity, IODescription(___239)); ___2037 = ___2037 && readValue<uint32_t, false>(file, auxDataNameLength, IODescription(___262)); ___2037 = ___2037 && (auxDataNameLength > 0); ___2037 = ___2037 && auxDataName.alloc(static_cast<uint64_t>(auxDataNameLength)); ___2037 = ___2037 && readString(file, auxDataNameLength, auxDataName, IODescription(___261)); ___2037 = ___2037 && readValue<uint8_t, false>(file, auxDataType, IODescription(___268)); ___2037 = ___2037 && readValue<uint32_t, false>(file, auxDataValueLength, IODescription(___272)); if (___2037 && auxDataValueLength > 0) { ___2037 = auxDataValue.alloc(static_cast<uint64_t>(auxDataValueLength)); ___2037 = ___2037 && readString(file, auxDataValueLength, auxDataValue, IODescription(___271)); } if (___2037) { try { AuxDataLocation_e location = static_cast<AuxDataLocation_e>(auxDataLocation); ___1170 entity = static_cast<___1170>(auxDataEntity); AuxDataType_e type = static_cast<AuxDataType_e>(auxDataType); ___476(type == ___270); if (location == ___258) entity += varOffset; else if (location == ___259) entity += zoneOffset; std::string auxDataValueString; if (auxDataValueLength > 0) auxDataValueString = std::string(auxDataValue.data(), auxDataValueLength); auxData = ___230(std::string(auxDataName.data(), auxDataNameLength), auxDataValueString, location, entity, type);
} catch (std::bad_alloc const&) { ___2037 = ___1184("Out-of-memory error while reading auxiliary data."); } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } ___372 readAuxDataCount( ___1397& file, ___3943&         ___3942, uint32_t&            auxDataCount) { REQUIRE(file.___2039()); REQUIRE(___3942.find(___241) != ___3942.end()); ___372 ___2037 = file.___3457(___3942[___241]); if (file.___2000()) ___2037 = ___2037 && readAndVerifyValue<uint32_t, false>(file, SZPLT_AUX_DATA_MARKER, IODescription(SZPLT_AUX_DATA_MARKER_DESCRIPTION)); ___2037 = ___2037 && readValue<uint32_t, false>(file, auxDataCount, IODescription(___233)); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 readAuxData( ___1397& file, ___3943&         ___3942, ___4350           varOffset, ___4634          zoneOffset, uint32_t             auxDataOffset, AuxDataArray&        auxDataArray) { REQUIRE(file.___2039()); uint32_t  auxDataCount = 0; ___372 ___2037 = readAuxDataCount(file, ___3942, auxDataCount); for(uint32_t i = 0; ___2037 && i < auxDataCount; ++i) ___2037 = readAuxDataItem(file, varOffset, zoneOffset, auxDataArray[auxDataOffset + i]); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } namespace { ___372 readGeomLineSegData( ___1397& file, ___1554&                ___1553) { REQUIRE(file.___2039()); REQUIRE(___1553.___2464 == GeomType_LineSegs); uint32_t ___2833; bool is3D = (___1553.___2614 == CoordSys_Grid3D);
 #if 0
std::vector<std::vector<class ___4578> > ___2462;
 #endif
___372 ___2037 = readValue<uint32_t, false>(file, ___2833, IODescription(___1621)); if (___2037) { try { ___1553.___2462.resize(static_cast<size_t>(___2833)); } catch(...) { ___2037 = ___1184("Out of memory while reading geometry data."); } } for(uint32_t segment = 0; ___2037 && segment < ___2833; ++segment) { uint32_t numPts = 0; ___1103 xPts; ___1103 yPts; ___1103 zPts; ___2037 = ___2037 && readValue<uint32_t, false>(file, numPts, IODescription(___1620)) && xPts.alloc(static_cast<uint64_t>(numPts)) && yPts.alloc(static_cast<uint64_t>(numPts)); if (is3D) ___2037 = ___2037 && zPts.alloc(static_cast<uint64_t>(numPts)); ___2037 = ___2037 && readValueArray<double, false, 0>(file, 0, static_cast<size_t>(numPts), xPts, IODescription(___1652)) && readValueArray<double, false, 0>(file, 0, static_cast<size_t>(numPts), yPts, IODescription(___1654)); if (is3D) ___2037 && readValueArray<double, false, 0>(file, 0, static_cast<size_t>(numPts), zPts, IODescription(___1657)); for(uint32_t i = 0; ___2037 && i < numPts; ++i) { try { if (is3D) ___1553.___2462[segment].push_back(___4578(xPts[i], yPts[i], zPts[i])); else ___1553.___2462[segment].push_back(___4578(xPts[i], yPts[i], 0.0)); } catch(...) { ___2037 = ___1184("Out of memory while reading geometry data."); } } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { ___372 readGeometry( ___1397& file, ___1554&                ___1553) { REQUIRE(file.___2039()); ___372 ___2037 = readValue<double, false>(file, ___1553.___2615[0], IODescription(___1651)) && readValue<double, false>(file, ___1553.___2615[1], IODescription(___1653)) && readValue<double, false>(file, ___1553.___2615[2], IODescription(___1656)); uint8_t ___3157 = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, ___3157, IODescription(___1625)); ___1553.___2614 = static_cast<CoordSys_e>(___3157); uint8_t ___2002 = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, ___2002, IODescription(___1609)); ___1553.___2482 = static_cast<___372>(___2002); int32_t zone = 0; ___2037 = ___2037 && readValue<int32_t, false>(file, zone, IODescription(___1655)); ___1553.___2675 = static_cast<___1170>(zone); uint16_t color = 0; ___2037 = ___2037 && readValue<uint16_t, false>(file, color, IODescription(___1569)); ___1553.___2393 = static_cast<___514>(color); uint16_t ___1409 = 0; ___2037 = ___2037 && readValue<uint16_t, false>(file, ___1409, IODescription(___1580)); ___1553.___2460 = static_cast<___514>(___1409); uint8_t ___2020 = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, ___2020, IODescription(___1610)); ___1553.___2484 = static_cast<___372>(___2020); uint8_t ___1649 = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, ___1649, IODescription(GEOM_GEOM_TYPE)); ___1553.___2464 = static_cast<GeomType_e>(___1649); uint8_t ___2261 = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, ___2261, IODescription(___1611));
___1553.___2487 = static_cast<LinePattern_e>(___2261); ___2037 = ___2037 && readValue<double, false>(file, ___1553.___2613, IODescription(___1623)); ___2037 = ___2037 && readValue<double, false>(file, ___1553.___2488, IODescription(___1612)); ___2037 = ___2037 && readValue<uint16_t, false>(file, ___1553.___2500, IODescription(___1619)); uint8_t arrowheadStyle = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, arrowheadStyle, IODescription(___1567)); ___1553.___2341 = static_cast<ArrowheadStyle_e>(arrowheadStyle); uint8_t arrowheadAttachment = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, arrowheadAttachment, IODescription(___1561)); ___1553.___2339 = static_cast<ArrowheadAttachment_e>(arrowheadAttachment); ___2037 = ___2037 && readValue<double, false>(file, ___1553.___2340, IODescription(___1566)); ___2037 = ___2037 && readValue<double, false>(file, ___1553.___2338, IODescription(___1560)); uint8_t geomScope = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, geomScope, IODescription(___1631)); ___1553.___2617 = static_cast<Scope_e>(geomScope); uint8_t geomClipping = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, geomClipping, IODescription(GEOM_CLIPPING)); ___1553.___2392 = static_cast<Clipping_e>(geomClipping); uint32_t macroFunctionCommandLength = 0; ___2037 = ___2037 && readValue<uint32_t, false>(file, macroFunctionCommandLength, IODescription(___1614)); if (___2037 && macroFunctionCommandLength > 0) { try { ___471 ___2328; ___2037 = ___2037 && ___2328.alloc(static_cast<uint64_t>(macroFunctionCommandLength)) && readString(file, static_cast<size_t>(macroFunctionCommandLength), ___2328, IODescription(___1613)); if (___2037) ___1553.___2489 = std::string(&___2328[0], static_cast<size_t>(macroFunctionCommandLength)); } catch (std::bad_alloc const&) { ___2037 = ___1184("Out-of-memory error while reading geometries."); } } ___4578 basicGeomData; ___476(!basicGeomData.___2065()); switch (___1553.___2464) { case GeomType_LineSegs: { ___2037 = ___2037 && readGeomLineSegData(file, ___1553); } break; case GeomType_Rectangle: { double ___4456 = 0.0; double ___1824 = 0.0; ___2037 = ___2037 && readValue<double, false>(file, ___4456, IODescription(___1628)) && readValue<double, false>(file, ___1824, IODescription(___1627)); if (___2037) basicGeomData = ___4578(___4456, ___1824, 0.0); } break; case GeomType_Square: { double squareSize = 0.0; ___2037 = ___2037 && readValue<double, false>(file, squareSize, IODescription(___1647)); if (___2037) basicGeomData = ___4578(squareSize, 0.0, 0.0); } break; case GeomType_Circle: { double radius = 0.0; ___2037 = ___2037 && readValue<double, false>(file, radius, IODescription(___1606)); if (___2037) basicGeomData = ___4578(radius, 0.0, 0.0); } break; case GeomType_Ellipse: { double horizontalAxis = 0.0; double verticalAxis = 0.0;
___2037 = ___2037 && readValue<double, false>(file, horizontalAxis, IODescription(___1576)) && readValue<double, false>(file, verticalAxis, IODescription(___1577)); if (___2037) basicGeomData = ___4578(horizontalAxis, verticalAxis, 0.0); } break; default: ___476(___1303); break; } if (___2037 && basicGeomData.___2065()) { try { ___1553.___2462.resize(1); ___1553.___2462[0].push_back(basicGeomData); } catch(...) { ___2037 = ___1184("Out of memory reading square geometry."); } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } ___372 readGeometriesCount( ___1397& file, ___3943&         ___3942, uint32_t&            geomCount) { REQUIRE(file.___2039()); REQUIRE(___3942.find(___1579) != ___3942.end()); ___372 ___2037 = file.___3457(___3942[___1579]); if (file.___2000()) ___2037 = ___2037 && readAndVerifyValue<uint32_t, false>(file, SZPLT_GEOMETRY_MARKER, IODescription(SZPLT_GEOMETRY_MARKER_DESCRIPTION)); ___2037 = ___2037 && readValue<uint32_t, false>(file, geomCount, IODescription(NUM_GEOMS_DESCRIPTION)); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 readGeometries( ___1397& file, ___3943&         ___3942, uint32_t             geomOffset, GeomArray&           geomArray) { REQUIRE(file.___2039()); uint32_t geomCount = 0; ___372 ___2037 = readGeometriesCount(file, ___3942, geomCount); for(uint32_t i = 0; ___2037 && i < geomCount; ++i) ___2037 = readGeometry(file, geomArray[geomOffset + i]); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } namespace { ___372 readText( ___1397& file, Text&                ___4040) { REQUIRE(file.___2039()); ___372 ___2037 = readValue<double, false>(file, ___4040.___2624[0], IODescription(___1651)) && readValue<double, false>(file, ___4040.___2624[1], IODescription(___1653)) && readValue<double, false>(file, ___4040.___2624[2], IODescription(___1656)); uint16_t ___4078 = 0; ___2037 = ___2037 && readValue<uint16_t, false>(file, ___4078, IODescription(___4080)); ___4040.___2632 = static_cast<___514>(___4078); uint16_t ___4057 = 0; ___2037 = ___2037 && readValue<uint16_t, false>(file, ___4057, IODescription(___4058)); ___4040.___2626 = static_cast<___514>(___4057); uint16_t ___4059 = 0; ___2037 = ___2037 && readValue<uint16_t, false>(file, ___4059, IODescription(___4060)); ___4040.___2627 = static_cast<___514>(___4059); ___2037 = ___2037 && readValue<double, false>(file, ___4040.___2628, IODescription(___4070)); ___2037 = ___2037 && readValue<double, false>(file, ___4040.___2629, IODescription(___4072)); uint8_t ___4076 = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, ___4076, IODescription(TEXT_BOX_TYPE)); ___4040.___2630 = static_cast<TextBox_e>(___4076); uint8_t ___4041 = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, ___4041, IODescription(___4042));
___4040.___2623 = static_cast<TextAnchor_e>(___4041); ___2037 = ___2037 && readValue<double, false>(file, ___4040.___2625, IODescription(___4055)); uint8_t ___4077 = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, ___4077, IODescription(TEXT_CLIPPING)); ___4040.___2631 = static_cast<Clipping_e>(___4077); ___2037 = ___2037 && readValue<double, false>(file, ___4040.___2633, IODescription(TEXT_HEIGHT)); ___2037 = ___2037 && readValue<double, false>(file, ___4040.___2635, IODescription(___4106)); uint8_t ___4113 = 0; ___2037 = ___2037 &&  readValue<uint8_t, false>(file, ___4113, IODescription(___4114)); ___4040.___2637 = static_cast<CoordSys_e>(___4113); uint8_t ___4117 = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, ___4117, IODescription(___4118)); ___4040.___2639 = static_cast<Scope_e>(___4117); uint8_t ___4122 = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, ___4122, IODescription(___4123)); ___4040.___2640 = static_cast<Units_e>(___4122); uint32_t textStringLength = 0; ___2037 = ___2037 && readValue<uint32_t, false>(file, textStringLength, IODescription(___4126)); try { if (textStringLength > 0) { ___471 ___4124; ___2037 = ___2037 && ___4124.alloc(static_cast<size_t>(textStringLength)) && readString(file, static_cast<size_t>(textStringLength), ___4124, IODescription(___4125)); if (___2037) ___4040.___2641 = std::string(&___4124[0], static_cast<size_t>(textStringLength)); } uint32_t textTypefaceFamilyLength = 0; ___2037 = ___2037 && readValue<uint32_t, false>(file, textTypefaceFamilyLength, IODescription(___4129)); if (___2037 && textTypefaceFamilyLength > 0) { ___471 ___4127; ___2037 = ___2037 && ___4127.alloc(static_cast<size_t>(textTypefaceFamilyLength)) && readString(file, static_cast<size_t>(textTypefaceFamilyLength), ___4127, IODescription(___4128)); if (___2037) ___4040.___2642 = std::string(&___4127[0], static_cast<size_t>(textTypefaceFamilyLength)); } uint8_t ___4130 = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, ___4130, IODescription(___4131)); ___4040.___2643 = static_cast<___372>(___4130); uint8_t ___4132 = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, ___4132, IODescription(___4133)); ___4040.___2644 = static_cast<___372>(___4132); int32_t ___4136 = 0; ___2037 = ___2037 && readValue<int32_t, false>(file, ___4136, IODescription(___4137)); ___4040.___2645 = static_cast<___1170>(___4136); uint8_t ___4103 = 0; ___2037 = ___2037 && readValue<uint8_t, false>(file, ___4103, IODescription(___4104)); ___4040.___2634 = static_cast<___372>(___4103); uint32_t textMacroFunctionCmdLength = 0; ___2037 = ___2037 && readValue<uint32_t, false>(file, textMacroFunctionCmdLength, IODescription(___4109));
if (___2037 && textMacroFunctionCmdLength > 0) { ___471 ___4107; ___2037 = ___2037 && ___4107.alloc(static_cast<size_t>(textMacroFunctionCmdLength)) && readString(file, static_cast<size_t>(textMacroFunctionCmdLength), ___4107, IODescription(___4108)); if (___2037) ___4040.___2636 = std::string(&___4107[0], static_cast<size_t>(textMacroFunctionCmdLength)); } } catch (std::bad_alloc const&) { ___2037 = ___1184("Out-of-memory error while reading text."); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } ___372 readTextsCount( ___1397& file, ___3943&         ___3942, uint32_t&            textCount) { REQUIRE(file.___2039()); REQUIRE(___3942.find(___4081) != ___3942.end()); ___372 ___2037 = file.___3457(___3942[___4081]); if (file.___2000()) ___2037 = ___2037 && readAndVerifyValue<uint32_t, false>(file, SZPLT_TEXT_MARKER, IODescription(SZPLT_TEXT_MARKER_DESCRIPTION)); ___2037 = ___2037 && readValue<uint32_t, false>(file, textCount, IODescription(NUM_TEXTS_DESCRIPTION)); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 readTexts( ___1397& file, ___3943&         ___3942, uint32_t             textOffset, TextArray&           textArray) { REQUIRE(file.___2039()); uint32_t textCount = 0; ___372 ___2037 = readTextsCount(file, ___3942, textCount); for(uint32_t i = 0; ___2037 && i < textCount; ++i) ___2037 = readText(file, textArray[textOffset + i]); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } namespace { ___372 readCustomLabelSet( ___1397& file, CustomLabelSet&      customLabelSet) { REQUIRE(file.___2039()); ___372 ___2037 = readValue<uint32_t, false>(file, customLabelSet.m_numLabels, IODescription(___2818)) && readStringArray(file, 0, size_t(customLabelSet.m_numLabels), customLabelSet.m_labels, IODescription(___792)); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } ___372 readCustomLabelsCount( ___1397& file, ___3943&         ___3942, uint32_t&            customLabelsCount) { REQUIRE(file.___2039()); REQUIRE(___3942.find(___793) != ___3942.end()); ___372 ___2037 = ___4224; ___2037 = file.___3457(___3942[___793]); if (file.___2000()) ___2037 = ___2037 && readAndVerifyValue<uint32_t, false>(file, SZPLT_CUSTOM_LABELS_MARKER, IODescription(SZPLT_CUSTOM_LABELS_MARKER_DESCRIPTION)); ___2037 = ___2037 && readValue<uint32_t, false>(file, customLabelsCount, IODescription(___791)); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 readCustomLabels( ___1397& file, ___3943&         ___3942, uint32_t&            customLabelsOffset, CustomLabelsArray&   customLabelsArray) { REQUIRE(file.___2039()); uint32_t  customLabelsCount = 0; ___372 ___2037 = readCustomLabelsCount(file, ___3942, customLabelsCount); for(uint32_t i = 0; ___2037 && i < customLabelsCount; ++i) ___2037 = readCustomLabelSet(file, customLabelsArray[customLabelsOffset + i]);
ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 readZoneHeaderTags( ___1397& file, ___4634          expectedZone, ___3943&         ___3942) { ___372 ___2037 = ___4224; REQUIRE(file.___2039()); REQUIRE(expectedZone>=0); if ( file.___2000() ) { ___2037 = ___2037 && readAndVerifyValue<uint32_t, false>(file, SZPLT_ZONE_MARKER, IODescription(SZPLT_ZONE_MARKER_DESCRIPTION)); ___2037 = ___2037 && readAndVerifyValue<uint32_t, false>(file, uint32_t(expectedZone + 1), IODescription(SZPLT_ZONE_NUM_DESCRIPTION)); } ___3940 tagDescriptionMap = ___4687; ___2037 = ___2037 && readTagList(file, tagDescriptionMap, ___3942); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } namespace { ___372 checkArrayHeaderTag( uint16_t             tag, ___3943 const&   ___3942, IODescription const& ___970) { REQUIRE(!___970.isEmpty() && ___970.zone()!=IODescription::NO_ZONE); ___372 ___2037 = ___4224; ___3943::const_iterator iter = ___3942.find(tag); if ( iter == ___3942.end() ) { if ( ___970.___2975() == IODescription::NO_PARTITION ) ___2037 = ___1184("Missing zone header tag '%s' for zone %" PRIu64 ".", ___970.___2683(), uint64_t(___970.zone()+1)); else ___2037 = ___1184("Missing partition header tag '%s' for partition %" PRIu64 " of zone %" PRIu64 ".", ___970.___2683(), uint64_t(___970.___2975()+1), uint64_t(___970.zone()+1)); } else if ( iter->second == 0 || iter->second == ___330 ) { if ( ___970.___2975() == IODescription::NO_PARTITION ) ___2037 = ___1184("Invalid value for zone header tag '%s' for zone %" PRIu64, ___970.___2683(), uint64_t(___970.zone()+1)); else ___2037 = ___1184("Invalid value for partition header tag '%s' for partition %" PRIu64 " of zone %" PRIu64 ".", ___970.___2683(), uint64_t(___970.___2975()+1), uint64_t(___970.zone()+1)); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { ___372 applyZoneHeaderScalarTagValues( ___3943&  ___3942, ZoneMetadata& zoneMetadata) { ___372 ___2037 = ___4224; try { zoneMetadata.m_classicZoneFileLocations.___2496 = (___3942[___2723] ? ___3942[___2723] : ___330); zoneMetadata.m_classicZoneFileLocations.___2661 = (___3942[USER_FACE_NBR_FILE_LOC_TAG] ? ___3942[USER_FACE_NBR_FILE_LOC_TAG] : ___330); ___2088::___2978 const numPartitions = ___2088::___2978(___3942[NUM_PARTITIONS_TAG]); if ( numPartitions == 0 ) zoneMetadata.setNumPartitions(1); else zoneMetadata.setNumPartitions(numPartitions); } catch(std::bad_alloc const&) { ___2037 = ___1184("Out-of-memory error while retrieving file tags."); } catch(...) { ___2037 = ___1184("Unrecoverable error while retrieving file tags."); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { template<typename T> ___372 readHeaderTagArray( ___1397&  file, ___3943&          ___3942, uint16_t              tagValue,
size_t                ___2863, size_t                numValues, ___2238<T>& valueArray, ___372           (*readValueArrayFunc)(___1397& file, size_t ___2863, size_t ___2793, ___2238<T>& valueArray, IODescription const& ___970), IODescription const&  ___970) { ___372 ___2037 = checkArrayHeaderTag(tagValue, ___3942, ___970); if ( ___2037 ) { ___1391 const fileLoc = ___3942[tagValue]; ___476(fileLoc != ___330 && fileLoc != 0); ___2037 = file.___3457(fileLoc) && readValueArrayFunc(file, ___2863, numValues, valueArray, ___970); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { ___372 readNonSZLZoneHeaderArrays( ___1397& file, ___3943&         ___3942, ___4350           numVarsInFile, ZoneMetadata&        zoneMetadata) { ___372 ___2037 = ___4224; REQUIRE(!zoneMetadata.isSZL()); ___4634 zone = zoneMetadata.zone(); try { ___2037 = ___2037 && readHeaderTagArray<uint64_t>( file, ___3942, ___4340, 0, numVarsInFile, zoneMetadata.m_classicZoneFileLocations.___2671, readValueArray<uint64_t, true, 0>, IODescription(VAR_FILE_LOC_DESCRIPTION, IODescription::NO_VAR, zone)); } catch (std::bad_alloc const&) { ___2037 = ___1184("Out-of-memory error while reading zone %" PRIu64 " header.", uint64_t(zone + 1)); } catch (...) { ___2037 = ___1184("Unrecoverable error while reading zone %" PRIu64 " header.", uint64_t(zone + 1)); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { inline uint64_t minMaxBlockSize(FieldDataType_e ___1361, ___2088::SubzoneOffset_t numSubzones, bool ___2000) { REQUIRE(VALID_ENUM(___1361, FieldDataType_e)); REQUIRE(numSubzones > 0); switch (___1361) { case FieldDataType_Float: return arraySizeInFile<std::pair<float, float>, false >(numSubzones, ___2000); case FieldDataType_Double: return arraySizeInFile<std::pair<double, double>, false >(numSubzones, ___2000); case FieldDataType_Int32: return arraySizeInFile<std::pair<int32_t, int32_t>, false >(numSubzones, ___2000); case FieldDataType_Int16: return arraySizeInFile<std::pair<int16_t, int16_t>, false >(numSubzones, ___2000); case FieldDataType_Byte: case ___1363: return arraySizeInFile<std::pair<uint8_t, uint8_t>, false >(numSubzones, ___2000); default: ___476(___1303); return 0; } } } namespace { ___372 readSZLNonPartitionedZoneHeaderArrays( ___1397&      file, ___1386 const&    ___1385, ___3943&              ___3942, ___4634               zoneOffset, ___4350                varOffset, ___4350                numVarsInFile, VarZoneMinMaxArray const& vzMinMax, ___4380 const& vzFieldDataTypes, ZoneMetadata&             zoneMetadata) { REQUIRE(file.___2039()); REQUIRE(numVarsInFile>0); REQUIRE(IMPLICATION(vzMinMax.empty(), varOffset == 0)); REQUIRE(IMPLICATION(!vzMinMax.empty(), size_t(varOffset+numVarsInFile) <= vzMinMax.size())); REQUIRE(zoneMetadata.isSZL()); REQUIRE(zoneMetadata.getNumPartitions()==1);
___4634 const zone = zoneMetadata.zone(); ___476(zoneMetadata.m_ptnFileNums.empty()); ___476(zoneMetadata.m_ptnHeaderFileLocs.empty()); ___372 ___2037 = ___4224; try { ___2037 = ___2037 && zoneMetadata.m_ptnNumCells.alloc(1); ___2037 = ___2037 && zoneMetadata.m_ptnNumNodes.alloc(1); ___2037 = ___2037 && zoneMetadata.m_ptnFirstCell.alloc(1); ___2037 = ___2037 && zoneMetadata.m_ptnFirstNode.alloc(1); if ( zoneMetadata.getZoneType() == ___4702 ) { ___2037 = ___2037 && zoneMetadata.m_ptnNodeMinIJKs.alloc(1); ___2037 = ___2037 && zoneMetadata.m_ptnNodeMaxIJKs.alloc(1); } ___2037 = ___2037 && zoneMetadata.m_ptnNumCszs.alloc(1); ___2037 = ___2037 && zoneMetadata.m_ptnNumNszs.alloc(1); if ( ___2037 ) { ___463 const ___2779 = zoneMetadata.___1764(); ___2716 const ___2819 = zoneMetadata.___1766(); zoneMetadata.m_ptnNumCells[0] = ___2779; zoneMetadata.m_ptnNumNodes[0] = ___2819; zoneMetadata.m_ptnFirstCell[0] = 0; zoneMetadata.m_ptnFirstNode[0] = 0; if ( zoneMetadata.getZoneType() == ___4702 ) { ___2037 = ___2037 && zoneMetadata.m_ijkZoneInfos.alloc(1); if (___2037) { zoneMetadata.m_ijkZoneInfos[0] = ___1879(zoneMetadata.getZoneIJK(), ___1385.___1755()); zoneMetadata.m_ptnNodeMinIJKs[0] = ___1842(0,0,0); zoneMetadata.m_ptnNodeMaxIJKs[0] = zoneMetadata.getZoneIJK()-1; zoneMetadata.m_ptnNumCszs[0] = zoneMetadata.m_ijkZoneInfos[0].getNumCszs(); zoneMetadata.m_ptnNumNszs[0] = zoneMetadata.m_ijkZoneInfos[0].getNumNszs(); } } else { zoneMetadata.m_ptnNumCszs[0] = getNumSzFromNumItems(___2779); zoneMetadata.m_ptnNumNszs[0] = getNumSzFromNumItems(___2819); } } ___2037 = ___2037 && zoneMetadata.m_varPtnMinMaxTrees.alloc(numVarsInFile); for ( ___4350 ___4334 = 0; ___2037 && ___4334 < numVarsInFile; ++___4334 ) zoneMetadata.m_varPtnMinMaxTrees[___4334].populateTreeFromMinMax(vzMinMax[varOffset + ___4334][zoneOffset + zone]); ___2037 = ___2037 && zoneMetadata.m_ptnMetadata.alloc(1); if ( ___2037 ) { PartitionMetadata& partitionMetadata = zoneMetadata.m_ptnMetadata[0]; ___2037 = ___2037 && partitionMetadata.m_cszMinMaxFileLocs.alloc(numVarsInFile); ___2037 = ___2037 && partitionMetadata.m_szDataStartFileLocs.alloc(numVarsInFile); ___2037 = ___2037 && readHeaderTagArray<uint64_t>( file, ___3942, ___4340, 0, numVarsInFile, partitionMetadata.m_nszMinMaxFileLocs, readValueArray<uint64_t, true, 0>, IODescription(VAR_FILE_LOC_DESCRIPTION,IODescription::NO_VAR,zone)); if ( ___2037 ) { ___2088::SubzoneOffset_t const numCszs = zoneMetadata.getNumCszsInPartition(0); ___2088::SubzoneOffset_t const numNszs = zoneMetadata.getNumNszsInPartition(0); uint64_t nszMinMaxBlockSize; uint64_t cszMinMaxBlockSize; for ( ___4350 ___4334 = 0; ___4334 < numVarsInFile; ++___4334 ) { nszMinMaxBlockSize = minMaxBlockSize((FieldDataType_e)vzFieldDataTypes[varOffset + ___4334][zoneOffset + zone], numNszs, ___1385.___2000() ? true : false); cszMinMaxBlockSize = minMaxBlockSize((FieldDataType_e)vzFieldDataTypes[varOffset + ___4334][zoneOffset + zone], numCszs, ___1385.___2000() ? true : false); if (partitionMetadata.m_nszMinMaxFileLocs[___4334] != ___330)
{ partitionMetadata.m_cszMinMaxFileLocs[___4334]   = partitionMetadata.m_nszMinMaxFileLocs[___4334] + nszMinMaxBlockSize; partitionMetadata.m_szDataStartFileLocs[___4334] = partitionMetadata.m_cszMinMaxFileLocs[___4334] + cszMinMaxBlockSize; } else { partitionMetadata.m_cszMinMaxFileLocs[___4334]   = ___330; partitionMetadata.m_szDataStartFileLocs[___4334] = ___330; } } if (___3892(zoneMetadata.getZoneType()) && ___1385.___842() != ___846) { if (___3942.find(NSZ_CONNECT_FILE_LOC_TAG) != ___3942.end() && ___3942.find(NSZ_CONNECT_FILE_LOC_TAG)->second != ___330) { ___2037 = ___2037 && readHeaderTagArray<uint64_t>( file, ___3942, NSZ_CONNECT_FILE_LOC_TAG, 0, numNszs, partitionMetadata.m_nszConnectivityFileLocs, readValueArray<uint64_t, true, 0>, IODescription(NSZ_CONNECT_FILE_LOC_DESCRIPTION,IODescription::NO_VAR,zone)); ___2037 = ___2037 && readHeaderTagArray<uint64_t>( file, ___3942, CSZ_CONNECT_FILE_LOC_TAG, 0, numCszs, partitionMetadata.m_cszConnectivityFileLocs, readValueArray<uint64_t, true, 0>, IODescription(CSZ_CONNECT_FILE_LOC_DESCRIPTION,IODescription::NO_VAR,zone)); if (___1385.getFileVersion() > 104) { ___2037 = ___2037 && readHeaderTagArray<uint16_t>( file, ___3942, NUM_REF_NODE_SUBZONES_TAG, 0, numCszs, partitionMetadata.m_cszNumRefNszs, readValueArray<uint16_t, false, 0>, IODescription(NUM_REF_NODE_SUBZONES_DESCRIPTION,IODescription::NO_VAR,zone)); ___2037 = ___2037 && readHeaderTagArray<uint16_t>( file, ___3942, NUM_REF_CELL_SUBZONES_TAG, 0, numNszs, partitionMetadata.m_nszNumRefCszs, readValueArray<uint16_t, false, 0>, IODescription(NUM_REF_CELL_SUBZONES_DESCRIPTION,IODescription::NO_VAR,zone)); } } else { ___2037 = ((___3942.find(NSZ_CONNECT_FILE_LOC_TAG) != ___3942.end() && ___3942.find(NSZ_CONNECT_FILE_LOC_TAG)->second == ___330) && (___3942.find(CSZ_CONNECT_FILE_LOC_TAG) != ___3942.end() && ___3942.find(CSZ_CONNECT_FILE_LOC_TAG)->second == ___330) && IMPLICATION(___1385.getFileVersion() > 104, (___3942.find(NUM_REF_NODE_SUBZONES_TAG) != ___3942.end() && ___3942.find(NUM_REF_NODE_SUBZONES_TAG)->second == ___330) && (___3942.find(NUM_REF_CELL_SUBZONES_TAG) != ___3942.end() && ___3942.find(NUM_REF_CELL_SUBZONES_TAG)->second == ___330))); if (!___2037) ___1184("Connectivity integrity error while reading SZL zone %" PRIu64 " header.", uint64_t(zone+1)); } } } } else { throw std::bad_alloc(); } } catch(std::bad_alloc const&) { ___2037 = ___1184("Out-of-memory error while reading SZL zone %" PRIu64 " header.", uint64_t(zone+1)); } catch(...) { ___2037 = ___1184("Unrecoverable error while reading SZL zone %" PRIu64 " header.", uint64_t(zone+1)); } if ( !___2037 ) { zoneMetadata.m_ptnNumCells.___935(); zoneMetadata.m_ptnNumNodes.___935(); zoneMetadata.m_ptnFirstCell.___935(); zoneMetadata.m_ptnFirstNode.___935(); zoneMetadata.m_ptnNumCszs.___935(); zoneMetadata.m_ptnNumNszs.___935(); zoneMetadata.m_varPtnMinMaxTrees.___935();
zoneMetadata.m_ptnMetadata.___935(); } ENSURE(zoneMetadata.m_ptnFileNums.empty()); ENSURE(zoneMetadata.m_ptnHeaderFileLocs.empty()); ENSURE(zoneMetadata.m_varPtnMinMaxFileLocs.empty()); ENSURE(IMPLICATION(___2037, zoneMetadata.m_ptnNumCells.size()==1)); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnNumCells.empty())); ENSURE(IMPLICATION(___2037, zoneMetadata.m_ptnNumNodes.size()==1)); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnNumNodes.empty())); ENSURE(IMPLICATION(___2037, zoneMetadata.m_ptnFirstCell.size() == 1)); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnFirstCell.empty())); ENSURE(IMPLICATION(___2037, zoneMetadata.m_ptnFirstNode.size() == 1)); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnFirstNode.empty())); ENSURE(IMPLICATION(___2037, zoneMetadata.m_ptnNumCszs.size()==1)); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnNumCszs.empty())); ENSURE(IMPLICATION(___2037, zoneMetadata.m_ptnNumNszs.size()==1)); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnNumNszs.empty())); ENSURE(IMPLICATION(___2037, zoneMetadata.m_varPtnMinMaxTrees.size()==size_t(numVarsInFile))); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_varPtnMinMaxTrees.empty())); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { ___372 readSZLPartitionedZoneHeaderArrays( ___1397&      file, ___1386 const&    ___1385, ___3943&              ___3942, ___4634               zoneOffset, ___4350                varOffset, ___4350                ___2841, VarZoneMinMaxArray const& ASSERT_ONLY(vzMinMax), ___4380 const& vzFieldDataTypes, ZoneMetadata&             zoneMetadata) { REQUIRE(file.___2039()); REQUIRE(___2841>0); REQUIRE(IMPLICATION(vzMinMax.empty(), varOffset == 0)); REQUIRE(IMPLICATION(!vzMinMax.empty(), size_t(varOffset+___2841) <= vzMinMax.size())); REQUIRE(zoneMetadata.isSZL()); REQUIRE(zoneMetadata.getNumPartitions()>1); ___372 ___2037 = ___4224; ___4634 const zone = zoneMetadata.zone(); ___2088::___2978 const numPartitions = zoneMetadata.getNumPartitions(); try { ___2037 = ___2037 && zoneMetadata.m_ptnMetadata.alloc(numPartitions); ___2037 = ___2037 && zoneMetadata.m_ptnNumCszs.alloc(numPartitions); ___2037 = ___2037 && zoneMetadata.m_ptnNumNszs.alloc(numPartitions); ___2037 = ___2037 && zoneMetadata.m_ptnFirstNode.alloc(numPartitions); ___2037 = ___2037 && zoneMetadata.m_ptnFirstCell.alloc(numPartitions); ___2037 = ___2037 && readHeaderTagArray<uint32_t>( file, ___3942, PARTITION_FILE_NUM_TAG, 0, numPartitions, zoneMetadata.m_ptnFileNums, readValueArray<uint32_t, false, 0>, IODescription(PARTITION_FILE_NUM_DESCRIPTION,IODescription::NO_VAR,zone)); ___2037 = ___2037 && readHeaderTagArray<uint64_t>( file, ___3942, PARTITION_FILE_LOC_TAG, 0, numPartitions, zoneMetadata.m_ptnHeaderFileLocs, readValueArray<uint64_t, true, 0>, IODescription(PARTITION_FILE_LOC_DESCRIPTION,IODescription::NO_VAR,zone)); if (___3892(zoneMetadata.getZoneType())) { ___2037 = ___2037 && zoneMetadata.m_ptnNumCells.alloc(numPartitions) && zoneMetadata.m_ptnNumNodes.alloc(numPartitions);
___2238<uint32_t> tempArray; ___2037 = ___2037 && readHeaderTagArray<uint32_t>( file, ___3942, PARTITION_NUM_CELLS_TAG, 0, numPartitions, tempArray, readValueArray<uint32_t, false, 0>, IODescription(PARTITION_NUM_CELLS_DESCRIPTION, IODescription::NO_VAR, zone)); for (___2088::___2978 i = 0; ___2037 && i < numPartitions; ++i) zoneMetadata.m_ptnNumCells[i] = tempArray[i]; ___2037 = ___2037 && readHeaderTagArray<uint32_t>( file, ___3942, PARTITION_NUM_NODES_TAG, 0, numPartitions, tempArray, readValueArray<uint32_t, false, 0>, IODescription(PARTITION_NUM_NODES_DESCRIPTION, IODescription::NO_VAR, zone)); for (___2088::___2978 i = 0; ___2037 && i < numPartitions; ++i) zoneMetadata.m_ptnNumNodes[i] = tempArray[i]; tempArray.___935(); if ( ___2037 ) { ___463 totalNumCells = 0; ___2716 totalNumNodes = 0; for ( ___2088::___2978 ___2975 = 0; ___2975 < numPartitions; ___2975++ ) { ___463 const ___2779 = zoneMetadata.m_ptnNumCells[___2975]; zoneMetadata.m_ptnNumCszs[___2975] = getNumSzFromNumItems(___2779); zoneMetadata.m_ptnFirstCell[___2975] = totalNumCells; totalNumCells += ___2779; ___2716 const ___2819 = zoneMetadata.m_ptnNumNodes[___2975]; zoneMetadata.m_ptnNumNszs[___2975] = getNumSzFromNumItems(___2819); zoneMetadata.m_ptnFirstNode[___2975] = totalNumNodes; totalNumNodes += ___2819; } if ( totalNumCells != zoneMetadata.___1764() ) ___2037 = ___1184("Mismatch of number of cell between zone and partitions in partitioned zone %" PRIu64 ".", uint64_t(zone+1)); else if ( totalNumNodes != zoneMetadata.___1766() ) ___2037 = ___1184("Mismatch of number of node between zone and partitions in partitioned zone %" PRIu64 ".", uint64_t(zone+1)); } } else { ___476(supportedOrderedVolumeZoneType(zoneMetadata.getZoneType(), zoneMetadata.getZoneIJK())); ___476(zoneMetadata.m_ptnNumNodes.empty()); ___476(zoneMetadata.m_ptnNumCells.empty()); ___2037 = ___2037 && zoneMetadata.m_ptnNumNodes.alloc(numPartitions); ___2037 = ___2037 && zoneMetadata.m_ptnNumCells.alloc(numPartitions); ___2238<uint64_t> ptnMinNodeNumbers; ___2238<uint64_t> ptnMaxNodeNumbers; ___2037 = ___2037 && readHeaderTagArray<uint64_t>( file, ___3942, PARTITION_MIN_NODE_NUMBERS_TAG, 0, numPartitions, ptnMinNodeNumbers, readValueArray<uint64_t, false, 0>, IODescription(PARTITION_MIN_NODE_NUMBERS_DESCRIPTION, IODescription::NO_VAR, zone)); ___2037 = ___2037 && readHeaderTagArray<uint64_t>( file, ___3942, PARTITION_MAX_NODE_NUMBERS_TAG, 0, numPartitions, ptnMaxNodeNumbers, readValueArray<uint64_t, false, 0>, IODescription(PARTITION_MAX_NODE_NUMBERS_DESCRIPTION, IODescription::NO_VAR, zone)); ___2037 = ___2037 && zoneMetadata.m_ijkZoneInfos.alloc(numPartitions); ___2037 = ___2037 && zoneMetadata.m_ptnNodeMinIJKs.alloc(numPartitions); ___2037 = ___2037 && zoneMetadata.m_ptnNodeMaxIJKs.alloc(numPartitions); if (___2037) { ___463 totalNumCells = 0; ___2716 totalNumNodes = 0; for (___2088::___2978 ___2975 = 0; ___2975 < numPartitions; ___2975++)
{ zoneMetadata.m_ptnNodeMinIJKs[___2975] = zoneMetadata.getZoneIJK().ijkAtOffset(static_cast<___81>(ptnMinNodeNumbers[___2975])); zoneMetadata.m_ptnNodeMaxIJKs[___2975] = zoneMetadata.getZoneIJK().ijkAtOffset(static_cast<___81>(ptnMaxNodeNumbers[___2975])); ___1842 nodeDimensionIJK = zoneMetadata.m_ptnNodeMaxIJKs[___2975] - zoneMetadata.m_ptnNodeMinIJKs[___2975] + 1; IJKSubzoneInfo nodeSubzoneInfo(nodeDimensionIJK, ___1385.___1755(), ___2975, true  ); ___1842 cellDimensionIJK = nodeDimensionIJK; if (zoneMetadata.m_ptnNodeMaxIJKs[___2975].i() == zoneMetadata.getZoneIJK().i() - 1) cellDimensionIJK.setI(nodeDimensionIJK.i() - 1); if (zoneMetadata.m_ptnNodeMaxIJKs[___2975].___2103() == zoneMetadata.getZoneIJK().___2103() - 1) cellDimensionIJK.setJ(nodeDimensionIJK.___2103() - 1); if (zoneMetadata.m_ptnNodeMaxIJKs[___2975].___2132() == zoneMetadata.getZoneIJK().___2132() - 1) cellDimensionIJK.___3495(nodeDimensionIJK.___2132() - 1); IJKSubzoneInfo cellSubzoneInfo(cellDimensionIJK, ___1385.___1755(), ___2975, true); zoneMetadata.m_ijkZoneInfos[___2975] = ___1879(___2975, nodeSubzoneInfo, cellSubzoneInfo); zoneMetadata.m_ptnNumCells[___2975] = zoneMetadata.m_ijkZoneInfos[___2975].___1764(); zoneMetadata.m_ptnFirstCell[___2975] = totalNumCells; totalNumCells += zoneMetadata.m_ptnNumCells[___2975]; zoneMetadata.m_ptnNumCszs[___2975] = zoneMetadata.m_ijkZoneInfos[___2975].getNumCszs(); zoneMetadata.m_ptnNumNodes[___2975] = zoneMetadata.m_ijkZoneInfos[___2975].___1766(); zoneMetadata.m_ptnFirstNode[___2975] = totalNumNodes; totalNumNodes += zoneMetadata.m_ptnNumNodes[___2975]; zoneMetadata.m_ptnNumNszs[___2975] = zoneMetadata.m_ijkZoneInfos[___2975].getNumNszs(); zoneMetadata.addPartitionTreeItem(___2975, zoneMetadata.m_ptnNodeMinIJKs[___2975], zoneMetadata.m_ptnNodeMaxIJKs[___2975]); } if (totalNumCells != zoneMetadata.___1764()) ___2037 = ___1184("Mismatched of number of cells between zone and partitions in partitioned zone %" PRIu64 ".", uint64_t(zone + 1)); else if (totalNumNodes != zoneMetadata.___1766()) ___2037 = ___1184("Mismatched of number of nodes between zone and partitions in partitioned zone %" PRIu64 ".", uint64_t(zone + 1)); } ptnMinNodeNumbers.___935(); ptnMaxNodeNumbers.___935(); } ___2037 = ___2037 && checkArrayHeaderTag(VAR_PARTITION_MIN_MAX_TAG, ___3942, IODescription(VAR_PARTITION_MIN_MAX_DESCRIPTION,IODescription::NO_VAR,zone)); ___2037 = ___2037 && zoneMetadata.m_varPtnMinMaxFileLocs.alloc(___2841, ___330); ___2037 = ___2037 && zoneMetadata.m_varPtnMinMaxTrees.alloc(___2841); if ( ___2037 ) { size_t const headerSize = file.___2000() ? ___206 + ASCII_SPACING_LEN : 0 ; ___1391 fileLoc = ___3942[VAR_PARTITION_MIN_MAX_TAG]; zoneMetadata.m_varPtnMinMaxFileLocs[0] = fileLoc; for ( ___4350 ___4334 = 1; ___4334 < ___2841; ++___4334 ) { size_t sizePerMinMax; switch ((FieldDataType_e)vzFieldDataTypes[varOffset + ___4334][zoneOffset + zone]) { case FieldDataType_Float:
sizePerMinMax = file.___2000() ? ASCII_FLOAT_MINMAX_LEN + ASCII_SPACING_LEN : 2 * sizeof(float); break; case FieldDataType_Double: sizePerMinMax = file.___2000() ? ASCII_DOUBLE_MINMAX_LEN + ASCII_SPACING_LEN : 2 * sizeof(double); break; case FieldDataType_Int32: sizePerMinMax = file.___2000() ? ASCII_INT32_MINMAX_LEN + ASCII_SPACING_LEN : 2 * sizeof(int32_t); break; case FieldDataType_Int16: sizePerMinMax = file.___2000() ? ASCII_INT16_MINMAX_LEN + ASCII_SPACING_LEN : 2 * sizeof(int16_t); break; case FieldDataType_Byte: case ___1363: sizePerMinMax = file.___2000() ? ASCII_UINT8_MINMAX_LEN + ASCII_SPACING_LEN : 2 * sizeof(uint8_t); break; default: ___476(___1303); sizePerMinMax = 0; break; } fileLoc += headerSize + numPartitions * sizePerMinMax; zoneMetadata.m_varPtnMinMaxFileLocs[___4334] = fileLoc; } } } catch(std::bad_alloc const&) { ___2037 = ___1184("Out-of-memory error while reading partitioned zone %" PRIu64 " header.", uint64_t(zone+1)); } catch(...) { ___2037 = ___1184("Unrecoverable error while reading partitioned zone %" PRIu64 " header.", uint64_t(zone+1)); } if ( !___2037 ) { zoneMetadata.m_ptnFileNums.___935(); zoneMetadata.m_ptnHeaderFileLocs.___935(); zoneMetadata.m_ptnNumCells.___935(); zoneMetadata.m_ptnNumNodes.___935(); zoneMetadata.m_ptnFirstCell.___935(); zoneMetadata.m_ptnFirstNode.___935(); zoneMetadata.m_ptnNumCszs.___935(); zoneMetadata.m_ptnNumNszs.___935(); zoneMetadata.m_ptnNodeMinIJKs.___935(); zoneMetadata.m_ptnNodeMaxIJKs.___935(); zoneMetadata.m_varPtnMinMaxFileLocs.___935(); zoneMetadata.m_varPtnMinMaxTrees.___935(); } ENSURE(VALID_BOOLEAN(___2037)); ENSURE(IMPLICATION(___2037, zoneMetadata.m_ptnFileNums.size()==size_t(numPartitions))); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnFileNums.empty())); ENSURE(IMPLICATION(___2037, zoneMetadata.m_ptnHeaderFileLocs.size()==size_t(numPartitions) && zoneMetadata.m_ptnHeaderFileLocs[0] != ___330 && zoneMetadata.m_ptnHeaderFileLocs[numPartitions/2] != ___330 && zoneMetadata.m_ptnHeaderFileLocs[numPartitions-1] != ___330)); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnHeaderFileLocs.empty())); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnNumCells.empty())); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnNumNodes.empty())); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnFirstCell.empty())); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnFirstNode.empty())); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnNodeMinIJKs.empty())); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnNodeMaxIJKs.empty())); if (___3892(zoneMetadata.getZoneType())) { ENSURE(IMPLICATION(___2037, zoneMetadata.m_ptnNumCells.size() == size_t(numPartitions) && zoneMetadata.m_ptnNumCells[0] > 0 && zoneMetadata.m_ptnNumCells[numPartitions / 2] > 0 && zoneMetadata.m_ptnNumCells[numPartitions - 1] > 0)); ENSURE(IMPLICATION(___2037, zoneMetadata.m_ptnNumNodes.size() == size_t(numPartitions) && zoneMetadata.m_ptnNumNodes[0] > 0 && zoneMetadata.m_ptnNumNodes[numPartitions / 2] > 0 && zoneMetadata.m_ptnNumNodes[numPartitions - 1] > 0));
} else { ENSURE(IMPLICATION(___2037, zoneMetadata.m_ptnNodeMaxIJKs.size() == size_t(numPartitions))); ENSURE(IMPLICATION(___2037, zoneMetadata.m_ptnNodeMaxIJKs.size() == size_t(numPartitions) && zoneMetadata.m_ptnNodeMaxIJKs[0].blockSize() > 0 && zoneMetadata.m_ptnNodeMaxIJKs[numPartitions / 2].blockSize() > 0 && zoneMetadata.m_ptnNodeMaxIJKs[numPartitions - 1].blockSize() > 0)); } ENSURE(IMPLICATION(___2037, zoneMetadata.m_ptnNumCszs.size()==size_t(numPartitions) && zoneMetadata.m_ptnNumCszs[0] > 0 && zoneMetadata.m_ptnNumCszs[numPartitions/2] > 0 && zoneMetadata.m_ptnNumCszs[numPartitions-1] > 0)); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnNumCszs.empty())); ENSURE(IMPLICATION(___2037, zoneMetadata.m_ptnNumNszs.size()==size_t(numPartitions) && zoneMetadata.m_ptnNumNszs[0] > 0 && zoneMetadata.m_ptnNumNszs[numPartitions/2] > 0 && zoneMetadata.m_ptnNumNszs[numPartitions-1] > 0)); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_ptnNumNszs.empty())); ENSURE(IMPLICATION(___2037, zoneMetadata.m_varPtnMinMaxFileLocs.size() == size_t(___2841) && zoneMetadata.m_varPtnMinMaxFileLocs[0] != ___330 && zoneMetadata.m_varPtnMinMaxFileLocs[___2841/2] != ___330 && zoneMetadata.m_varPtnMinMaxFileLocs[___2841-1] != ___330)); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_varPtnMinMaxFileLocs.empty())); ENSURE(IMPLICATION(___2037, zoneMetadata.m_varPtnMinMaxTrees.size()==size_t(___2841))); ENSURE(IMPLICATION(!___2037, zoneMetadata.m_varPtnMinMaxTrees.empty())); return ___2037; } } ___372 readZoneHeaders( ___1397&             file, ___1386 const&           ___1385, ___4634                      zoneOffset, ___4634                      expectedZone, ___4350                       varOffset, ___4350                       numFileVars, VarZoneMinMaxArray const&        vzMinMax, ___4380 const& vzFieldDataType, ZoneMetadata&                    zoneMetadata) { ___3943 ___3942; ___372 ___2037 = readZoneHeaderTags(file, expectedZone, ___3942); ___2037 = ___2037 && applyZoneHeaderScalarTagValues(___3942, zoneMetadata); if (zoneMetadata.isSZL()) { if (___2037) { if (zoneMetadata.getNumPartitions() == 1) { ___2037 = ___2037 && readSZLNonPartitionedZoneHeaderArrays( file, ___1385, ___3942, zoneOffset, varOffset, numFileVars, vzMinMax, vzFieldDataType, zoneMetadata); } else { ___2037 = ___2037 && readSZLPartitionedZoneHeaderArrays( file, ___1385, ___3942, zoneOffset, varOffset, numFileVars, vzMinMax, vzFieldDataType, zoneMetadata); } } ___476(IMPLICATION(___2037 && zoneMetadata.getZoneType() == ___4702, !zoneMetadata.m_ijkZoneInfos.empty())); } else { ___2037 = ___2037 && readNonSZLZoneHeaderArrays( file, ___3942, numFileVars, zoneMetadata); } return ___2037; } namespace { ___372 readUserFaceNeighborHeader( ___1397& file, ___4634          expectedZone) { REQUIRE(expectedZone >= 0); REQUIRE(file.___2000()); ___372 ___2037 = (readAndVerifyValue<uint32_t, false>( file, SZPLT_USER_FACE_NEIGHBOR_MARKER, IODescription(SZPLT_USER_FACE_NEIGHBOR_MARKER_DESCRIPTION)) &&
readAndVerifyValue<uint32_t, false>( file, expectedZone + 1, IODescription(SZPLT_ZONE_NUM_DESCRIPTION))); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } ___372 readFaceNeighbors( ___1397& file, ___4634          expectedZone, uint64_t&            numValues, ___1963&          ___4297) { ___372 ___2037 = ___4224; if (file.___2000()) ___2037 = readUserFaceNeighborHeader(file, expectedZone); ___2037 = ___2037 && readValue<uint64_t, false>(file, numValues, IODescription(SZPLT_USER_FACE_NEIGHBORS_COUNT_DESCRIPTION)); if (numValues) ___2037 = ___2037 && readValueArray<int32_t, false, 0>(file, 0, numValues, ___4297, IODescription(SZPLT_USER_FACE_NEIGHBORS_DESCRIPTION)); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } namespace { ___372 readPartitionHeaderTags( ___1397&     file, ___4634              expectedZone, ___2088::___2978 expectedPartition, ___3943&             ___3942) { ___372 ___2037 = ___4224; REQUIRE(file.___2039()); REQUIRE(expectedZone>=0); if ( file.___2000() ) { ___2037 = ___2037 && readAndVerifyValue<uint32_t, false>(file, SZPLT_PARTITION_MARKER, IODescription(SZPLT_PARTITION_MARKER_DESCRIPTION)); ___2037 = ___2037 && readAndVerifyValue<uint32_t, false>(file, uint32_t(expectedPartition + 1), IODescription(SZPLT_PARTITION_NUM_DESCRIPTION, IODescription::NO_VAR, expectedZone)); } static ___3940 tagDescriptionMap = PARTITION_TAG_DESCRIPTIONS_MAP_INITIALIZER; ___2037 = ___2037 && readTagList(file, tagDescriptionMap, ___3942); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 applyPartitionHeaderScalarTagValues( ___3943&       ___3942, PartitionMetadata& partitionMetadata) { ___372 ___2037 = ___4224; if ( ___2037 ) { try { partitionMetadata.m_numRefPartitions = ___2088::___2978(___3942[NUM_REF_PARTITIONS_TAG]); } catch(std::bad_alloc const&) { ___2037 = ___1184("Out-of-memory error while retrieving partition tags."); } catch(...) { ___2037 = ___1184("Unrecoverable error while retrieving partition tags."); } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 readVarLocations( ___1397&             file, ___1386 const&           ___1385, ___3943&                     ___3942, ___4350                       varOffset, ___4350                       ___2841, ___2088::SubzoneOffset_t     numCszsInPartition, ___2088::SubzoneOffset_t     numNszsInPartition, PartitionMetadata&               partitionMetadata, ___4634                      zone, ___2088::___2978         ___2975, ___4380 const& vzFieldDataTypes) { ___372 ___2037 = readHeaderTagArray<uint64_t>( file, ___3942, ___4340, 0, ___2841, partitionMetadata.m_nszMinMaxFileLocs, readValueArray<uint64_t, true, 0>, IODescription(VAR_FILE_LOC_DESCRIPTION, IODescription::NO_VAR, zone, ___2975)); ___2037 = ___2037 && partitionMetadata.m_cszMinMaxFileLocs.alloc(___2841); ___2037 = ___2037 && partitionMetadata.m_szDataStartFileLocs.alloc(___2841); if (___2037) { for (___4350 ___4334 = 0; ___4334 < ___2841; ++___4334)
{ size_t const nszMinMaxBlockSize = minMaxBlockSize((FieldDataType_e)vzFieldDataTypes[varOffset + ___4334][zone], numNszsInPartition, ___1385.___2000() ? true : false); size_t const cszMinMaxBlockSize = minMaxBlockSize((FieldDataType_e)vzFieldDataTypes[varOffset + ___4334][zone], numCszsInPartition, ___1385.___2000() ? true : false); if (partitionMetadata.m_nszMinMaxFileLocs[___4334] != ___330) { partitionMetadata.m_cszMinMaxFileLocs[___4334] = partitionMetadata.m_nszMinMaxFileLocs[___4334] + nszMinMaxBlockSize; partitionMetadata.m_szDataStartFileLocs[___4334] = partitionMetadata.m_cszMinMaxFileLocs[___4334] + cszMinMaxBlockSize; } else { partitionMetadata.m_cszMinMaxFileLocs[___4334] = ___330; partitionMetadata.m_szDataStartFileLocs[___4334] = ___330; } } } return ___2037; } ___372 readOrderedPartitionHeaderArrays( ___1397&             file, ___1386 const&           ___1385, ___3943&                     ___3942, ___4350                       varOffset, ___4350                       ___2841, ___2088::SubzoneOffset_t     numCszsInPartition, ___2088::SubzoneOffset_t     numNszsInPartition, PartitionMetadata&               partitionMetadata, ___4634                      zone, ___2088::___2978         ___2975, ___4380 const& vzFieldDataTypes) { REQUIRE(file.___2039()); REQUIRE(___2841>0); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(numCszsInPartition-1)); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(numNszsInPartition-1)); REQUIRE(zone >= 0); REQUIRE(VALID_ITEM_ADDRESS_PARTITION(___2975)); ___372 ___2037 = ___4224; ___2037 = ___2037 && readVarLocations(file, ___1385, ___3942, varOffset, ___2841, numCszsInPartition, numNszsInPartition, partitionMetadata, zone, ___2975, vzFieldDataTypes); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 readFEPartitionHeaderArrays( ___1397&             file, ___1386 const&           ___1385, ___3943&                     ___3942, ___4350                       varOffset, ___4350                       ___2841, ___2088::SubzoneOffset_t     numCszsInPartition, ___2088::SubzoneOffset_t     numNszsInPartition, PartitionMetadata&               partitionMetadata, ___4634                      zone, ___2088::___2978         ___2975, ___4380 const& vzFieldDataTypes) { REQUIRE(file.___2039()); REQUIRE(___2841>0); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(numCszsInPartition-1)); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(numNszsInPartition-1)); REQUIRE(zone>=0); REQUIRE(VALID_ITEM_ADDRESS_PARTITION(___2975)); ___372 ___2037 = ___4224; try { if (___1385.___842() != ___846) { if (___3942.find(NSZ_CONNECT_FILE_LOC_TAG) != ___3942.end() && ___3942.find(NSZ_CONNECT_FILE_LOC_TAG)->second != ___330) { ___2037 = ___2037 && readHeaderTagArray<uint64_t>( file, ___3942, CSZ_CONNECT_FILE_LOC_TAG, 0, numCszsInPartition, partitionMetadata.m_cszConnectivityFileLocs, readValueArray<uint64_t, true, 0>,
IODescription(CSZ_CONNECT_FILE_LOC_DESCRIPTION, IODescription::NO_VAR, zone, ___2975)); ___2037 = ___2037 && readHeaderTagArray<uint64_t>( file, ___3942, NSZ_CONNECT_FILE_LOC_TAG, 0, numNszsInPartition, partitionMetadata.m_nszConnectivityFileLocs, readValueArray<uint64_t, true, 0>, IODescription(NSZ_CONNECT_FILE_LOC_DESCRIPTION, IODescription::NO_VAR, zone, ___2975)); } else { ___476(___3942.find(CSZ_CONNECT_FILE_LOC_TAG) != ___3942.end() && ___3942.find(CSZ_CONNECT_FILE_LOC_TAG)->second == ___330); ___476(___3942.find(NSZ_CONNECT_FILE_LOC_TAG) != ___3942.end() && ___3942.find(NSZ_CONNECT_FILE_LOC_TAG)->second == ___330); } } ___2037 = ___2037 && readVarLocations(file, ___1385, ___3942, varOffset, ___2841, numCszsInPartition, numNszsInPartition, partitionMetadata, zone, ___2975, vzFieldDataTypes); if (___3942[NUM_REF_PARTITIONS_TAG] > 0) ___2037 = ___2037 && readHeaderTagArray<uint32_t>( file, ___3942, REF_PARTITIONS_TAG, 0, partitionMetadata.m_numRefPartitions, partitionMetadata.m_refPartitions, readValueArray<uint32_t, false, 0>, IODescription(REF_PARTITIONS_DESCRIPTION, IODescription::NO_VAR, zone, ___2975)); if (___1385.___842() != ___846) { if (___3942.find(NSZ_CONNECT_FILE_LOC_TAG) != ___3942.end() && ___3942.find(NSZ_CONNECT_FILE_LOC_TAG)->second != ___330) { ___2037 = ___2037 && readHeaderTagArray<uint16_t>( file, ___3942, NUM_REF_NODE_SUBZONES_TAG, 0, numCszsInPartition, partitionMetadata.m_cszNumRefNszs, readValueArray<uint16_t, false, 0>, IODescription(NUM_REF_NODE_SUBZONES_DESCRIPTION, IODescription::NO_VAR, zone, ___2975)); ___2037 = ___2037 && readHeaderTagArray<uint16_t>( file, ___3942, NUM_REF_CELL_SUBZONES_TAG, 0, numNszsInPartition, partitionMetadata.m_nszNumRefCszs, readValueArray<uint16_t, false, 0>, IODescription(NUM_REF_CELL_SUBZONES_DESCRIPTION, IODescription::NO_VAR, zone, ___2975)); ___2037 = ___2037 && readHeaderTagArray<uint8_t>( file, ___3942, CELL_SUBZONE_INCLUDES_PARTITIONS_TAG, 0, (numCszsInPartition + 7) / 8, partitionMetadata.m_cszIncludesPtn, readValueArray<uint8_t, true, 0>, IODescription(CELL_SUBZONE_INCLUDES_PARTITIONS_DESCRIPTION, IODescription::NO_VAR, zone, ___2975)); ___2037 = ___2037 && readHeaderTagArray<uint8_t>( file, ___3942, NODE_SUBZONE_INCLUDES_PARTITIONS_TAG, 0, (numNszsInPartition + 7) / 8, partitionMetadata.m_nszIncludesPtn, readValueArray<uint8_t, true, 0>, IODescription(NODE_SUBZONE_INCLUDES_PARTITIONS_DESCRIPTION, IODescription::NO_VAR, zone, ___2975)); } else { ___476(___3942.find(NUM_REF_NODE_SUBZONES_TAG) != ___3942.end() && ___3942.find(NUM_REF_NODE_SUBZONES_TAG)->second == ___330); ___476(___3942.find(NUM_REF_CELL_SUBZONES_TAG) != ___3942.end() && ___3942.find(NUM_REF_CELL_SUBZONES_TAG)->second == ___330); ___476(___3942.find(CELL_SUBZONE_INCLUDES_PARTITIONS_TAG) != ___3942.end() && ___3942.find(CELL_SUBZONE_INCLUDES_PARTITIONS_TAG)->second == ___330);
___476(___3942.find(NODE_SUBZONE_INCLUDES_PARTITIONS_TAG) != ___3942.end() && ___3942.find(NODE_SUBZONE_INCLUDES_PARTITIONS_TAG)->second == ___330); } } } catch(std::bad_alloc const&) { ___2037 = ___1184("Out-of-memory error while reading partition %" PRIu64 " header of zone %" PRIu64 ".", uint64_t(___2975+1), uint64_t(zone+1)); } catch(...) { ___2037 = ___1184("Unrecoverable error while reading partition %" PRIu64 " header of zone %" PRIu64 ".", uint64_t(___2975+1), uint64_t(zone+1)); } if ( !___2037 ) { partitionMetadata.m_nszConnectivityFileLocs.___935(); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } ___372 readPartitionHeader( ___1397&             file, ___1386 const&           ___1385, ___4350                       numFileVars, ___4350                       targetBaseVarOffset, ___4634                      fileInfoZoneOffset, ___2088::___2978         ___2975, ZoneMetadata const&              zoneMetadata, ___4380 const& vzFieldDataType, PartitionMetadata&               partitionMetadata) { ___3943 ___3942; ___372 ___2037 = readPartitionHeaderTags(file, fileInfoZoneOffset, ___2975, ___3942); ___2037 = ___2037 && applyPartitionHeaderScalarTagValues(___3942, partitionMetadata); if (zoneMetadata.getZoneType() == ___4702) ___2037 = ___2037 && readOrderedPartitionHeaderArrays( file, ___1385, ___3942, targetBaseVarOffset, numFileVars, zoneMetadata.getNumCszsInPartition(___2975), zoneMetadata.getNumNszsInPartition(___2975), partitionMetadata, fileInfoZoneOffset, ___2975, vzFieldDataType); else ___2037 = ___2037 && readFEPartitionHeaderArrays( file, ___1385, ___3942, targetBaseVarOffset, numFileVars, zoneMetadata.getNumCszsInPartition(___2975), zoneMetadata.getNumNszsInPartition(___2975), partitionMetadata, fileInfoZoneOffset, ___2975, vzFieldDataType); return ___2037; } namespace { ___372 readCompressedRefSzAddresses( ___1397&         fileWrapper, ___2088::___2978     numRefPtns, ___2088::___2978     curPartition, PartitionArray const&        refPartitions, RefSubzoneOffset_t           numRefSzs, ___2088::SubzoneAddress* refSubzoneAddresses, IODescription const&         ioDescription) { REQUIRE(fileWrapper.___2039()); REQUIRE(numRefPtns != 1); REQUIRE(refPartitions.size() == numRefPtns); REQUIRE(VALID_REF(refSubzoneAddresses) && "refSubzoneAddresses size is numRefSzs"); REQUIRE(ioDescription.___2065()); ___372 ___2037 = ___4224; static size_t const MAX_BYTES_FOR_STACK_REF_PTN_OFFSETS = 1024; uint8_t  stackRefPtnOffsets[MAX_BYTES_FOR_STACK_REF_PTN_OFFSETS]; uint8_t* refPtnOffsets = NULL; size_t numBytesForRefPtnOffsets = 0; if ( numRefPtns != 0 ) { if ( numRefPtns <= MAX_ENTRIES_FOR_2_BIT_COMPRESSION ) numBytesForRefPtnOffsets = numBytesFor2BitCompression(numRefSzs); else if ( numRefPtns <= MAX_ENTRIES_FOR_4_BIT_COMPRESSION ) numBytesForRefPtnOffsets = numBytesFor4BitCompression(numRefSzs);
else if ( numRefPtns <= MAX_ENTRIES_FOR_8_BIT_COMPRESSION ) numBytesForRefPtnOffsets = numRefSzs; else numBytesForRefPtnOffsets = numRefSzs*sizeof(uint16_t); if ( numBytesForRefPtnOffsets > MAX_BYTES_FOR_STACK_REF_PTN_OFFSETS ) { refPtnOffsets = (uint8_t*)malloc(numBytesForRefPtnOffsets); if ( refPtnOffsets == NULL ) ___2037 = ___1184("Cannot allocate memory for reading referenced subzone addresses"); } else refPtnOffsets = stackRefPtnOffsets; if ( numRefPtns <= MAX_ENTRIES_FOR_2_BIT_COMPRESSION ) ___2037 = ___2037 && readValues<uint8_t, true, 0>(fileWrapper, numBytesForRefPtnOffsets, refPtnOffsets, IODescription(SZ_CONNECT_REF_PTN_OFFSET_2BIT_ARRAY_DESCRIPTION)); else if ( numRefPtns <= MAX_ENTRIES_FOR_4_BIT_COMPRESSION ) ___2037 = ___2037 && readValues<uint8_t, true, 0>(fileWrapper, numBytesForRefPtnOffsets, refPtnOffsets, IODescription(SZ_CONNECT_REF_PTN_OFFSET_4BIT_ARRAY_DESCRIPTION)); else if ( numRefPtns <= MAX_ENTRIES_FOR_8_BIT_COMPRESSION ) ___2037 = ___2037 && readValues<uint8_t, true, 0>(fileWrapper, numBytesForRefPtnOffsets, refPtnOffsets, IODescription(SZ_CONNECT_REF_PTN_OFFSET_8BIT_ARRAY_DESCRIPTION)); else ___2037 = ___2037 && readValues<uint16_t, true, 0>(fileWrapper, numRefSzs, (uint16_t*)refPtnOffsets, IODescription(SZ_CONNECT_REF_PTN_OFFSET_16BIT_ARRAY_DESCRIPTION)); } ___476(sizeof(___2088::SubzoneAddress)>sizeof(uint32_t)); uint32_t * const szOffsetArray = (uint32_t*)refSubzoneAddresses; ___2037 = ___2037 && readValues<uint32_t, false, 1>(fileWrapper, numRefSzs, szOffsetArray, ioDescription); if ( ___2037 ) { if ( numRefPtns == 0 ) { ___2088::SubzoneAddress* szAddressPtr = &refSubzoneAddresses[numRefSzs]; uint32_t* szOffsetPtr = &szOffsetArray[numRefSzs]; while ( szAddressPtr > refSubzoneAddresses  ) { ___2088::SubzoneOffset_t const subzoneOffset = *(--szOffsetPtr); *(--szAddressPtr) = ___2088::SubzoneAddress(curPartition,subzoneOffset); } ___476(szAddressPtr==refSubzoneAddresses && szOffsetPtr==szOffsetArray); } else if ( numRefPtns <= MAX_ENTRIES_FOR_2_BIT_COMPRESSION ) { ___2088::SubzoneAddress* szAddressPtr = &refSubzoneAddresses[numRefSzs]; uint32_t* szOffsetPtr = &szOffsetArray[numRefSzs]; RefSubzoneOffset_t refSz = numRefSzs; while ( szAddressPtr > refSubzoneAddresses  ) { ___2088::SubzoneOffset_t const subzoneOffset = *(--szOffsetPtr); RefSubzoneOffset_t const           refPtnOffset = getValueFrom2BitCompressedArray(--refSz, refPtnOffsets); ___2088::SubzoneOffset_t const ___2975 = refPartitions[refPtnOffset]; *(--szAddressPtr) = ___2088::SubzoneAddress(___2975,subzoneOffset); } ___476(szAddressPtr==refSubzoneAddresses && szOffsetPtr==szOffsetArray && refSz==0); } else if ( numRefPtns <= MAX_ENTRIES_FOR_4_BIT_COMPRESSION ) { ___2088::SubzoneAddress* szAddressPtr = &refSubzoneAddresses[numRefSzs]; uint32_t* szOffsetPtr = &szOffsetArray[numRefSzs]; RefSubzoneOffset_t refSz = numRefSzs; while ( szAddressPtr > refSubzoneAddresses  ) { ___2088::SubzoneOffset_t const subzoneOffset = *(--szOffsetPtr); RefSubzoneOffset_t const           refPtnOffset = getValueFrom4BitCompressedArray(--refSz, refPtnOffsets);
___2088::SubzoneOffset_t const ___2975 = refPartitions[refPtnOffset]; *(--szAddressPtr) = ___2088::SubzoneAddress(___2975,subzoneOffset); } ___476(szAddressPtr==refSubzoneAddresses && szOffsetPtr==szOffsetArray && refSz==0); } else if ( numRefPtns <= MAX_ENTRIES_FOR_8_BIT_COMPRESSION ) { ___2088::SubzoneAddress* szAddressPtr = &refSubzoneAddresses[numRefSzs]; uint32_t* szOffsetPtr = &szOffsetArray[numRefSzs]; uint8_t* refPtnOffsetPtr = &refPtnOffsets[numRefSzs]; while ( szAddressPtr > refSubzoneAddresses  ) { ___2088::SubzoneOffset_t const szOffset = *(--szOffsetPtr); RefSubzoneOffset_t const           refPtnOffset = *(--refPtnOffsetPtr); ___2088::SubzoneOffset_t const ___2975 = refPartitions[refPtnOffset]; *(--szAddressPtr) = ___2088::SubzoneAddress(___2975,szOffset); } ___476(szAddressPtr==refSubzoneAddresses && szOffsetPtr==szOffsetArray && refPtnOffsetPtr==refPtnOffsets); } else { ___2088::SubzoneAddress* szAddressPtr = &refSubzoneAddresses[numRefSzs]; uint32_t* szOffsetPtr = &szOffsetArray[numRefSzs]; uint16_t* refPtnOffsetPtr = &((uint16_t*)refPtnOffsets)[numRefSzs]; while ( szAddressPtr > refSubzoneAddresses  ) { ___2088::SubzoneOffset_t const szOffset = *(--szOffsetPtr); RefSubzoneOffset_t const           refPtnOffset = *(--refPtnOffsetPtr); ___2088::SubzoneOffset_t const ___2975 = refPartitions[refPtnOffset]; *(--szAddressPtr) = ___2088::SubzoneAddress(___2975,szOffset); } ___476(szAddressPtr==refSubzoneAddresses && szOffsetPtr==szOffsetArray && refPtnOffsetPtr==(uint16_t*)refPtnOffsets); } } if ( numBytesForRefPtnOffsets > MAX_BYTES_FOR_STACK_REF_PTN_OFFSETS ) free(refPtnOffsets); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } ___372 readCszConnectivity( ___1397&         fileWrapper, ___1386 const&       ___1385, ZoneMetadata const&          zoneMetadata, ___2088::___2978     curPartition, ___2088::SubzoneOffset_t cszOffset, CszConnectivity&             cszConnectivity) { REQUIRE(fileWrapper.___2039()); REQUIRE(cszConnectivity.empty()); RefSubzoneOffset_t numRefNszs; if (___1385.getFileVersion() == 104) numRefNszs = 0; else numRefNszs = zoneMetadata.m_ptnMetadata[curPartition].m_cszNumRefNszs[cszOffset]; ___2088::___2978 numRefPtns; if (zoneMetadata.m_ptnMetadata[curPartition].m_cszIncludesPtn.empty()) { ___476(zoneMetadata.getNumPartitions() == 1); ___476(curPartition == 0); numRefPtns = 0; } else { ___476(___1385.getFileVersion() > 104); if (bitValue(zoneMetadata.m_ptnMetadata[curPartition].m_cszIncludesPtn, cszOffset)) numRefPtns = zoneMetadata.m_ptnMetadata[curPartition].m_numRefPartitions; else numRefPtns = 0; } PartitionArray emptyPartitionList; PartitionArray const& refPartitions = (numRefPtns == 0) ? emptyPartitionList : zoneMetadata.m_ptnMetadata[curPartition].m_refPartitions; ___476(refPartitions.size() == size_t(numRefPtns)); ___2088::ItemOffset_t ___2779; if (cszOffset + 1 == zoneMetadata.getNumCszsInPartition(curPartition))
___2779 = ___2088::ItemOffset_t(((zoneMetadata.m_ptnNumCells[curPartition] - 1)&___2088::MAX_ITEM_OFFSET) + 1); else ___2779 = ___2088::MAX_ITEM_OFFSET + 1; uint32_t const ___2793 = uint32_t(___2779) * uint32_t(zoneMetadata.___1765()); ___372 ___2037 = ___4224; if ( ___1385.getFileVersion() == 104 ) ___2037 = readValue<uint16_t, false>(fileWrapper, numRefNszs, IODescription(CSZ_CONNECT_NUM_REF_NSZ)); if ( ___2037 && ( numRefNszs == 0 || numRefNszs > ___2793 ) ) ___2037 = ___1184("Bad value for %s.", CSZ_CONNECT_NUM_REF_NSZ); if ( ___2037 && !cszConnectivity.alloc(___2793, numRefNszs) ) ___2037 = ___1184("Cannot allocate memory for cell connectivity (%" PRIu64 " entries, %" PRIu64 " ref subzones).", uint64_t(___2793), uint64_t(numRefNszs)); ___2037 = ___2037 && readCompressedRefSzAddresses(fileWrapper, numRefPtns, curPartition, refPartitions, numRefNszs, cszConnectivity.getRefNszArray(), IODescription(CSZ_CONNECT_REF_NSZ_ARRAY_DESCRIPTION)); if ( ___2037 ) { uint16_t* const rszOffsetArray = cszConnectivity.getRszOffsetArray(); uint16_t* const rszOffsetArrayEnd = rszOffsetArray + ___2793; if ( numRefNszs <= MAX_ENTRIES_FOR_2_BIT_COMPRESSION && ___1385.getFileVersion() > 104 ) { ___476(___2793%4==0); uint32_t const ___2777 = numBytesFor2BitCompression(___2793); uint8_t* rszCompressedPtr = ((uint8_t*)rszOffsetArrayEnd) - ___2777; ___2037 = readValues<uint8_t, true, 0>(fileWrapper, ___2777, rszCompressedPtr, IODescription(CSZ_CONNECT_REF_NSZ_OFFSET_2BIT_ARRAY_DESCRIPTION)); if ( ___2037 ) { uint16_t* rszOffsetPtr = rszOffsetArray; while ( rszOffsetPtr < rszOffsetArrayEnd ) { uint8_t const bits = *rszCompressedPtr++; *rszOffsetPtr++ = bits>>6; *rszOffsetPtr++ = (bits>>4)&0x03; *rszOffsetPtr++ = (bits>>2)&0x03; *rszOffsetPtr++ = bits&0x03; } ___476(rszOffsetPtr==rszOffsetArrayEnd && rszCompressedPtr==(uint8_t*)rszOffsetArrayEnd); } } else if ( numRefNszs <= MAX_ENTRIES_FOR_4_BIT_COMPRESSION ) { ___476(___2793%2==0); uint32_t const ___2777 = numBytesFor4BitCompression(___2793); uint8_t* rszCompressedPtr = ((uint8_t*)rszOffsetArrayEnd) - ___2777; if ( ___1385.getFileVersion() == 104 ) ___2037 = readValues<uint8_t, false, 0>(fileWrapper, ___2777, rszCompressedPtr, IODescription(CSZ_CONNECT_REF_NSZ_OFFSET_4BIT_ARRAY_DESCRIPTION)); else ___2037 = readValues<uint8_t, true, 0>(fileWrapper, ___2777, rszCompressedPtr, IODescription(CSZ_CONNECT_REF_NSZ_OFFSET_4BIT_ARRAY_DESCRIPTION)); if ( ___2037 ) { uint16_t* rszOffsetPtr = rszOffsetArray; while ( rszOffsetPtr < rszOffsetArrayEnd ) { uint8_t const bits = *rszCompressedPtr++; *rszOffsetPtr++ = bits>>4; *rszOffsetPtr++ = bits&0x0F; } ___476(rszOffsetPtr==rszOffsetArrayEnd && rszCompressedPtr==(uint8_t*)rszOffsetArrayEnd); } } else if ( numRefNszs <= MAX_ENTRIES_FOR_8_BIT_COMPRESSION ) { uint8_t* rszCompressedPtr = ((uint8_t*)rszOffsetArrayEnd) - ___2793; if ( ___1385.getFileVersion() == 104 ) ___2037 = readValues<uint8_t, false, 0>(fileWrapper, ___2793, rszCompressedPtr, IODescription(CSZ_CONNECT_REF_NSZ_OFFSET_8BIT_ARRAY_DESCRIPTION));
else ___2037 = readValues<uint8_t, true, 0>(fileWrapper, ___2793, rszCompressedPtr, IODescription(CSZ_CONNECT_REF_NSZ_OFFSET_8BIT_ARRAY_DESCRIPTION)); if ( ___2037 ) { uint16_t* rszOffsetPtr = rszOffsetArray; while ( rszOffsetPtr < rszOffsetArrayEnd ) *rszOffsetPtr++ = *rszCompressedPtr++; ___476(rszOffsetPtr==rszOffsetArrayEnd && rszCompressedPtr==(uint8_t*)rszOffsetArrayEnd); } } else { if ( ___1385.getFileVersion() == 104 ) ___2037 = readValues<uint16_t, false, 0>(fileWrapper, ___2793, &rszOffsetArray[0], IODescription(CSZ_CONNECT_REF_NSZ_OFFSET_16BIT_ARRAY_DESCRIPTION)); else ___2037 = readValues<uint16_t, true, 0>(fileWrapper, ___2793, &rszOffsetArray[0], IODescription(CSZ_CONNECT_REF_NSZ_OFFSET_16BIT_ARRAY_DESCRIPTION)); } } if ( ___2037 ) { uint8_t* offsetArray = cszConnectivity.getItemOffsetArray(); ___2037 = readValues<uint8_t, false, 0>(fileWrapper, ___2793, offsetArray, IODescription(CSZ_CONNECT_NSZ_OFFSET_ARRAY_DESCRIPTION)); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 readNszConnectivity( ___1397&     fileWrapper, ___1386 const&   ___1385, ___2088::___2978 numRefPtns, ___2088::___2978 curPartition, PartitionArray const&    refPartitions, RefSubzoneOffset_t       numRefCszs, NszConnectivity&         nszConnectivity) { REQUIRE(fileWrapper.___2039()); REQUIRE(IMPLICATION(___1385.getFileVersion() == 104, numRefPtns == 0)); REQUIRE(refPartitions.size() == numRefPtns); REQUIRE(___1385.getFileVersion() == 104 ? numRefCszs == 0 : numRefCszs>0); REQUIRE(nszConnectivity.empty()); ___372 ___2037 = ___4224; if ( ___1385.getFileVersion() == 104 ) ___2037 = readValue<uint16_t, false>(fileWrapper, numRefCszs, IODescription(NSZ_CONNECT_NUM_REF_CSZ)); if ( ___2037 && !nszConnectivity.setNumRszs(numRefCszs) ) ___2037 = ___1184("Cannot allocate memory for node connectivity referenced cell subzones (%" PRIu64 " subzones).", uint64_t(numRefCszs)); if ( ___2037 && numRefCszs > 0 ) ___2037 = ___2037 && readCompressedRefSzAddresses(fileWrapper, numRefPtns, curPartition, refPartitions, numRefCszs, &nszConnectivity.m_refCszs[0], IODescription(NSZ_CONNECT_REF_CSZS)); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } }}
