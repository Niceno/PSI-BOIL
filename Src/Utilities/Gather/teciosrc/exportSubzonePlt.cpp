#include "ThirdPartyHeadersBegin.h"
#include <float.h>
#include <algorithm>
#include <cctype>
#include <limits>
 #if defined DO_SUBZONE_HISTOGRAM || defined DO_ITEMANDSUBZONE_HISTOGRAM
#include <set>
 #endif
#include <sstream>
#include <stdexcept>
#include <string>
#include <boost/assign.hpp>
 #if !defined TECIOMPI
#include <boost/atomic.hpp>
 #endif
#include <boost/make_shared.hpp>
#include <boost/ref.hpp>
#include <boost/scoped_ptr.hpp>
#include <boost/shared_ptr.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "exportSubzonePlt.h"
#include "AltTecUtil.h"
#include "FEZoneInfo.h"
#include "fileStuff.h"
#include "FileStreamWriter.h"
#include "IJKZoneInfo.h"
#include "ItemSetIterator.h"
 #if defined DO_SUBZONE_HISTOGRAM || defined DO_ITEMANDSUBZONE_HISTOGRAM
#include "FileSystem.h"
#include "ItemAddress.h"
#include "NodeMap.h"
 #endif
#include "writeValueArray.h"
#include "ZoneInfoCache.h"
#include "zoneUtil.h"
#include "ZoneVarMetadata.h"
#include "ZoneWriterAbstract.h"
#include "ZoneWriterFactory.h"
 #define HEADER_STRING_FORMAT "%-14s"
 #define SZPLT_REVISION "$Revision: 110952 $"
namespace tecplot { namespace ___3931 { namespace { char ___847(DataFileType_e ___842) { REQUIRE(VALID_ENUM(___842, DataFileType_e)); if (___842 == ___843) return 'F'; else if (___842 == ___844) return 'G'; else return 'S'; } } ___372 ___4514( FileWriterInterface& file, char const*          ___1405, uint32_t const       fileVersion, ___372            includeRevisionNumber, uint64_t             dataSetHeaderLocation) { REQUIRE(VALID_NON_ZERO_LEN_STR(___1405) && strlen(___1405) <= 7); REQUIRE(fileVersion <= 999); ___372 ___2037 = ___4224; try { size_t const headerBufferSize = 128; char headerBuffer[headerBufferSize]; ___2037 = snprintf(headerBuffer, headerBufferSize, "#!%s %3.3" PRIu32 "%c%c", ___1405, fileVersion, file.___2000() ? 'T' : 'B', ___847(file.___842())) < static_cast<int>(headerBufferSize); std::string header(headerBuffer); if (includeRevisionNumber) header.append(" ").append(SZPLT_REVISION); ___2037 = ___2037 && file.fprintf(HEADER_STRING_FORMAT"\r\n", header.c_str()) >= SZPLT_FILE_HEADER_MIN_SIZE      && writeValue<uint64_t, true, 0>(file, ___1384, ___1383) && writeValue<uint64_t, true, 0>(file, ___893, dataSetHeaderLocation); } catch (std::bad_alloc const&) { ___2037 = ___1303; } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } namespace { ___372 writeInitialDataSetHeader( FileWriterInterface& file, ___3943 const&   headerTagMap) { ___372 ___2037 = ___4224; REQUIRE(file.___2039()); ___3940 tagDescriptionMap = DATSET_HEADER_TAG_DESCRIPTIONS_MAP_INITIALIZER; ___2037 = ___2037 && writeValue<uint16_t, false, 0>(file, ___2837, static_cast<uint16_t>(headerTagMap.size())); UInt16Array tagArray; ___2037 = ___2037 && tagArray.alloc(headerTagMap.size()); if (___2037) { size_t numTags = 0; for (___3943::const_iterator ___4312 = headerTagMap.begin(); ___4312 != headerTagMap.end(); ++___4312) tagArray[numTags++] = ___4312->first; ___2037 = ___2037 && ___4561<uint16_t, false, 0>(file, ___3941, ___2743, numTags, &tagArray[0]); } for (___3943::const_iterator ___4312 = headerTagMap.begin(); ___4312 != headerTagMap.end(); ++___4312) ___2037 = ___2037 && writeValue<uint64_t, true, 0>(file, tagDescriptionMap[___4312->first].c_str(), ___4312->second); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { ___372 writePerDataSetFileHeader( FileWriterInterface& szpltFile, ___3943&         ___3942, char const*          dataSetTitle) { REQUIRE(szpltFile.___2039()); REQUIRE(VALID_REF(dataSetTitle)); ___3942[DATA_SET_TITLE_TAG] = szpltFile.fileLoc(); uint32_t dataSetTitleLength = static_cast<uint32_t>(strlen(dataSetTitle)); ___372 ___2037 = writeValue<uint32_t, false, 0>(szpltFile, DATA_SET_TITLE_LENGTH, dataSetTitleLength) && ___4542(szpltFile, DATA_SET_TITLE_DESCRIPTION, dataSetTitle); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { ___372 ___4543( FileWriterInterface& file,
char const*          ___970, size_t               ___2810, ___3814 const&   itemNames) { REQUIRE(file.___2039()); REQUIRE(VALID_DESCRIPTION(___970)); REQUIRE(___2810>0); REQUIRE(itemNames.size() == ___2810); uint64_t totalStringListSize = 0; if (file.___2000()) totalStringListSize = ___206 + 2; for (size_t ___2083 = 0; ___2083 < ___2810; ___2083++) { totalStringListSize += itemNames[___2083].size(); if (file.___2000()) totalStringListSize += 2; else totalStringListSize += 1; } if (___970) { char ___1416[___206 + 1]; sprintf(___1416, "%sTotalSize", ___970); writeValue<uint64_t, false, 0>(file, ___1416, totalStringListSize); } else writeValue<uint64_t, false, 0>(file, NULL , totalStringListSize); ___372 ___2037 = ___4224; if (file.___2000()) { ___2037 = ___2037 && (file.fprintf("%*s\r\n", -___206, ___970) != 0); for (size_t ___2083 = 0; ___2083 < ___2810; ___2083++) ___2037 = ___2037 && (file.fprintf("%s\r\n", itemNames[___2083].c_str()) != 0); } else { for (size_t ___2083 = 0; ___2083 < ___2810; ___2083++) ___2037 = ___2037 && (file.fprintf("%s\r", itemNames[___2083].c_str()) != 0); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { ___372 ___4539( FileWriterInterface&   file, ___3943&           ___3942, ___4350 const       ___2841, ___4705 const& ___4704) { REQUIRE(file.___2039()); REQUIRE(___4704.m_varNames.size() == size_t(___2841)); ___372 ___2037 = ___4224; if (___2841 > 0) { ___3942[___4363] = file.fileLoc(); ___2037 = ___4543(file, ___4362, ___2841, ___4704.m_varNames); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { ___372 ___4541( FileWriterInterface&   file, ___3943&           ___3942, ___4634 const      ___2844, ___1390 const&    ___4627, ___4705 const& ___4704) { REQUIRE(file.___2039()); REQUIRE(___4704.m_zoneNames.size() == size_t(___2844)); ___372 ___2037 = ___4224; if (___2844 > 0) { ___3942[___4649] = file.fileLoc(); ___2037 = ___4543(file, ___4648, ___2844, ___4704.m_zoneNames); ___3942[ZONE_TYPE_FILE_LOC_TAG] = file.fileLoc(); ___2037 = ___2037 && ___4561<char, false, 0>(file, ___4692, ___2743, ___2844, &___4704.m_zoneTypes[0]); ___3942[___4608] = file.fileLoc(); ___2037 = ___2037 && ___4561<uint8_t, false, 0>(file, ___4607, ___2743, ___2844, &___4704.m_zoneFaceNeighborModes[0]); ___3942[___4674] = file.fileLoc(); ___2037 = ___2037 && ___4561<double, false, 0>(file, ___4673, ___2743, ___2844, &___4704.m_zoneSolutionTimes[0]); ___3942[___4684] = file.fileLoc(); ___2037 = ___2037 && ___4561<uint32_t, false, 0>(file, ___4683, ___2743,
___2844, &___4704.m_zoneStrandIDs[0]); ___3942[___4668] = file.fileLoc(); ___2037 = ___2037 && ___4561<int32_t, false, 0>(file, ___4667, ___2743, ___2844, &___4704.m_zoneParentZones[0]); ___3942[ZONE_IMAX_OR_NUM_NODES_FILE_LOC_TAG] = file.fileLoc(); ___2037 = ___2037 && ___4561<uint64_t, false, 0>(file, ZONE_IMAX_OR_NUM_NODES_ARRAY_DESCRIPTION, ___2743, ___2844, &___4704.m_zoneIMaxOrNumNodes[0]); ___3942[ZONE_JMAX_OR_NUM_CELLS_FILE_LOC_TAG] = file.fileLoc(); ___2037 = ___2037 && ___4561<uint64_t, false, 0>(file, ZONE_JMAX_OR_NUM_CELLS_ARRAY_DESCRIPTION, ___2743, ___2844, &___4704.m_zoneJMaxOrNumCells[0]); ___3942[ZONE_KMAX_OR_NUM_CORNERS_FILE_LOC_TAG] = file.fileLoc(); ___2037 = ___2037 && ___4561<uint64_t, false, 0>(file, ZONE_KMAX_OR_NUM_CORNERS_ARRAY_DESCRIPTION, ___2743, ___2844, &___4704.m_zoneKMaxOrNumCorners[0]); ___3942[___4672] = file.fileLoc(); ___2037 = ___2037 && ___4561<int32_t, false, 0>(file, ___4671, ___2743, ___2844, &___4704.m_zoneShareConnectivityWithZone[0]); ___3942[___4628] = file.fileLoc(); ___2037 = ___2037 && ___4561<uint64_t, true, 0>(file, ___4626, ___2743, ___2844, &___4627[0]); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { ___372 ___4540( FileWriterInterface&   file, ___3943&           ___3942, ___4350 const       ___2841, ___4634 const      ___2844, ___4705 const& ___4704) { REQUIRE(file.___2039()); if (___2844 == 0 || ___2841 == 0) return ___4224; REQUIRE(___4704.m_vzMinMaxes.size() == size_t(___2841)); REQUIRE(___4704.m_vzMinMaxes[0].size() == size_t(___2844) && ___4704.m_vzMinMaxes[___2841 / 2].size() == size_t(___2844) && ___4704.m_vzMinMaxes[___2841 - 1].size() == size_t(___2844)); REQUIRE(___4704.m_vzValueLocations.size() == size_t(___2841)); REQUIRE(___4704.m_vzValueLocations[0].size() == size_t(___2844) && ___4704.m_vzValueLocations[___2841 / 2].size() == size_t(___2844) && ___4704.m_vzValueLocations[___2841 - 1].size() == size_t(___2844)); REQUIRE(___4704.m_vzFieldDataTypes.size() == size_t(___2841)); REQUIRE(___4704.m_vzFieldDataTypes[0].size() == size_t(___2844) && ___4704.m_vzFieldDataTypes[___2841 / 2].size() == size_t(___2844) && ___4704.m_vzFieldDataTypes[___2841 - 1].size() == size_t(___2844)); REQUIRE(___4704.m_vzIsPassive.size() == size_t(___2841)); REQUIRE(___4704.m_vzIsPassive[0].size() == size_t(___2844) && ___4704.m_vzIsPassive[___2841 / 2].size() == size_t(___2844) && ___4704.m_vzIsPassive[___2841 - 1].size() == size_t(___2844)); REQUIRE(___4704.m_vzShareVarWithZone.size() == size_t(___2841)); REQUIRE(___4704.m_vzShareVarWithZone[0].size() == size_t(___2844) &&
___4704.m_vzShareVarWithZone[___2841 / 2].size() == size_t(___2844) && ___4704.m_vzShareVarWithZone[___2841 - 1].size() == size_t(___2844)); ___372 ___2037 = ___4224; ___3942[VAR_ZONE_MIN_MAX_FILE_LOC_TAG] = file.fileLoc(); bool minMaxesMustBeDouble = false; for (___4350 ___4334 = 0; !minMaxesMustBeDouble && ___4334 < ___2841; ++___4334) { for (___4634 zone = 0; !minMaxesMustBeDouble && zone < ___2844; ++zone) { FieldDataType_e ___1361 = (FieldDataType_e)___4704.m_vzFieldDataTypes[___4334][zone]; if (___1361 == FieldDataType_Double || ___1361 == FieldDataType_Int32) minMaxesMustBeDouble = true; } } for (___4350 ___4334 = 0; ___2037 && ___4334 < ___2841; ++___4334) { if (minMaxesMustBeDouble) ___2037 = ___2037 && ___4526<double>(file, VAR_ZONE_MIN_MAX_ARRAY_DESCRIPTION, ___4334, ___2844, &___4704.m_vzMinMaxes[___4334][0], ___944 / 2); else ___2037 = ___2037 && ___4526<float>(file, VAR_ZONE_MIN_MAX_ARRAY_DESCRIPTION, ___4334, ___2844, &___4704.m_vzMinMaxes[___4334][0], ___944 / 2); } ___3942[___4391] = file.fileLoc(); for (___4350 ___4334 = 0; ___4334 < ___2841; ___4334++) ___2037 = ___2037 && ___4561<uint8_t, false, 0>(file, ___4390, ___4334, ___2844, &___4704.m_vzValueLocations[___4334][0]); ___3942[___4382] = file.fileLoc(); for (___4350 ___4334 = 0; ___4334 < ___2841; ___4334++) ___2037 = ___2037 && ___4561<uint8_t, false, 0>(file, ___4381, ___4334, ___2844, &___4704.m_vzFieldDataTypes[___4334][0]); ___3942[___4385] = file.fileLoc(); for (___4350 ___4334 = 0; ___4334 < ___2841; ___4334++) ___2037 = ___2037 && ___4561<uint8_t, false, 0>(file, ___4384, ___4334, ___2844, &___4704.m_vzIsPassive[___4334][0]); ___3942[___4388] = file.fileLoc(); for (___4350 ___4334 = 0; ___4334 < ___2841; ___4334++) ___2037 = ___2037 && ___4561<int32_t, false, 0>(file, ___4387, ___4334, ___2844, &___4704.m_vzShareVarWithZone[___4334][0]); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } ___372 writeDataSetHeaders( FileWriterInterface&          szpltFile, ___372                     dataSetIsAvailable, std::string const&            dataSetTitle, ___4350                    ___2841, ___4634                   ___2844, ___3943&                  headerTagMap, ___4705 const&        ___4704, ___1390 const&           szpltZoneHeaderFileLocs, ___934& ___933) { REQUIRE(szpltFile.___2039()); if (dataSetIsAvailable) { REQUIRE(___2841>0); REQUIRE(___4704.m_varNames.size() == size_t(___2841)); REQUIRE(___4704.m_varNames[0].size() > 0 && ___4704.m_varNames[___2841 / 2].size() > 0 && ___4704.m_varNames[___2841 - 1].size() > 0); REQUIRE(___2844>0); REQUIRE(___4704.m_zoneNames.size() == size_t(___2844));
REQUIRE(___4704.m_zoneNames[0].size() > 0 && ___4704.m_zoneNames[___2844 / 2].size() > 0 && ___4704.m_zoneNames[___2844 - 1].size() > 0); REQUIRE(szpltZoneHeaderFileLocs.size() == size_t(___2844)); REQUIRE(VALID_FILE_LOC(szpltZoneHeaderFileLocs[0]) && VALID_FILE_LOC(szpltZoneHeaderFileLocs[___2844 / 2]) && VALID_FILE_LOC(szpltZoneHeaderFileLocs[___2844 - 1])); REQUIRE(___4704.m_vzMinMaxes.size() == size_t(___2841)); REQUIRE(___4704.m_vzMinMaxes[0].size() == size_t(___2844) && ___4704.m_vzMinMaxes[___2841 / 2].size() == size_t(___2844) && ___4704.m_vzMinMaxes[___2841 - 1].size() == size_t(___2844)); REQUIRE(___4704.m_vzValueLocations.size() == size_t(___2841)); REQUIRE(___4704.m_vzValueLocations[0].size() == size_t(___2844) && ___4704.m_vzValueLocations[___2841 / 2].size() == size_t(___2844) && ___4704.m_vzValueLocations[___2841 - 1].size() == size_t(___2844)); REQUIRE(___4704.m_vzValueLocations[0][0] < ___4327 && ___4704.m_vzValueLocations[___2841 / 2][___2844 / 2] < ___4327 && ___4704.m_vzValueLocations[___2841 - 1][___2844 - 1] < ___4327); REQUIRE(___4704.m_vzFieldDataTypes.size() == size_t(___2841)); REQUIRE(___4704.m_vzFieldDataTypes[0].size() == size_t(___2844) && ___4704.m_vzFieldDataTypes[___2841 / 2].size() == size_t(___2844) && ___4704.m_vzFieldDataTypes[___2841 - 1].size() == size_t(___2844)); REQUIRE(___4704.m_vzFieldDataTypes[0][0] < ___1367 && ___4704.m_vzFieldDataTypes[___2841 / 2][___2844 / 2] < ___1367 && ___4704.m_vzFieldDataTypes[___2841 - 1][___2844 - 1] < ___1367); } ___372 ___2037 = ___4224; try { uint64_t initialFileHeaderLoc = szpltFile.fileLoc(); ___2037 = ___2037 && writeInitialDataSetHeader(szpltFile, headerTagMap); ___2037 = ___2037 && writePerDataSetFileHeader(szpltFile, headerTagMap, dataSetTitle.c_str()); ___2037 = ___2037 && ___4541(szpltFile, headerTagMap, ___2844, szpltZoneHeaderFileLocs, ___4704); ___2037 = ___2037 && ___4539(szpltFile, headerTagMap, ___2841, ___4704); ___2037 = ___2037 && ___4540(szpltFile, headerTagMap, ___2841, ___2844, ___4704); uint64_t finalFileLoc = szpltFile.fileLoc(); ___2037 = ___2037 && szpltFile.___3457(initialFileHeaderLoc); ___2037 = ___2037 && writeInitialDataSetHeader(szpltFile, headerTagMap); ___2037 = ___2037 && szpltFile.___3457(finalFileLoc);
 #ifdef PROFILE_FILE_ACCESS
if (___2037) { FileStreamWriter* fileWriter = dynamic_cast<FileStreamWriter*>(&szpltFile); if (fileWriter) ___933.___7(fileWriter->statistics().___2778); }
 #else
___4276(___933);
 #endif
} catch(std::bad_alloc const&) { ___2037 = ___1184("Out of memory while writing file header."); } catch(...) { ___2037 = ___1184("Unrecoverable error while writing file header."); } return ___2037; } ___372 ___4482( FileWriterInterface& file, uint32_t             numAuxData) { REQUIRE(file.___2039()); ___372 ___2037 = ___4224; if (file.___2000()) ___2037 = writeValue<uint32_t, false, 0>(file, SZPLT_AUX_DATA_MARKER_DESCRIPTION, SZPLT_AUX_DATA_MARKER); ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, ___233, numAuxData); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 writeAuxDataItem( FileWriterInterface& file, AuxDataLocation_e    auxDataLocation, ___1170           auxDataEntity, char const*          itemName, AuxDataType_e        itemType, char const*          itemValueString) { return writeValue<uint8_t, false, 0>(file, ___252, static_cast<uint8_t>(auxDataLocation)) && writeValue<uint32_t, false, 0>(file, ___239, static_cast<uint32_t>(auxDataEntity)) && writeValue<uint32_t, false, 0>(file, ___262, static_cast<uint32_t>(strlen(itemName))) && ___4542(file, ___261, itemName) && writeValue<uint8_t, false, 0>(file, ___268, static_cast<uint8_t>(itemType)) && writeValue<uint32_t, false, 0>(file, ___272, static_cast<uint32_t>(strlen(itemValueString))) && ___4542(file, ___271, itemValueString); } namespace { uint32_t countRetainedAuxDataItems(___264 auxData, ___37& ___36) { uint32_t ___3356 = 0; if (auxData) { int32_t ___2810 = ___36.___247(auxData); for (int32_t index = 1; index <= ___2810; ++index) { char* itemName = 0; ___90 itemValue = 0; AuxDataType_e itemType; ___372 ___3359; ___36.___243(auxData, index, &itemName, &itemValue, &itemType, &___3359); if (___3359) ++___3356; ___36.___3815(&itemName); ___36.___3815(reinterpret_cast<char**>(&itemValue)); } } return ___3356; } uint32_t countAuxData( ___37&      ___36, ItemSetIterator& varIter, ItemSetIterator& zoneIter) { uint32_t numAuxData = 0; if (___36.___894()) { numAuxData = countRetainedAuxDataItems(___36.___235(), ___36); varIter.reset(); while (varIter.hasNext()) { ___4350 const datasetVar = varIter.next(); if (!___36.___4351(datasetVar + 1)) continue; numAuxData += countRetainedAuxDataItems(___36.___273(datasetVar + 1), ___36); } zoneIter.reset(); while (zoneIter.hasNext()) { ___4634 const ___902 = zoneIter.next(); if (!___36.___4636(___902 + 1)) continue; numAuxData += countRetainedAuxDataItems(___36.___274(___902 + 1), ___36); } } return numAuxData; } ___372 ___4481( FileWriterInterface& file, ___37&          ___36, ___264           auxData, AuxDataLocation_e    auxDataLocation, ___1170           auxDataEntity, uint32_t&            numItemsWritten)
{ REQUIRE(file.___2039()); REQUIRE(VALID_REF(auxData)); REQUIRE(VALID_ENUM(auxDataLocation, AuxDataLocation_e)); REQUIRE(auxDataEntity >= 0); int32_t ___2810 = ___36.___247(auxData); numItemsWritten = 0; ___372 ___2037 = ___4224; for (int32_t index = 1; ___2037 && index <= ___2810; ++index) { char* itemName = 0; ___90 itemValue = 0; AuxDataType_e itemType; ___372 ___3359; ___36.___243(auxData, index, &itemName, &itemValue, &itemType, &___3359); ___476(itemType == ___270); if (___3359) { ++numItemsWritten; char const* itemValueString = reinterpret_cast<char const*>(itemValue); ___2037 = writeAuxDataItem(file, auxDataLocation, auxDataEntity, itemName, itemType, itemValueString); } ___36.___3815(&itemName); ___36.___3815(reinterpret_cast<char**>(&itemValue)); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { ___372 writeAuxDataItems( FileWriterInterface& file, ___37&          ___36, ItemSetIterator&     varIter, ItemSetIterator&     zoneIter, bool                 appendingZones) { ___372 ___2037 = ___4224; if (___36.___894()) { ___264 auxData = ___36.___235(); uint32_t numItemsWritten = 0; if (auxData) { ___2037 = ___2037 && ___4481( file, ___36, auxData, ___253, 0, numItemsWritten); } varIter.reset(); ___4350 const baseVar = varIter.baseItem(); while (___2037 && varIter.hasNext()) { ___4350 const datasetVar = varIter.next(); ___4634 const fileVar = datasetVar - baseVar; auxData = ___36.___273(datasetVar + 1); if (auxData) { ___2037 = ___2037 && ___4481( file, ___36, auxData, ___258, fileVar + 1, numItemsWritten); } } zoneIter.reset(); ___4634 const ___341 = zoneIter.baseItem(); while (___2037 && zoneIter.hasNext()) { ___4634 const ___902 = zoneIter.next(); ___4634 const fileZone = appendingZones ? ___902 : ___902 - ___341; if (!___36.___4636(___902 + 1)) continue; auxData = ___36.___274(___902 + 1); if (auxData) { ___2037 = ___2037 && ___4481( file, ___36, auxData, ___259, fileZone + 1, numItemsWritten); } } } return ___2037; } ___372 ___4480( FileWriterInterface& file, ___37&          ___36, ItemSetIterator&     varIter, ItemSetIterator&     zoneIter, ___3943&         headerTagMap) { REQUIRE(file.___2039()); headerTagMap[___241] = file.fileLoc(); uint32_t numAuxData = countAuxData(___36, varIter, zoneIter); ___372 ___2037 = ___4482(file, numAuxData); bool const appendingZones = false; ___2037 = ___2037 && writeAuxDataItems(file, ___36, varIter, zoneIter, appendingZones); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 ___4520( FileWriterInterface& file, uint32_t             numGeoms) { REQUIRE(file.___2039()); ___372 ___2037 = ___4224; if (file.___2000()) ___2037 = writeValue<uint32_t, false, 0>(file, SZPLT_GEOMETRY_MARKER_DESCRIPTION, SZPLT_GEOMETRY_MARKER);
___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, NUM_GEOMS_DESCRIPTION, numGeoms); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 ___4521( FileWriterInterface& file, ___37&          ___36, GeomID_t             geomID) { REQUIRE(file.___2039()); uint32_t ___2833 = (uint32_t)___36.___1618(geomID); bool is3D = (___36.___1601(geomID) == CoordSys_Grid3D); ___372 ___2037 = writeValue<uint32_t, false, 0>(file, ___1621, ___2833); for(uint32_t segment = 0; ___2037 && segment < ___2833; ++segment) { uint32_t numPts = (uint32_t)___36.___1617(geomID, static_cast<int32_t>(segment + 1)); ___1103 xPts; ___1103 yPts; ___1103 zPts; ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, ___1620, numPts) && xPts.alloc(static_cast<uint64_t>(numPts)) && yPts.alloc(static_cast<uint64_t>(numPts)); if (is3D) ___2037 = ___2037 && zPts.alloc(static_cast<uint64_t>(numPts)); for(uint32_t i = 0; i < numPts; ++i) { if (is3D) ___36.___1558(geomID, static_cast<int32_t>(segment + 1), static_cast<___2225>(i + 1), &xPts[i], &yPts[i], &zPts[i]); else ___36.___1555(geomID, static_cast<int32_t>(segment + 1), static_cast<___2225>(i + 1), &xPts[i], &yPts[i]); } ___2037 = ___2037 && ___4561<double, false, 0>(file, ___1652, segment, static_cast<size_t>(numPts), &xPts[0]) && ___4561<double, false, 0>(file, ___1654, segment, static_cast<size_t>(numPts), &yPts[0]); if (is3D) ___2037 && ___4561<double, false, 0>(file, ___1657, segment, static_cast<size_t>(numPts), &zPts[0]); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { uint32_t countGeoms(___37& ___36) { uint32_t numGeoms = 0; for (GeomID_t geomID = ___36.___1590(); geomID != ___4033; geomID = ___36.___1599(geomID)) { if (___36.___1604(geomID) != GeomType_Image) ++numGeoms; } return numGeoms; } ___372 ___4519( FileWriterInterface& file, ___37&          ___36, ___4634          ___341, GeomID_t             geomID, bool                 appendingZones) { REQUIRE(file.___2039()); double ___4572; double ___4589; double ___4713; ___36.___1589(geomID, &___4572, &___4589, &___4713); ___372 ___2037 = writeValue<double, false, 0>(file, ___1651, ___4572) && writeValue<double, false, 0>(file, ___1653, ___4589) && writeValue<double, false, 0>(file, ___1656, ___4713); uint8_t ___3157 = (uint8_t)___36.___1601(geomID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___1625, ___3157); uint8_t ___2002 = ___36.___1608(geomID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___1609, ___2002); ___4634 zone = ___36.___1605(geomID); ___2037 = ___2037 && writeValue<int32_t, false, 0>(file, ___1655, appendingZones ? zone : zone - ___341); uint16_t color = (uint16_t)___36.___1592(geomID);
___2037 = ___2037 && writeValue<uint16_t, false, 0>(file, ___1569, color); uint16_t ___1409 = (uint16_t)___36.___1594(geomID); ___2037 = ___2037 && writeValue<uint16_t, false, 0>(file, ___1580, ___1409); uint8_t ___2020 = (uint8_t)___36.___1595(geomID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___1610, ___2020); uint8_t ___1649 = (uint8_t)___36.___1604(geomID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, GEOM_GEOM_TYPE, ___1649); uint8_t ___2261 = (uint8_t)___36.___1596(geomID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___1611, ___2261); double ___2984 = ___36.___1600(geomID); ___2037 = ___2037 && writeValue<double, false, 0>(file, ___1623, ___2984); double ___2287 = ___36.___1597(geomID); ___2037 = ___2037 && writeValue<double, false, 0>(file, ___1612, ___2287); if (___1649 == (uint8_t)GeomType_Circle || ___1649 == (uint8_t)GeomType_Ellipse) { uint16_t ___2791 = static_cast<uint16_t>(___36.___1574(geomID)); ___2037 = ___2037 && writeValue<uint16_t, false, 0>(file, ___1619, ___2791); } else { ___2037 = ___2037 && writeValue<uint16_t, false, 0>(file, ___1619, 0); } if (___1649 == (uint8_t)GeomType_LineSegs) { uint8_t arrowheadStyle = (uint8_t)___36.___1565(geomID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___1567, arrowheadStyle); uint8_t arrowheadAttachment = (uint8_t)___36.___1563(geomID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___1561, arrowheadAttachment); double arrowheadSize = ___36.___1564(geomID); ___2037 = ___2037 && writeValue<double, false, 0>(file, ___1566, arrowheadSize); double arrowheadAngle = ___36.___1562(geomID); ___2037 = ___2037 && writeValue<double, false, 0>(file, ___1560, arrowheadAngle); } else { ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___1567, 0); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___1561, 0); ___2037 = ___2037 && writeValue<double, false, 0>(file, ___1566, 0); ___2037 = ___2037 && writeValue<double, false, 0>(file, ___1560, 0); } uint8_t geomScope = (uint8_t)___36.___1603(geomID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___1631, geomScope); uint8_t geomClipping = (uint8_t)___36.___1591(geomID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, GEOM_CLIPPING, geomClipping); char* ___2328 = 0; if (___36.___1598(geomID, &___2328) && ___2328 != 0) { uint32_t length = static_cast<uint32_t>(strlen(___2328)); ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, ___1614, length); if (length > 0) ___4542(file, ___1613, ___2328);
___36.___3815(&___2328); } else { ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, ___1614, 0); } switch (___36.___1604(geomID)) { case GeomType_LineSegs: { ___2037 = ___2037 && ___4521(file, ___36, geomID); } break; case GeomType_Rectangle: { double ___4456; double ___1824; ___36.___1626(geomID, &___4456, &___1824); ___2037 = ___2037 && writeValue<double, false, 0>(file, ___1628, ___4456) && writeValue<double, false, 0>(file, ___1627, ___1824); } break; case GeomType_Square: { ___2037 = ___2037 && writeValue<double, false, 0>(file, ___1647, ___36.___1646(geomID)); } break; case GeomType_Circle: { ___2037 = ___2037 && writeValue<double, false, 0>(file, ___1606, ___36.___1568(geomID)); } break; case GeomType_Ellipse: { double horizontalAxis; double verticalAxis; ___36.___1575(geomID, &horizontalAxis, &verticalAxis); ___2037 = ___2037 && writeValue<double, false, 0>(file, ___1576, horizontalAxis) && writeValue<double, false, 0>(file, ___1577, verticalAxis); } break; default: ___476(___1303); break; } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 writeGeomItems( FileWriterInterface& file, ___37&          ___36, ___4634          ___341, bool                 appendingZones) { REQUIRE(file.___2039()); ___372 ___2037 = ___4224; for(GeomID_t geomID = ___36.___1590(); ___2037 && geomID != ___4033; geomID = ___36.___1599(geomID)) { if (___36.___1604(geomID) != GeomType_Image) ___2037 = ___4519(file, ___36, ___341, geomID, appendingZones); } return ___2037; } ___372 ___4522( FileWriterInterface& file, ___37&          ___36, ___4634          ___341, ___3943&         headerTagMap) { REQUIRE(file.___2039()); headerTagMap[___1579] = file.fileLoc(); uint32_t numGeoms = countGeoms(___36); ___372 ___2037 = ___4520(file, numGeoms); bool const appendingZones = false; ___2037 = ___2037 && writeGeomItems(file, ___36, ___341, appendingZones); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { uint32_t countTexts(___37& ___36) { uint32_t numTexts = 0; for (TextID_t textID = ___36.___4085(); textID != ___4033; textID = ___36.___4091(textID)) ++numTexts; return numTexts; } ___372 ___4545( FileWriterInterface& file, uint32_t             numTexts) { REQUIRE(file.___2039()); ___372 ___2037 = ___4224; if (file.___2000()) ___2037 = writeValue<uint32_t, false, 0>(file, SZPLT_TEXT_MARKER_DESCRIPTION, SZPLT_TEXT_MARKER); ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, NUM_TEXTS_DESCRIPTION, numTexts); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 ___4544( FileWriterInterface& file, ___37&          ___36, ___4634          ___341, TextID_t             textID, bool                 appendingZones) { REQUIRE(file.___2039());
double ___4572 = 0.0; double ___4589 = 0.0; double ___4713 = 0.0; ___36.___4083(textID, &___4572, &___4589, &___4713); ___372 ___2037 = writeValue<double, false, 0>(file, ___4134, ___4572) && writeValue<double, false, 0>(file, ___4135, ___4589) && writeValue<double, false, 0>(file, ___4138, ___4713); uint16_t ___4078 = (uint16_t)___36.___4087(textID); ___2037 = ___2037 && writeValue<uint16_t, false, 0>(file, ___4080, ___4078); uint16_t ___4057 = (uint16_t)___36.___4062(textID); ___2037 = ___2037 && writeValue<uint16_t, false, 0>(file, ___4058, ___4057); uint16_t ___4059 = (uint16_t)___36.___4063(textID); ___2037 = ___2037 && writeValue<uint16_t, false, 0>(file, ___4060, ___4059); double ___4069 = ___36.___4064(textID); ___2037 = ___2037 && writeValue<double, false, 0>(file, ___4070, ___4069); double ___4071 = ___36.___4065(textID); ___2037 = ___2037 && writeValue<double, false, 0>(file, ___4072, ___4071); uint8_t ___4076 = (uint8_t)___36.___4066(textID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, TEXT_BOX_TYPE, ___4076); uint8_t ___4041 = (uint8_t)___36.___4082(textID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___4042, ___4041); double ___4054 = ___36.___4084(textID); ___2037 = ___2037 && writeValue<double, false, 0>(file, ___4055, ___4054); uint8_t ___4077 = (uint8_t)___36.___4086(textID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, TEXT_CLIPPING, ___4077); double ___4101 = ___36.___4088(textID); ___2037 = ___2037 && writeValue<double, false, 0>(file, TEXT_HEIGHT, ___4101); double ___4105 = ___36.___4089(textID); ___2037 = ___2037 && writeValue<double, false, 0>(file, ___4106, ___4105); uint8_t ___4113 = (uint8_t)___36.___4092(textID); ___2037 = ___2037 &&  writeValue<uint8_t, false, 0>(file, ___4114, ___4113); uint8_t ___4117 = (uint8_t)___36.___4094(textID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___4118, ___4117); uint8_t ___4122 = (uint8_t)___36.___4095(textID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___4123, ___4122); char* ___4124 = 0; ___36.___4096(textID, &___4124); ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, ___4126, static_cast<uint32_t>(strlen(___4124))); if (strlen(___4124) > 0) ___2037 = ___2037 && ___4542(file, ___4125, ___4124); ___36.___3815(&___4124); char* ___4127 = ___36.___4097(textID); ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, ___4129, static_cast<uint32_t>(strlen(___4127))); if (strlen(___4127) > 0) ___2037 = ___2037 && ___4542(file, ___4128, ___4127);
___36.___3815(&___4127); uint8_t ___4130 = (uint8_t)___36.___4098(textID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___4131, ___4130); uint8_t ___4132 = (uint8_t)___36.___4099(textID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___4133, ___4132); int32_t ___4136 = (int32_t)___36.___4100(textID); ___2037 = ___2037 && writeValue<int32_t, false, 0>(file, ___4137, appendingZones ? ___4136 : ___4136 - ___341); uint8_t ___4103 = (uint8_t)___36.___4103(textID); ___2037 = ___2037 && writeValue<uint8_t, false, 0>(file, ___4104, ___4103); char* ___4107 = 0; if (___36.___4090(textID, &___4107) && ___4107 != 0) { ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, ___4109, static_cast<uint32_t>(strlen(___4107))); if (strlen(___4107) > 0) ___2037 = ___2037 && ___4542(file, ___4108, ___4107); ___36.___3815(&___4107); } else { ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, ___4109, 0); } ___36.___3815(&___4107); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 writeTextItems( FileWriterInterface& file, ___37&          ___36, ___4634          ___341, bool                 appendingZones) { ___372 ___2037 = ___4224; for (TextID_t textID = ___36.___4085(); ___2037 && textID != ___4033; textID = ___36.___4091(textID)) ___2037 = ___4544(file, ___36, ___341, textID, appendingZones); return ___2037; } ___372 ___4546( FileWriterInterface& file, ___37&          ___36, ___4634          ___341, ___3943&         headerTagMap) { REQUIRE(file.___2039()); headerTagMap[___4081] = file.fileLoc(); uint32_t numTexts = countTexts(___36); ___372 ___2037 = ___4545(file, numTexts); bool const appendingZones = false; ___2037 = ___2037 && writeTextItems(file, ___36, ___341, appendingZones); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { uint32_t countCustomLabelSets(___37& ___36) { uint32_t numCustomLabelSets = 0; if (___36.___894()) numCustomLabelSets = ___36.___795(); return numCustomLabelSets; } ___372 ___4502( FileWriterInterface& file, uint32_t             numCustomLabelSets) { REQUIRE(file.___2039()); ___372 ___2037 = ___4224; if (file.___2000()) ___2037 = writeValue<uint32_t, false, 0>(file, SZPLT_CUSTOM_LABELS_MARKER_DESCRIPTION, SZPLT_CUSTOM_LABELS_MARKER); ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, ___791, numCustomLabelSets); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 ___4501( FileWriterInterface& file, ___37&          ___36,
int32_t              customLabelNum) { REQUIRE(file.___2039()); ___3837 ___2169 = 0; ___3814 customLabels; ___372 ___2037 = ___36.___794(&___2169, customLabelNum); int32_t numLabels = 0; if (___2037) { numLabels = (int32_t)___36.___3830(___2169); ___2037 = ___2037 && customLabels.alloc(static_cast<uint64_t>(numLabels)) && writeValue<uint32_t, false, 0>(file, ___2818, numLabels); } for(int32_t i = 1; ___2037 && i <= ___36.___3830(___2169); ++i) { char* label = ___36.___3831(___2169, i); customLabels[i - 1] = label; ___36.___3815(&label); } ___2037 = ___2037 && ___4543(file, ___792, (size_t)numLabels, customLabels); if (___2169) ___36.___3825(&___2169); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 writeCustomLabelSets( FileWriterInterface& file, ___37&          ___36) { ___372 ___2037 = ___4224; uint32_t numCustomLabelSets = countCustomLabelSets(___36); for (uint32_t customLabelNum = 1; ___2037 && customLabelNum <= numCustomLabelSets; ++customLabelNum) ___2037 = ___4501(file, ___36, static_cast<int32_t>(customLabelNum)); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 ___4500( FileWriterInterface& file, ___37&          ___36, ___3943&         headerTagMap) { REQUIRE(file.___2039()); headerTagMap[___793] = file.fileLoc(); uint32_t numCustomLabelSets = countCustomLabelSets(___36); ___372 ___2037 = ___4502(file, numCustomLabelSets); ___2037 = ___2037 && writeCustomLabelSets(file, ___36); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } }
 #if defined DO_SUBZONE_HISTOGRAM || defined DO_ITEMANDSUBZONE_HISTOGRAM
namespace { ___372 ___2879( std::string const& pltFileName, ___4634        zone, char const*        ___2502, FILE*&             fileHandle) { REQUIRE(!pltFileName.empty()); REQUIRE(zone>=0); REQUIRE(VALID_NON_ZERO_LEN_STR(___2502)); REQUIRE(fileHandle==NULL); char histogramFileName[1000]; sprintf(histogramFileName, "%s.zone%" PRIu64 ".histogram.csv", pltFileName.c_str(), uint64_t(zone+1)); ___372 ___2037 = ___4224; fileHandle = tecplot::filesystem::fileOpen(histogramFileName, ___2502); if (fileHandle == NULL) ___2037 = ___1184("Cannot open histogram file %s", histogramFileName); return ___2037; } }
 #endif
 #ifdef DO_SUBZONE_HISTOGRAM
___372 OutputSubzoneHistograms( char const*       szpltFileName, ___37&       ___36, ___4634       zone, boost::shared_ptr<___1348 const> ___1347) { ___372 ___2037 = ___4224; REQUIRE(VALID_NON_ZERO_LEN_STR(szpltFileName)); REQUIRE(VALID_REF(___1347.get())); ___2088::SubzoneOffset_t const ___2781 = ___1347->___2781(); ___2088::SubzoneOffset_t const ___2821 = ___1347->___2821(); SubzoneOffsetArray cszRefsByNszHistogram; SubzoneOffsetArray nszRefsByCszHistogram; ___2037 = ___2037 && cszRefsByNszHistogram.alloc(___2781+1, ___2088::SubzoneOffset_t(0)); ___2037 = ___2037 && nszRefsByCszHistogram.alloc(___2821+1, ___2088::SubzoneOffset_t(0)); SubzoneOffsetSetArray cszRefsByNsz; ___2037 = ___2037 && cszRefsByNsz.alloc(___2821); if (___2037) { ___2727 ___2721 = boost::make_shared<___2722>(&___36, zone+1); if (!___2721->___2065()) return ___1303; ___680 const ___2787 = ___1347->___1765(); for (___2088::SubzoneOffset_t ___467 = 0; ___467 < ___2781; ___467++) { SubzoneOffsetSet nszRefs; ___2088::ItemOffset_t const ___2780 = ___1347->___2780(___467); for (___2088::ItemOffset_t cszOffset = 0; cszOffset < ___2780; cszOffset++) { ___2088 const ___686(0, ___467, cszOffset); ___463 const datasetCell = ___1347->___4606(___686); ___476(datasetCell<___1347->___1764()); for (___680 ___679 = 0; ___679 < ___2787; ___679++) { ___2716 const datasetNode = ___2721->___1761(datasetCell+1, ___679+1) - 1; ___476(datasetNode<___1347->___1766()); ___2088 const ___2757 = ___1347->___3922(datasetNode); ___2088::SubzoneOffset_t const ___2732 = ___2757.subzoneOffset(); nszRefs.insert(___2732); cszRefsByNsz[___2732].insert(___467); } } if (___2037) { size_t const numNszRefs = nszRefs.size(); ___476(numNszRefs<nszRefsByCszHistogram.size()); nszRefsByCszHistogram[numNszRefs]++; } } for (___2088::SubzoneOffset_t ___2732 = 0; ___2732 < ___2821; ___2732++) { size_t const numCszRefs = cszRefsByNsz[___2732].size(); ___476(numCszRefs<cszRefsByNszHistogram.size()); cszRefsByNszHistogram[numCszRefs]++; } } if (___2037) { FILE* histogramFile = NULL; ___2037 = ___2879(szpltFileName, zone, "wt", histogramFile); if (___2037) { fprintf(histogramFile,"\nZone %" PRIu64 " (%" PRIu64 " cells, %" PRIu64 " cell subzones, %" PRIu64 " nodes, %" PRIu64 " node subzones)\n", uint64_t(zone+1), uint64_t(___1347->___1764()), uint64_t(___2781), uint64_t(___1347->___1766()), uint64_t(___2821)); fprintf(histogramFile,"\nNszs per Cell Subzone Histogram\n"); fprintf(histogramFile,"\nNumNodeSubzonesReferenced,Count\n"); for (___2088::SubzoneOffset_t nodeSubzoneCount = 0; nodeSubzoneCount <= ___2821; nodeSubzoneCount++) if (nszRefsByCszHistogram[nodeSubzoneCount] > 0)
fprintf(histogramFile,"%" PRIu64 "\t%" PRIu64 "\n", uint64_t(nodeSubzoneCount), uint64_t(nszRefsByCszHistogram[nodeSubzoneCount])); fprintf(histogramFile,"\nCszs per Node Subzone Histogram\n"); fprintf(histogramFile,"\nNumCellSubzonesReferenced,Count\n"); for (___2088::SubzoneOffset_t cellSubzoneCount = 0; cellSubzoneCount <= ___2781; cellSubzoneCount++) if (cszRefsByNszHistogram[cellSubzoneCount] > 0) fprintf(histogramFile,"%" PRIu64 "\t%" PRIu64 "\n", uint64_t(cellSubzoneCount), uint64_t(cszRefsByNszHistogram[cellSubzoneCount])); } ___4193(histogramFile); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; }
 #endif
 #ifdef DO_ITEMANDSUBZONE_HISTOGRAM
___372 OutputItemAndSubzoneHistograms( char const*       szpltFileName, ___37&       ___36, ___4634       zone, boost::shared_ptr<___1348 const> ___1347) { ___372 ___2037 = ___4224; REQUIRE(VALID_NON_ZERO_LEN_STR(szpltFileName)); REQUIRE(VALID_REF(___1347.get())); ___463 const ___2779 = ___1347->___1764(); ___2716 const ___2819 = ___1347->___1766(); ___462 cellRefsByNszHistogram; ___2715 nodeRefsByCszHistogram; ___2037 = ___2037 && cellRefsByNszHistogram.alloc(___2779+1, ___463(0)); ___2037 = ___2037 && nodeRefsByCszHistogram.alloc(___2819+1, ___2716(0)); typedef std::set<___463> CellIndexSet; ___2238<CellIndexSet> cellsRefsByNsz; ___2037 = ___2037 && cellsRefsByNsz.alloc(___2819); if (___2037) { ___2727 ___2721 = boost::make_shared<___2722>(&___36, zone+1); if (!___2721->___2065()) return ___1303; ___680 const ___2787 = ___1347->___1765(); ___2088::SubzoneOffset_t const ___2781 = ___1347->___2781(); for (___2088::SubzoneOffset_t ___467 = 0; ___467 < ___2781; ___467++) { CellIndexSet nodeRefs; ___2088::ItemOffset_t const ___2780 = ___1347->___2780(___467); for (___2088::ItemOffset_t cszOffset = 0; cszOffset < ___2780; cszOffset++) { ___2088 const ___686(0, ___467, cszOffset); ___463 const datasetCell = ___1347->___4606(___686); ___476(datasetCell < ___2779); for (___680 ___679 = 0; ___679 < ___2787; ___679++) { ___2716 const datasetNode = ___2721->___1761(datasetCell+1, ___679+1) - 1; ___476(datasetNode<___2819); ___2088 const ___2757 = ___1347->___3922(datasetNode); ___2088::SubzoneOffset_t const ___2732 = ___2757.subzoneOffset(); nodeRefs.insert(datasetNode); cellsRefsByNsz[___2732].insert(datasetCell); } } if (___2037) { size_t const numNodeRefs = nodeRefs.size(); ___476(numNodeRefs < nodeRefsByCszHistogram.size()); nodeRefsByCszHistogram[numNodeRefs]++; } } ___2088::SubzoneOffset_t const ___2821 = ___1347->___2821(); for (___2088::SubzoneOffset_t ___2732 = 0; ___2732 < ___2821; ___2732++) { size_t const numCellRefs = cellsRefsByNsz[___2732].size(); ___476(numCellRefs < cellRefsByNszHistogram.size()); cellRefsByNszHistogram[numCellRefs]++; } } if (___2037) { FILE* histogramFile = NULL; ___2037 = ___2879(szpltFileName, zone, "at", histogramFile); if (___2037) { fprintf(histogramFile,"\nZone %" PRIu64 " (%" PRIu64 " cells, %" PRIu64 " cell subzones, %" PRIu64 " nodes, %" PRIu64 " node subzones)\n", uint64_t(zone+1), uint64_t(___1347->___1764()), uint64_t(___2779), uint64_t(___1347->___1766()), uint64_t(___2819)); fprintf(histogramFile,"\nNodes per Cell Subzone Histogram\n"); fprintf(histogramFile,"\nNumNodesReferenced,Count\n"); for (___2088::SubzoneOffset_t nodeSubzoneCount = 0; nodeSubzoneCount <= ___2819; nodeSubzoneCount++)
if (nodeRefsByCszHistogram[nodeSubzoneCount] > 0) fprintf(histogramFile,"%" PRIu64 "\t%" PRIu64 "\n", uint64_t(nodeSubzoneCount), uint64_t(nodeRefsByCszHistogram[nodeSubzoneCount])); fprintf(histogramFile,"\nCells per Node Subzone Histogram\n"); fprintf(histogramFile,"\nNumCellsReferenced,Count\n"); for (___2088::SubzoneOffset_t cellSubzoneCount = 0; cellSubzoneCount <= ___2779; cellSubzoneCount++) if (cellRefsByNszHistogram[cellSubzoneCount] > 0) fprintf(histogramFile,"%" PRIu64 "\t%" PRIu64 "\n", uint64_t(cellSubzoneCount), uint64_t(cellRefsByNszHistogram[cellSubzoneCount])); } ___4193(histogramFile); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; }
 #endif
namespace { inline ___372 ___477(___37& ___36) { ___372 ___2037 = ___4224; if (!___36.___894() && ___36.___1590() == ___4033 && ___36.___4085() == ___4033) ___2037 = ___1184("Cannot export dataset: The active frame has no data, texts or geoms to export."); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { inline ___372 ___479(___37& ___36, ___4350  ___4334) { REQUIRE(___36.___894()); REQUIRE(___4334<___36.___888()); ___372 ___2037 = ___4224; if (!___36.___4351(___4334 + 1)) ___2037 = ___1184("Cannot export dataset: Variable %" PRIu64 " is disabled and cannot be exported.", uint64_t(___4334 + 1)); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { inline ___372 ___481(___37& ___36, ___4634 zone) { REQUIRE(___36.___894()); REQUIRE(zone < ___36.___889()); ___372 ___2037 = ___4224; if (!___36.___4636(zone + 1)) ___2037 = ___1184("Cannot export dataset: Zone %" PRIu64 " is disabled and cannot be exported.", uint64_t(zone + 1)); else if ((___4644(___36, zone) || ___4641(___36, zone)) && !___4640(___36, zone) && !___4642(___36, zone)) ___2037 = ___1184("Cannot export dataset: Zone %" PRIu64 " is unsupported type", uint64_t(zone + 1)); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } namespace { ___372 ___478( ___37&      ___36, ItemSetIterator& varIter, ItemSetIterator& zoneIter, DataFileType_e   ___842) { REQUIRE(VALID_ENUM(___842, DataFileType_e)); ___372 ___2037 = ___477(___36); if (___2037) { ___4350 const numVarsToWrite = varIter.___2810(); varIter.reset(); while (___2037 && varIter.hasNext()) ___2037 = ___479(___36, varIter.next()); ___372 hasVolumeZones     = ___1303; ___372 atLeastOneZoneIsFE = ___1303; zoneIter.reset(); while (___2037 && zoneIter.hasNext()) { ___4634 const ___902 = zoneIter.next(); if (___4644(___36, ___902)) hasVolumeZones = ___4224; if (___36.___4638(___902 + 1)) atLeastOneZoneIsFE = ___4224; ___2037 = ___481(___36, ___902); } if (___2037 && hasVolumeZones) { if ((___842 != ___846) && (numVarsToWrite < 3                 || !___36.___4351(1) || !___36.___4351(2) || !___36.___4351(3))) { ___2037 = ___1303; ___1184("Err:  Variables 1,2 and 3 are needed to calculate subzones and must be enabled to export a szplt file"); } else if (___36.___1511() == ___3113) { if (___842 != ___846 && atLeastOneZoneIsFE && (___36.___4343('X') != 1 || ___36.___4343('Y') != 2 || ___36.___4343('Z') != 3)) { ___1929("Warning:\n" "Calculations to determine subzones for szl zones assumes the first 3 variables in the dataset are X,Y, and Z.\n"
"The X,Y,Z axis assignments in the current frame are not the first 3 variables and thus the resulting subzone distribution may not be optimal"); } } else if (___842 != ___846) { ___1929("Warning:\n" "Calculations to determine subzones for szl zones assumes the first 3 variables in the dataset are X,Y, and Z.\n" "If the first 3 variables in the current dataset do not represent X,Y, and Z the resulting subzone distribution may not be optimal"); } } } return ___2037; } } namespace { ___372 ___25( ___1390& szpltZoneHeaderFileLocs, ___37&   ___36, ___4634   ___2844, bool          fillWithValidValues) { szpltZoneHeaderFileLocs.___935(); return IMPLICATION(___36.___894(), szpltZoneHeaderFileLocs.alloc( ___2844, fillWithValidValues ? ___1391(0): ___330)); } ___3943 initializedHeaderTagMap( ___4634               numZonesToWrite, ___4350                numVarsToWrite, uint64_t                  numPartitionFiles, ___1842 const&                maxIJKSubzoneSize, ___2088::ItemOffset_t maxFESubzoneSize) { ___3943 headerTagMap              = DATASET_HEADER_TAG_MAP_INITIALIZER; headerTagMap[___2847]           = static_cast<uint64_t>(numZonesToWrite); headerTagMap[___2843]            = static_cast<uint64_t>(numVarsToWrite); headerTagMap[SUBZONE_MAX_I_SIZE_TAG]  = static_cast<uint64_t>(maxIJKSubzoneSize.i()); headerTagMap[SUBZONE_MAX_J_SIZE_TAG]  = static_cast<uint64_t>(maxIJKSubzoneSize.___2103()); headerTagMap[SUBZONE_MAX_K_SIZE_TAG]  = static_cast<uint64_t>(maxIJKSubzoneSize.___2132()); headerTagMap[SUBZONE_MAX_FE_SIZE_TAG] = static_cast<uint64_t>(maxFESubzoneSize); if (numPartitionFiles > 0) headerTagMap[NUM_PARTITION_FILES_TAG] = numPartitionFiles; return headerTagMap; } } ___372 ___1240( ___37&                   ___36, FileWriterInterface&          szpltFile, ___1386 const&        ___1385, ___372                     includeRevisionNumber, DataSetWriter&                dataSetWriter, ___3499                        vars, ___3499                        ___4669, ___934& ___933) { REQUIRE(szpltFile.___2039()); REQUIRE(___1385.getFileVersion() == SZPLT_CUR_WRITE_VERSION); REQUIRE(VALID_REF_OR_NULL(vars)); REQUIRE(VALID_REF_OR_NULL(___4669));
 #if !defined TECIOMPI
REQUIRE(boost::atomic<double>().is_lock_free());
 #endif
szpltFile.___3492(___1385.___2000()); szpltFile.setDataFileType(___1385.___842()); ItemSetIterator varIter(___36, ___36.___894() ? ___36.___888() : 0, vars); ItemSetIterator zoneIter(___36, ___36.___894() ? ___36.___889() : 0, ___4669); ___372 ___2037 = ___478(___36, varIter, zoneIter, szpltFile.___842()); if (___2037) { ___36.___3777("Exporting szplt file...", ___4224 , ___4224/*___3578*/); ___2037 = ___2037 && ___36.___3767(0); ___4350 numVarsToWrite = 0; ___4634 numZonesToWrite = 0; uint64_t numPartitionFiles = 0; if (___36.___894()) { numVarsToWrite = varIter.___2810(); numZonesToWrite = zoneIter.___2810(); numPartitionFiles = static_cast<uint64_t>(___36.datasetGetNumPartitionFiles()); } ___1390 szpltZoneHeaderFileLocs; ___2037 = ___2037 && ___25(szpltZoneHeaderFileLocs, ___36, numZonesToWrite, true); try { ___3943 headerTagMap = initializedHeaderTagMap(numZonesToWrite, numVarsToWrite, numPartitionFiles, ___1385.___1755(), ___1385.___1754()); ___2037 = ___2037 && ___4514(szpltFile, SZPLT_FILE_TYPE, SZPLT_CUR_WRITE_VERSION, includeRevisionNumber, 0); ___4480(szpltFile, ___36, varIter, zoneIter, headerTagMap) && ___4522(szpltFile, ___36, zoneIter.baseItem(), headerTagMap) && ___4546(szpltFile, ___36, zoneIter.baseItem(), headerTagMap) && ___4500(szpltFile, ___36, headerTagMap); ___2037 = ___2037 && ___25(szpltZoneHeaderFileLocs, ___36, numZonesToWrite, false) && dataSetWriter.writeDataSet(szpltFile, szpltZoneHeaderFileLocs) && szpltFile.seekToFileEnd(); if (___2037) { uint64_t dataSetHeaderLocation = szpltFile.fileLoc(); ___372 dataSetIsAvailable = ___36.___894(); std::string dataSetTitle; if (dataSetIsAvailable) { char* ___4175 = 0; ___36.datasetGetTitle(&___4175); dataSetTitle = ___4175; ___36.___3815(&___4175); } ___2037 = ___2037 && writeDataSetHeaders(szpltFile, dataSetIsAvailable, dataSetTitle, numVarsToWrite, numZonesToWrite, headerTagMap, dataSetWriter.___4704(), szpltZoneHeaderFileLocs, ___933) && szpltFile.___3458() && ___4514(szpltFile, SZPLT_FILE_TYPE, SZPLT_CUR_WRITE_VERSION, includeRevisionNumber, dataSetHeaderLocation); }
 #ifdef PROFILE_FILE_ACCESS
FileStreamWriter* fileWriter = dynamic_cast<FileStreamWriter*>(&szpltFile); if (fileWriter) ___933.___7(fileWriter->statistics().___2778);
 #endif
} catch (std::bad_alloc const&) { ___2037 = ___1184("Out of memory while writing file."); } catch (std::runtime_error const& e) { std::ostringstream ___2890; ___2890 << "Error encountered while writing file: " << e.what(); ___2037 = ___1184(___2890.str().c_str()); } catch (...) { ___2037 = ___1184("Unrecoverable error while writing file."); } ___36.___3768(); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 writeIntermediateFiles( ___37&                   ___36, FileWriterInterface&          headerFile, FileWriterInterface&          zoneFile, FileWriterInterface&          auxDataFile, FileWriterInterface&          geometryFile, FileWriterInterface&          textFile, FileWriterInterface&          customLabelsFile, ___1386 const&        ___1385, uint64_t                      numHeadersInFile, uint32_t                      numAuxDataInFile, uint32_t                      numGeomsInFile, uint32_t                      numTextsInFile, uint32_t                      numCustomLabelsInFile, ___372                     includeRevisionNumber, DataSetWriter&                dataSetWriter, ___3499                        vars, ___3499                        ___4669, ___934& ___933) { REQUIRE(headerFile.___2039()); REQUIRE(zoneFile.___2039()); REQUIRE(auxDataFile.___2039()); REQUIRE(geometryFile.___2039()); REQUIRE(textFile.___2039()); REQUIRE(customLabelsFile.___2039()); REQUIRE(___1385.getFileVersion() == SZPLT_CUR_WRITE_VERSION); REQUIRE(VALID_REF_OR_NULL(vars)); REQUIRE(VALID_REF_OR_NULL(___4669));
 #if !defined TECIOMPI
REQUIRE(boost::atomic<double>().is_lock_free());
 #endif
ItemSetIterator varIter(___36, ___36.___894() ? ___36.___888() : 0, vars); ItemSetIterator zoneIter(___36, ___36.___894() ? ___36.___889() : 0, ___4669); ___372 ___2037 = ___478(___36, varIter, zoneIter, ___1385.___842()); if (___2037) { ___36.___3777("Exporting szplt temp files...", ___4224 , ___4224/*___3578*/); ___2037 = ___2037 && ___36.___3767(0); ___4350 numVarsToWrite = 0; ___4634 numZonesToWrite = 0; uint64_t numPartitionFiles = 0; if (___36.___894()) { numVarsToWrite = varIter.___2810(); numZonesToWrite = zoneIter.___2810(); numPartitionFiles = static_cast<uint64_t>(___36.datasetGetNumPartitionFiles()); } if (numHeadersInFile == 0) ___2037 = ___2037 && writeValue<uint64_t, false, 0>(headerFile, SZPLT_NUM_INTERMEDIATE_HEADERS, numHeadersInFile); ___2037 = ___2037 && zoneFile.___3458() && ___4514(zoneFile, SZPLT_FILE_TYPE, SZPLT_CUR_WRITE_VERSION, includeRevisionNumber, 1); try { ___3943 headerTagMap = initializedHeaderTagMap(numZonesToWrite, numVarsToWrite, numPartitionFiles, ___1385.___1755(), ___1385.___1754()); ___1390 szpltZoneHeaderFileLocs; ___372 dataSetIsAvailable = ___36.___894(); std::string dataSetTitle; if (dataSetIsAvailable) { char* ___4175 = 0; ___36.datasetGetTitle(&___4175); dataSetTitle = ___4175; ___36.___3815(&___4175); } uint64_t headersCount = numHeadersInFile + 1; uint32_t auxDataCount = numAuxDataInFile + countAuxData(___36, varIter, zoneIter); uint32_t geomCount = numGeomsInFile + countGeoms(___36); uint32_t textCount = numTextsInFile + countTexts(___36); uint32_t customLabelsCount = numCustomLabelsInFile + countCustomLabelSets(___36); ___2037 = ___2037 && headerFile.seekToFileEnd(); ___2037 = ___2037 && auxDataFile.seekToFileEnd(); ___2037 = ___2037 && textFile.seekToFileEnd(); ___2037 = ___2037 && geometryFile.seekToFileEnd(); ___2037 = ___2037 && customLabelsFile.seekToFileEnd(); bool const appendingZones = true; ___2037 = ___2037 && auxDataFile.___3458() && ___4482(auxDataFile, auxDataCount) && auxDataFile.seekToFileEnd() && writeAuxDataItems(auxDataFile, ___36, varIter, zoneIter, appendingZones) && geometryFile.___3458() && ___4520(geometryFile, geomCount) && geometryFile.seekToFileEnd() && writeGeomItems(geometryFile, ___36, zoneIter.baseItem(), appendingZones) && textFile.___3458() && ___4545(textFile, textCount) && textFile.seekToFileEnd() && writeTextItems(textFile, ___36, zoneIter.baseItem(), appendingZones) && customLabelsFile.___3458() && ___4502(customLabelsFile, customLabelsCount) && customLabelsFile.seekToFileEnd() && writeCustomLabelSets(customLabelsFile, ___36) && ___25(szpltZoneHeaderFileLocs, ___36, numZonesToWrite, false) && zoneFile.seekToFileEnd() &&
dataSetWriter.writeDataSet(zoneFile, szpltZoneHeaderFileLocs) && headerFile.___3458() && writeValue<uint64_t, false, 0>(headerFile, SZPLT_NUM_INTERMEDIATE_HEADERS, headersCount) && headerFile.seekToFileEnd() && writeDataSetHeaders(headerFile, dataSetIsAvailable, dataSetTitle, numVarsToWrite, numZonesToWrite, headerTagMap, dataSetWriter.___4704(), szpltZoneHeaderFileLocs, ___933);
 #ifdef PROFILE_FILE_ACCESS
FileStreamWriter* fileWriter = dynamic_cast<FileStreamWriter*>(&szpltFile); if (fileWriter) ___933.___7(fileWriter->statistics().___2778);
 #endif
} catch (std::bad_alloc const&) { ___2037 = ___1184("Out of memory while writing file."); } catch (std::runtime_error const& e) { std::ostringstream ___2890; ___2890 << "Error encountered while writing file: " << e.what(); ___2037 = ___1184(___2890.str().c_str()); } catch (...) { ___2037 = ___1184("Unrecoverable error while writing file."); } ___36.___3768(); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } }}
