#include "Zone_s.h"
#include "ThirdPartyHeadersBegin.h"
#include <algorithm>
#include <sstream>
#include <boost/make_shared.hpp>
#include <boost/scoped_array.hpp>
#include <boost/shared_ptr.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "FieldData_s.h"
 #if !defined TECIOMPI
#include "JobControl_s.h"
 #endif
#include "TecioData.h"
using namespace tecplot::___3931; namespace tecplot { namespace tecioszl { namespace {
 #define MIN_NODES_FOR_MULTITHREAD 100000 
 #define MIN_CELLS_FOR_MULTITHREAD 50000 
void getZoneCounts(int64_t& nodeCount, int64_t& cellCount, ___1842 const& zoneSize, ZoneType_e ___4690) { if (___4690 == ___4702) { nodeCount = (int64_t)zoneSize.i() * zoneSize.___2103() * zoneSize.___2132(); ___81 iMax = zoneSize.i(); ___81 jMax = zoneSize.___2103(); ___81 kMax = zoneSize.___2132(); if (kMax > 1) --kMax; else if (jMax > 1) --jMax; else if (iMax > 1) --iMax; cellCount = (int64_t)iMax * jMax * kMax; } else { nodeCount = (int64_t)zoneSize.i(); cellCount = (int64_t)zoneSize.___2103(); } } } Zone_s::Zone_s( std::string const& ___4688, ZoneType_e ___4690, int64_t iMin, int64_t jMin, int64_t kMin, int64_t ___1907, int64_t ___2114, int64_t ___2159, double ___3638, int32_t ___3783, ___1170 ___2972, int64_t ___2800, FaceNeighborMode_e ___1282, int64_t ___4190, int64_t ___2784, int64_t ___4186, std::vector<FieldDataType_e> const& ___1370, std::vector<int> const& passiveVarVector, std::vector<ValueLocation_e> const& ___4324, std::vector<___1170> const& shareVarFromZoneVector, ___1170 ___3547) : ___2681(___4688) , ___2682(___4690) , m_partitionOffset((___81)(iMin - 1), (___81)(jMin - 1), (___81)(kMin - 1)) , ___2680((___81)(___1907 - iMin + 1), (___81)(___2114 - jMin + 1), (___81)(___2159 - kMin + 1)) , ___2619(___3638) , ___2620(___3783) , ___2612(___2972) , ___2501(___2800) , ___2456(___1282) , ___2649(___4190) , ___2499(___2784) , ___2648(___4186) , ___2458(___1370) , m_passiveVars(passiveVarVector) , ___2668(___4324) , m_shareVarFromZone(shareVarFromZoneVector) , m_shareConnectivityFromZone(___3547) , ___2395(static_cast<size_t>(-1)) , ___2343(new AuxData_s) { REQUIRE(___4688.size() > 0); REQUIRE(VALID_ENUM(___4690, ZoneType_e)); REQUIRE(iMin > 0); REQUIRE(jMin > 0); REQUIRE(kMin > 0); REQUIRE(0 < ___1907); REQUIRE(0 < ___2114); REQUIRE(IMPLICATION(___4690 == ___4702 || ___4690 == ___4696 || ___4690 == ___4697, 0 < ___2159)); REQUIRE("solutionTime can be anything"); REQUIRE(0 <= ___3783); REQUIRE(0 <= ___2972); REQUIRE(0 <= ___2800); REQUIRE(___2668.size() > 0); REQUIRE(VALID_ENUM(___1282, FaceNeighborMode_e) || ___1282 == ___1286); REQUIRE(IMPLICATION(___4690 == ___4697, 0 <= ___4190)); REQUIRE(IMPLICATION(___4690 == ___4697 || ___4690 == ___4696, 0 <= ___2784)); REQUIRE(IMPLICATION(___4690 == ___4697 || ___4690 == ___4696, 0 <= ___4186)); int64_t nodeCount; int64_t cellCount; getZoneCounts(nodeCount, cellCount, ___2680, ___2682);
if (___2682 == ___4694) { ___2680.___3495(2); } else if (___2682 == ___4700) { ___2680.___3495(3); } else if (___2682 == ___4698 || ___2682 == ___4699) { ___2680.___3495(4); } else if (___2682 == ___4693) { ___2680.___3495(8); } try { ___2494.resize(___2668.size()); } catch (std::bad_alloc const&) { std::cerr << "Out of memory while storing " << ___2668.size() << " zone value locations." << std::endl; throw; } try { ___2398.resize(___2668.size()); } catch (std::bad_alloc const&) { std::cerr << "Out of memory while storing " << ___2668.size() << " zone derived variable structures." << std::endl; throw; } std::set<___3491> zoneSet; ___1170 numVarsShared = 0; try { for(size_t ___4289 = 0; ___4289 < ___2668.size(); ++___4289) { ___2494[___4289] = TypedFieldDataFactory().make(___2458[___4289]); ___2398[___4289] = TypedFieldDataFactory().make(___2458[___4289]); if (m_passiveVars[___4289] == 0 && m_shareVarFromZone[___4289] == 0) { if (___2395 == static_cast<size_t>(-1)) ___2395 = ___4289; if (___2668[___4289] == ___4328) { ___2494[___4289]->___2667 = ___4328; ___2494[___4289]->___2666 = nodeCount; ___2398[___4289]->___2667 = ___4326; ___2398[___4289]->___2666 = cellCount; } else { ___2494[___4289]->___2667 = ___4326; ___2494[___4289]->___2666 = cellCount; ___2398[___4289]->___2667 = ___4328; ___2398[___4289]->___2666 = nodeCount; } } } } catch (std::bad_alloc const&) { std::cerr << "Out of memory while storing " << ___2668.size() << " zone variable structures." << std::endl; throw; } m_allVarsAreShared = numVarsShared == static_cast<___1170>(___2668.size()); if (!m_shareConnectivityFromZone && ___2682 != ___4702) { try { ___2495 = ___2728::makePtr(___2680.___1667(), ___2114, ___2680.___1668()); } catch(std::bad_alloc const&) { std::cerr << "Out of memory while creating zone node map." << std::endl; throw; } } } Zone_s::Zone_s( Zone_s const* partitionParent, int64_t iMin, int64_t jMin, int64_t kMin, int64_t ___1907, int64_t ___2114, int64_t ___2159) { REQUIRE(VALID_REF(partitionParent)); REQUIRE(iMin > 0); REQUIRE(jMin > 0); REQUIRE(kMin > 0); REQUIRE(___1907      <= partitionParent->___2680.i()); REQUIRE(___2114 <= partitionParent->___2680.___2103()); REQUIRE(___2159    <= partitionParent->___2680.___2132()); REQUIRE(___1907 > iMin); REQUIRE(___2114 > jMin); REQUIRE(___2159 > kMin); *this = Zone_s(partitionParent->___2681, partitionParent->___2682, iMin, jMin, kMin, ___1907, ___2114, ___2159, partitionParent->___2619, partitionParent->___2620, partitionParent->___2612, 0,
partitionParent->___2456, 0, 0, 0, partitionParent->___2458, partitionParent->m_passiveVars, partitionParent->___2668, partitionParent->m_shareVarFromZone, partitionParent->m_shareConnectivityFromZone); } namespace { struct FENodalValueDerivationData { ___2716 begin; ___2716 end; ___1360* nativeFieldData; ___1360* derivedFieldData; ___2741* nodeToElemMap; double minVal; double maxVal; FENodalValueDerivationData(___2716 begin, ___2716 end, ___1360* nativeFieldData, ___1360* derivedFieldData, ___2741* nodeToElemMap) : begin(begin) , end(end) , nativeFieldData(nativeFieldData) , derivedFieldData(derivedFieldData) , nodeToElemMap(nodeToElemMap) , minVal(std::numeric_limits<double>::max()) , maxVal(-std::numeric_limits<double>::max()) {} }; inline double getValueFromTypedRawPtr(void* rawPtr, int64_t index, FieldDataType_e type) { REQUIRE(VALID_REF(rawPtr)); REQUIRE(0 <= index); REQUIRE(VALID_ENUM(type, FieldDataType_e)); double ___4312; switch(type) { case FieldDataType_Float: ___4312 = checked_numeric_cast<double>(((float*)(rawPtr))[index]); break; case FieldDataType_Double: ___4312 = ((double*)(rawPtr))[index]; break; case FieldDataType_Int32: ___4312 = checked_numeric_cast<double>(((int32_t*)(rawPtr))[index]); break; case FieldDataType_Int16: ___4312 = checked_numeric_cast<double>(((int16_t*)(rawPtr))[index]); break; case FieldDataType_Byte: ___4312 = checked_numeric_cast<double>(((uint8_t*)(rawPtr))[index]); break; case ___1363: ___4312 = checked_numeric_cast<double>((((uint8_t*)(rawPtr))[index / 8] >> (index % 8)) & 1); break; case ___1366: ___4312 = checked_numeric_cast<double>(((int64_t*)(rawPtr))[index]); break; default: ___476(___1303); ___4312 = 0.0; break; } return ___4312; } inline void setValueToTypedRawPtr(void* rawPtr, int64_t index, FieldDataType_e type, double ___4312) { REQUIRE(VALID_REF(rawPtr)); REQUIRE(0 <= index); REQUIRE(VALID_ENUM(type, FieldDataType_e)); switch(type) { case FieldDataType_Float: ((float*)(rawPtr))[index] = checked_numeric_cast<float>(___4312); break; case FieldDataType_Double: ((double*)(rawPtr))[index] = ___4312; break; case FieldDataType_Int32: ((int32_t*)(rawPtr))[index] = checked_numeric_cast<int32_t>(___4312); break; case FieldDataType_Int16: ((int16_t*)(rawPtr))[index] = checked_numeric_cast<int16_t>(___4312); break; case FieldDataType_Byte: ((uint8_t*)(rawPtr))[index] = checked_numeric_cast<uint8_t>(___4312); break; case ___1363: if (___4312 < 1.0) { ___4312 = 0.0; ((uint8_t *)(rawPtr))[index / 8] &= ~(checked_numeric_cast<uint8_t>(01) << (index % 8)); } else { ___4312 = 1.0; ((uint8_t *)(rawPtr))[index / 8] |= checked_numeric_cast<uint8_t>(01) << (index % 8); } break; case ___1366: ((int64_t*)(rawPtr))[index] = checked_numeric_cast<int64_t>(___4312); break; default: ___476(___1303); break; } } void deriveRangeOfNodalValues(___90 threadData) { FENodalValueDerivationData* derivationData = reinterpret_cast<FENodalValueDerivationData*>(threadData);
REQUIRE(derivationData->derivedFieldData->___2457 == derivationData->nativeFieldData->___2457); void* rawCCPtr = derivationData->nativeFieldData->getRawPointer(); void* rawNodalPtr = derivationData->derivedFieldData->getRawPointer(); FieldDataType_e ___1361 = derivationData->nativeFieldData->___2457; for(___2716 ___2707 = derivationData->begin; ___2707 < derivationData->end; ++___2707) { double ___4312 = 0.0; ___463 startingIndex = derivationData->nodeToElemMap->m_elemIndex[___2707]; ___463 howManyCells = derivationData->nodeToElemMap->cellCountForNode(___2707); for(___463 whichCell = 0; whichCell < howManyCells; ++whichCell) { ___463 ___447 = derivationData->nodeToElemMap->m_elem[startingIndex + whichCell]; ___4312 += getValueFromTypedRawPtr(rawCCPtr, ___447, ___1361); } ___4312 /= howManyCells; setValueToTypedRawPtr(rawNodalPtr, ___2707, ___1361, ___4312); derivationData->minVal = std::min(derivationData->minVal, ___4312); derivationData->maxVal = std::max(derivationData->maxVal, ___4312); } } } void Zone_s::___963(___4350 ___4366, ___2728* ___2721) { REQUIRE(0 < ___4366 && ___4366 <= static_cast<___4350>(___2494.size())); REQUIRE(___2494[___4366 - 1]->___2667 == ___4326); ___1360::Ptr nativeFieldData = ___2494[___4366 - 1]; ___1360::Ptr derivedFieldData = ___2398[___4366 - 1]; derivedFieldData->assignValues(derivedFieldData->___2666, 0.0); if (___2682 == ___4702) { boost::scoped_array<uint16_t> divisor(new uint16_t[derivedFieldData->___2666]); for(size_t i = 0; i < derivedFieldData->___2666; ++i) divisor[i] = 0; int64_t const ___459 = std::max(int64_t(1), (int64_t)(___2680.i() - 1)); int64_t const ___464 = std::max(int64_t(1), (int64_t)(___2680.___2103() - 1)); int64_t const ___465 = std::max(int64_t(1), (int64_t)(___2680.___2132() - 1)); int64_t const nodeIMax = ___2680.i(); int64_t const nodeJMax = ___2680.___2103(); int64_t const nodeKMax = ___2680.___2132(); std::vector<int64_t> nodes; for (int64_t i = 0; i < ___459; ++i) { for (int64_t ___2103 = 0; ___2103 < ___464; ++___2103) { for (int64_t ___2132 = 0; ___2132 < ___465; ++___2132) { int64_t const index = (___2132 * nodeJMax + ___2103) * nodeIMax + i; nodes.resize(0); nodes.push_back(index); if (nodeIMax > 1) { nodes.push_back(index + 1); } if (nodeJMax > 1) { size_t count = nodes.size(); for(size_t n = 0; n < count; ++n) { nodes.push_back(nodes[n] + nodeIMax); } } if (nodeKMax > 1) { size_t count = nodes.size(); for(size_t n = 0; n < count; ++n) { nodes.push_back(nodes[n] + nodeIMax * nodeJMax); } } for(size_t n = 0; n < nodes.size(); ++n) { derivedFieldData->___3502(nodes[n], derivedFieldData->___1778(nodes[n]) + nativeFieldData->___1778(index)); ++divisor[nodes[n]]; } } } } for(size_t n = 0; n < derivedFieldData->storedValueCount(); ++n) derivedFieldData->___3502((___81)n, derivedFieldData->___1778(n) / (double)divisor[n]); } else { ___476(___2680.___1667() > 0);
___476(VALID_REF(___2721)); if (!m_nodeToElemMap) m_nodeToElemMap.reset(new ___2741(*___2721, ___2680.___1668()));
 #if !defined TECIOMPI
int numThreads = 1; if (m_nodeToElemMap->m_nodeCount >= MIN_NODES_FOR_MULTITHREAD) numThreads = std::min(___2120::___2825(), checked_numeric_cast<int>((m_nodeToElemMap->m_nodeCount - 1) / MIN_NODES_FOR_MULTITHREAD + 1)); if (numThreads == 1) {
 #endif
FENodalValueDerivationData derivationData(0, ___2680.___1668(), nativeFieldData.get(), derivedFieldData.get(), m_nodeToElemMap.get()); deriveRangeOfNodalValues((___90)&derivationData); derivedFieldData->___3497(derivationData.minVal, derivationData.maxVal);
 #if !defined TECIOMPI
} else { std::vector<boost::shared_ptr<FENodalValueDerivationData> > nodalDerivationData; for(int i = 0; i < numThreads; ++i) { ___2716 const begin = static_cast<___2716>((size_t)m_nodeToElemMap->m_nodeCount * i / numThreads); ___2716 const end = static_cast<___2716>((size_t)m_nodeToElemMap->m_nodeCount * (i + 1) / numThreads); nodalDerivationData.push_back(boost::make_shared<FENodalValueDerivationData>( begin, end, nativeFieldData.get(), derivedFieldData.get(), m_nodeToElemMap.get())); } ___2120 ___2117; for(int i = 0; i < numThreads; ++i) ___2117.addJob(deriveRangeOfNodalValues, reinterpret_cast<___90>(nodalDerivationData[i].get())); ___2117.wait(); double minVal = std::numeric_limits<double>::max(); double maxVal = -std::numeric_limits<double>::max(); for(int i = 0; i < numThreads; ++i) { minVal = std::min(minVal, nodalDerivationData[i]->minVal); maxVal = std::max(maxVal, nodalDerivationData[i]->maxVal); } derivedFieldData->___3497(minVal, maxVal); }
 #endif
} } namespace { struct FECCValueDerivationData { int64_t begin; int64_t end; ___1360* nativeFieldData; ___1360* derivedFieldData; ___2728* ___2721; double minVal; double maxVal; FECCValueDerivationData(int64_t begin, int64_t end, ___1360* nativeFieldData, ___1360* derivedFieldData, ___2728* ___2721) : begin(begin) , end(end) , nativeFieldData(nativeFieldData) , derivedFieldData(derivedFieldData) , ___2721(___2721) , minVal(std::numeric_limits<double>::max()) , maxVal(-std::numeric_limits<double>::max()) {} }; void deriveRangeOfCCValues(___90 threadData) { FECCValueDerivationData* derivationData = reinterpret_cast<FECCValueDerivationData*>(threadData); REQUIRE(derivationData->derivedFieldData->___2457 == derivationData->nativeFieldData->___2457); void* rawNodalPtr = derivationData->nativeFieldData->getRawPointer(); void* rawCCPtr = derivationData->derivedFieldData->getRawPointer(); FieldDataType_e ___1361 = derivationData->nativeFieldData->___2457; for(int64_t ___447 = derivationData->begin; ___447 < derivationData->end; ++___447) { double ___4312 = 0.0; ___680 ___2787 = checked_numeric_cast<___680>(derivationData->___2721->___2498); for(___680 ___679 = 0; ___679 < ___2787; ++___679) { int64_t ___2707 = derivationData->___2721->___4312(___447 * ___2787 + ___679); ___4312 += getValueFromTypedRawPtr(rawNodalPtr, ___2707, ___1361); } ___4312 /= ___2787; setValueToTypedRawPtr(rawCCPtr, ___447, ___1361, ___4312); derivationData->minVal = std::min(derivationData->minVal, ___4312); derivationData->maxVal = std::max(derivationData->maxVal, ___4312); } } } void Zone_s::deriveCCValues(___4350 ___4366, ___2728* ___2721) { REQUIRE(0 < ___4366 && ___4366 <= static_cast<___4350>(___2494.size())); REQUIRE(___2494[___4366 - 1]->___2667 == ___4328); ___1360::Ptr nativeFieldData = ___2494[___4366 - 1]; ___1360::Ptr derivedFieldData = ___2398[___4366 - 1]; derivedFieldData->assignValues(derivedFieldData->___2666, 0.0); if (___2682 == ___4702) { int64_t const ___459 = std::max(int64_t(1), (int64_t)(___2680.i() - 1)); int64_t const ___464 = std::max(int64_t(1), (int64_t)(___2680.___2103() - 1)); int64_t const ___465 = std::max(int64_t(1), (int64_t)(___2680.___2132() - 1)); int64_t const nodeIMax = ___2680.i(); int64_t const nodeJMax = ___2680.___2103(); int64_t const nodeKMax = ___2680.___2132(); std::vector<int64_t> nodes; for (int64_t i = 0; i < ___459; ++i) { for (int64_t ___2103 = 0; ___2103 < ___464; ++___2103) { for (int64_t ___2132 = 0; ___2132 < ___465; ++___2132) { int64_t const index = (___2132 * nodeJMax + ___2103) * nodeIMax + i; nodes.resize(0); nodes.push_back(index); if (nodeIMax > 1) { nodes.push_back(index + 1); } if (nodeJMax > 1) { size_t count = nodes.size(); for(size_t n = 0; n < count; ++n) { nodes.push_back(nodes[n] + nodeIMax); } } if (nodeKMax > 1) { size_t count = nodes.size(); for(size_t n = 0; n < count; ++n)
{ nodes.push_back(nodes[n] + nodeIMax * nodeJMax); } } double ___4312 = 0.0; for(size_t n = 0; n < nodes.size(); ++n) ___4312 += nativeFieldData->___1778(nodes[n]); derivedFieldData->___3502(index, ___4312 / nodes.size()); } } } } else { ___476(___2680.___1667() > 0); ___476(VALID_REF(___2721));
 #if !defined TECIOMPI
int numThreads = 1; if (___2721->___2390 >= MIN_CELLS_FOR_MULTITHREAD) numThreads = std::min(___2120::___2825(), checked_numeric_cast<int>((___2721->___2390 - 1) / MIN_CELLS_FOR_MULTITHREAD + 1)); if (numThreads == 1) {
 #endif
FECCValueDerivationData derivationData(0, ___2721->___2390, nativeFieldData.get(), derivedFieldData.get(), ___2721); deriveRangeOfCCValues((___90)&derivationData); derivedFieldData->___3497(derivationData.minVal, derivationData.maxVal);
 #if !defined TECIOMPI
} else { std::vector<boost::shared_ptr<FECCValueDerivationData> > derivationData; for (int i = 0; i < numThreads; ++i) { ___463 const begin = static_cast<___463>((size_t)___2721->___2390 * i / numThreads); ___463 const end = static_cast<___463>((size_t)___2721->___2390 * (i + 1) / numThreads); derivationData.push_back(boost::make_shared<FECCValueDerivationData>( begin, end, nativeFieldData.get(), derivedFieldData.get(), ___2721)); } ___2120 ___2117; for (int i = 0; i < numThreads; ++i) ___2117.addJob(deriveRangeOfCCValues, reinterpret_cast<___90>(derivationData[i].get())); ___2117.wait(); double minVal = std::numeric_limits<double>::max(); double maxVal = -std::numeric_limits<double>::max(); for (int i = 0; i < numThreads; ++i) { minVal = std::min(minVal, derivationData[i]->minVal); maxVal = std::max(maxVal, derivationData[i]->maxVal); } derivedFieldData->___3497(minVal, maxVal); }
 #endif
} } Zone_s::Zone_s() {} void Zone_s::writeToFile(FileWriterInterface& outputFile, bool ___4478) const { ___4542(outputFile, ___2681, ___4478); writeScalar(outputFile, (uint32_t)___2682, ___4478); writeScalar(outputFile, m_partitionOffset.i(), ___4478); writeScalar(outputFile, m_partitionOffset.___2103(), ___4478); writeScalar(outputFile, m_partitionOffset.___2132(), ___4478); writeScalar(outputFile, ___2680.i(), ___4478); writeScalar(outputFile, ___2680.___2103(), ___4478); writeScalar(outputFile, ___2680.___2132(), ___4478); writeScalar(outputFile, ___2619, ___4478); writeScalar(outputFile, ___2620, ___4478); writeScalar(outputFile, ___2612, ___4478); writeScalar(outputFile, ___2501, ___4478); writeScalar(outputFile, (uint32_t)___2456, ___4478); writeScalar(outputFile, ___2649, ___4478); writeScalar(outputFile, ___2499, ___4478); writeScalar(outputFile, ___2648, ___4478); std::vector<uint32_t>tempFieldDataTypes(___2458.begin(), ___2458.end()); writeVector(outputFile, tempFieldDataTypes, ___4478); writeVector(outputFile, m_passiveVars, ___4478); std::vector<uint32_t> tempValueLocations(___2668.begin(), ___2668.end()); writeVector(outputFile, tempValueLocations, ___4478); writeVector(outputFile, m_shareVarFromZone, ___4478); writeScalar(outputFile, m_shareConnectivityFromZone, ___4478); m_ghostNodeInfo.writeToFile(outputFile, ___4478); m_ghostCellInfo.writeToFile(outputFile, ___4478); writeVectorOfPtrs(outputFile, ___2494, ___4478); writeScalar(outputFile, (uint64_t)___2395, ___4478); if (___2682 != ___4702) ___2495->writeToFile(outputFile, ___4478); writeMapOfPairsToObjects(outputFile, ___2455, ___4478); ___2343->writeToFile(outputFile, ___4478); writeMapOfScalarsToPtrs(outputFile, m_partitionMap, ___4478); writeVector(outputFile, m_partitionOwners, ___4478); } uint64_t Zone_s::sizeInFile(bool ___4478) const { uint64_t sizeInFile = 0; sizeInFile += stringSizeInFile(___2681, ___4478); sizeInFile += scalarSizeInFile((uint32_t)___2682, ___4478); sizeInFile += scalarSizeInFile(m_partitionOffset.i(), ___4478); sizeInFile += scalarSizeInFile(m_partitionOffset.___2103(), ___4478); sizeInFile += scalarSizeInFile(m_partitionOffset.___2132(), ___4478); sizeInFile += scalarSizeInFile(___2680.i(), ___4478); sizeInFile += scalarSizeInFile(___2680.___2103(), ___4478); sizeInFile += scalarSizeInFile(___2680.___2132(), ___4478); sizeInFile += scalarSizeInFile(___2619, ___4478); sizeInFile += scalarSizeInFile(___2620, ___4478); sizeInFile += scalarSizeInFile(___2612, ___4478); sizeInFile += scalarSizeInFile(___2501, ___4478); sizeInFile += scalarSizeInFile((uint32_t)___2456, ___4478); sizeInFile += scalarSizeInFile(___2649, ___4478);
sizeInFile += scalarSizeInFile(___2499, ___4478); sizeInFile += scalarSizeInFile(___2648, ___4478); std::vector<uint32_t> tempFieldDataTypes(___2458.size()); sizeInFile += vectorSizeInFile(tempFieldDataTypes, ___4478); sizeInFile += vectorSizeInFile(m_passiveVars, ___4478); std::vector<uint32_t> tempValueLocations(___2668.size()); sizeInFile += vectorSizeInFile(tempValueLocations, ___4478); sizeInFile += vectorSizeInFile(m_shareVarFromZone, ___4478); sizeInFile += scalarSizeInFile(m_shareConnectivityFromZone, ___4478); sizeInFile += m_ghostNodeInfo.sizeInFile(___4478); sizeInFile += m_ghostCellInfo.sizeInFile(___4478); sizeInFile += vectorOfPtrsSizeInFile(___2494, ___4478); sizeInFile += scalarSizeInFile((uint64_t)___2395, ___4478); if (___2682 != ___4702) sizeInFile += ___2495->sizeInFile(___4478); sizeInFile += mapOfPairsToObjectsSizeInFile(___2455, ___4478); sizeInFile += ___2343->sizeInFile(___4478); sizeInFile += mapOfScalarsToPtrsSizeInFile(m_partitionMap, ___4478); sizeInFile += vectorSizeInFile(m_partitionOwners, ___4478); return sizeInFile; } boost::shared_ptr<Zone_s> Zone_s::makePtr(___1397& inputFile, bool readASCII) { Zone_s* newZone = new Zone_s; readString(inputFile, newZone->___2681, readASCII); READ_ENUM(newZone->___2682, ZoneType_e, inputFile, readASCII); ___81 i, ___2103, ___2132; readScalar(inputFile, i, readASCII); readScalar(inputFile, ___2103, readASCII); readScalar(inputFile, ___2132, readASCII); newZone->m_partitionOffset = ___1842(i, ___2103, ___2132); readScalar(inputFile, i, readASCII); readScalar(inputFile, ___2103, readASCII); readScalar(inputFile, ___2132, readASCII); newZone->___2680 = ___1842(i, ___2103, ___2132); readScalar(inputFile, newZone->___2619, readASCII); readScalar(inputFile, newZone->___2620, readASCII); readScalar(inputFile, newZone->___2612, readASCII); readScalar(inputFile, newZone->___2501, readASCII); READ_ENUM(newZone->___2456, FaceNeighborMode_e, inputFile, readASCII); readScalar(inputFile, newZone->___2649, readASCII); readScalar(inputFile, newZone->___2499, readASCII); readScalar(inputFile, newZone->___2648, readASCII); READ_ENUM_VECTOR(newZone->___2458, FieldDataType_e, inputFile, readASCII); readVector(inputFile, newZone->m_passiveVars, readASCII); READ_ENUM_VECTOR(newZone->___2668, ValueLocation_e, inputFile, readASCII); readVector(inputFile, newZone->m_shareVarFromZone, readASCII); readScalar(inputFile, newZone->m_shareConnectivityFromZone, readASCII); newZone->m_ghostNodeInfo = GhostInfo_s(inputFile, readASCII); newZone->m_ghostCellInfo = GhostInfo_s(inputFile, readASCII); readVectorOfPtrs(inputFile, newZone->___2494, readASCII); newZone->___2398.resize(newZone->___2494.size()); readScalar(inputFile, newZone->___2395, readASCII);
if (newZone->___2682 != ___4702) newZone->___2495 = ___2728::makePtr(inputFile, readASCII); readMapOfPairsToObjects(inputFile, newZone->___2455, readASCII); newZone->___2343 = AuxData_s::makePtr(inputFile, readASCII); readMapOfScalarsToPtrs(inputFile, newZone->m_partitionMap, readASCII); readVector(inputFile, newZone->m_partitionOwners, readASCII); int64_t nodeCount; int64_t cellCount; getZoneCounts(nodeCount, cellCount, newZone->___2680, newZone->___2682); for(size_t ___4289 = 0; ___4289 < newZone->___2398.size(); ++___4289) { newZone->___2398[___4289] = TypedFieldDataFactory().make(newZone->___2458[___4289]); if (newZone->___2668[___4289] == ___4328) { newZone->___2398[___4289]->___2667 = ___4326; newZone->___2398[___4289]->___2666 = cellCount; } else { newZone->___2398[___4289]->___2667 = ___4328; newZone->___2398[___4289]->___2666 = nodeCount; } } return boost::shared_ptr<Zone_s>(newZone); } }}
