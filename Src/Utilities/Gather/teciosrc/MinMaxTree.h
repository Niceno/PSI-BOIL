 #pragma once
#include "MASTER.h"
#include "GLOBAL.h"
#include "SzlFileLoader.h"
#include "fileStuff.h"
#include "importSzPltFile.h"
#include "RawArray.h"
#include "readValueArray.h"
namespace tecplot { namespace ___3931 { class MinMaxTree { UNCOPYABLE_CLASS(MinMaxTree); public: typedef uint32_t EntryIndex_t; private: static EntryIndex_t const CHILDREN_BITS_PER_PARENT = 6; static EntryIndex_t const NUM_CHILDREN_PER_PARENT = (1<<CHILDREN_BITS_PER_PARENT); static EntryIndex_t const MAX_DEPTH = (24+CHILDREN_BITS_PER_PARENT-1)/CHILDREN_BITS_PER_PARENT; static size_t const MIN_ENTRIES_TO_ALLOCATE = 32; static size_t const ALLOCATION_EXPANSION_FACTOR = 2; ___2238<___2479> m_minMaxArraysByDepth;
 #ifndef NO_ASSERTS
EntryIndex_t m_size;
 #endif
public: MinMaxTree() {
 #ifndef NO_ASSERTS
m_size = 0;
 #endif
} ~MinMaxTree() {} inline void swap(MinMaxTree& ___2886) { ASSERT_ONLY( ___372 const thisWasEmpty = this->empty(); ) ASSERT_ONLY( ___372 const thisWasValidlyPopulated = this->isValidlyPopulated(EntryIndex_t(this->size())); ) ASSERT_ONLY( ___372 const otherWasEmpty = ___2886.empty(); ) ASSERT_ONLY( ___372 const otherWasValidlyPopulated = ___2886.isValidlyPopulated(EntryIndex_t(___2886.size())); ) m_minMaxArraysByDepth.swap(___2886.m_minMaxArraysByDepth);
 #ifndef NO_ASSERTS
using std::swap; swap(m_size, ___2886.m_size);
 #endif
ENSURE(EQUIVALENCE(thisWasEmpty, ___2886.empty())); ENSURE(EQUIVALENCE(thisWasValidlyPopulated, ___2886.isValidlyPopulated(EntryIndex_t(___2886.size())))); ENSURE(EQUIVALENCE(otherWasEmpty, this->empty())); ENSURE(EQUIVALENCE(otherWasValidlyPopulated, this->isValidlyPopulated(EntryIndex_t(this->size())))); } static EntryIndex_t getNumEntriesAtDepth( EntryIndex_t ___2793, EntryIndex_t depth) { REQUIRE(___2793 > 0); REQUIRE(depth <= MAX_DEPTH); EntryIndex_t const shift = depth*CHILDREN_BITS_PER_PARENT; EntryIndex_t const ___3356 = ( (___2793 - 1) >> shift ) + 1; return ___3356; } ___372 empty() const { ___372 const isEmpty = m_minMaxArraysByDepth.empty(); ENSURE(VALID_BOOLEAN(isEmpty)); ENSURE(EQUIVALENCE(isEmpty,m_size==0)); return isEmpty; } ___372 isPopulated() const { return !empty() && m_minMaxArraysByDepth[MAX_DEPTH-1][0].___2065(); }
 #ifndef NO_ASSERTS
size_t size() const { REQUIRE(EQUIVALENCE(m_size==0, m_minMaxArraysByDepth.empty())); REQUIRE(IMPLICATION(m_size>0, m_size==m_minMaxArraysByDepth[0].size())); return m_size; } ___372 isValidlyPopulated(EntryIndex_t ___2793) const { REQUIRE(___2793 == m_size); return m_minMaxArraysByDepth.size() == MAX_DEPTH && m_minMaxArraysByDepth[0].size() == ___2793 && m_minMaxArraysByDepth[0][0].___2065() && m_minMaxArraysByDepth[0][___2793/2].___2065() && m_minMaxArraysByDepth[0][___2793-1].___2065() && m_minMaxArraysByDepth[MAX_DEPTH/2].size() == getNumEntriesAtDepth(___2793,MAX_DEPTH/2) && m_minMaxArraysByDepth[MAX_DEPTH/2][0].___2065() && m_minMaxArraysByDepth[MAX_DEPTH/2][getNumEntriesAtDepth(___2793,MAX_DEPTH/2)/2].___2065() && m_minMaxArraysByDepth[MAX_DEPTH/2][getNumEntriesAtDepth(___2793,MAX_DEPTH/2)-1].___2065() && m_minMaxArraysByDepth[MAX_DEPTH-1].size() == getNumEntriesAtDepth(___2793,MAX_DEPTH-1) && m_minMaxArraysByDepth[MAX_DEPTH-1][0].___2065() && m_minMaxArraysByDepth[MAX_DEPTH-1][getNumEntriesAtDepth(___2793,MAX_DEPTH-1)/2].___2065() && m_minMaxArraysByDepth[MAX_DEPTH-1][getNumEntriesAtDepth(___2793,MAX_DEPTH-1)-1].___2065(); }
 #endif
public: uint64_t numBytesAllocated(uint64_t ___2793) const { REQUIRE(___2793 == m_size); uint64_t ___2777 = m_minMaxArraysByDepth.numBytesAllocated(MAX_DEPTH); if ( !m_minMaxArraysByDepth.empty() ) { for ( EntryIndex_t depth = 0; depth < MAX_DEPTH; depth++ ) { EntryIndex_t const numEntriesAtDepth = getNumEntriesAtDepth(EntryIndex_t(___2793), depth); ___2777 += m_minMaxArraysByDepth[depth].numBytesAllocated(numEntriesAtDepth); } } return ___2777; } ___372 allocUninitialized(EntryIndex_t ___2793) { REQUIRE(___2793>0);
 #ifndef NO_ASSERTS
m_size = ___2793;
 #endif
___372 ___2037 = m_minMaxArraysByDepth.alloc(MAX_DEPTH); for ( EntryIndex_t depth = 0; ___2037 && depth < MAX_DEPTH; ++depth ) { EntryIndex_t const numEntiresAtDepth = getNumEntriesAtDepth(___2793, depth); ___2037 = m_minMaxArraysByDepth[depth].alloc(numEntiresAtDepth); } if ( !___2037 ) ___935(); ENSURE(VALID_BOOLEAN(___2037)); ENSURE(EQUIVALENCE(___2037, !m_minMaxArraysByDepth.empty())); ENSURE(IMPLICATION(___2037, !m_minMaxArraysByDepth[0].empty())); return ___2037; } void initializeWithInvalidMinMaxes(EntryIndex_t ___2793) { REQUIRE(___2793>0 && ___2793 == m_size); REQUIRE(m_minMaxArraysByDepth.size()==MAX_DEPTH); ___476(___2793 == getNumEntriesAtDepth(___2793, 0)); for ( EntryIndex_t depth = 0; depth < MAX_DEPTH; ++depth ) { EntryIndex_t const numEntiresAtDepth = getNumEntriesAtDepth(___2793, depth); ___2479& ___2478 = m_minMaxArraysByDepth[depth]; for ( EntryIndex_t entry = 0; entry < numEntiresAtDepth; entry++ ) ___2478[entry].invalidate(); } ENSURE( !m_minMaxArraysByDepth[0][0].___2065() && !m_minMaxArraysByDepth[0][___2793/2].___2065() && !m_minMaxArraysByDepth[0][___2793-1].___2065() && !m_minMaxArraysByDepth[MAX_DEPTH-1][0].___2065() ); ENSURE( !isPopulated() ); } void ___935() { m_minMaxArraysByDepth.___935();
 #ifndef NO_ASSERTS
m_size = 0;
 #endif
} void getChildRangeUsingNumEntries( EntryIndex_t  parentPos, EntryIndex_t  numEntriesAtChildDepth, EntryIndex_t& childStart, EntryIndex_t& childEnd) const { REQUIRE(numEntriesAtChildDepth>0); REQUIRE(parentPos<numEntriesAtChildDepth*NUM_CHILDREN_PER_PARENT); childStart = parentPos<<CHILDREN_BITS_PER_PARENT; ___476(childStart == parentPos*NUM_CHILDREN_PER_PARENT); childEnd = std::min(childStart+NUM_CHILDREN_PER_PARENT, numEntriesAtChildDepth); ENSURE(childStart < childEnd); ENSURE(childEnd <= numEntriesAtChildDepth); } void getChildRange( EntryIndex_t  ___2793, EntryIndex_t  parentDepth, EntryIndex_t  parentPos, EntryIndex_t& childStart, EntryIndex_t& childEnd) const { REQUIRE(___2793 == m_size); REQUIRE(isValidlyPopulated(___2793)); REQUIRE(parentDepth>0); REQUIRE(parentDepth<=MAX_DEPTH); REQUIRE(parentPos<getNumEntriesAtDepth(___2793,parentDepth)); EntryIndex_t const childDepth = parentDepth-1; EntryIndex_t const numEntriesAtChildDepth = getNumEntriesAtDepth(___2793,childDepth); getChildRangeUsingNumEntries(parentPos, numEntriesAtChildDepth, childStart, childEnd); ENSURE(childStart < childEnd); ENSURE(childEnd <= getNumEntriesAtDepth(___2793,childDepth)); } ___2477 const& getMinMaxAtDepth(EntryIndex_t depth, EntryIndex_t pos) const { REQUIRE(depth < MAX_DEPTH); REQUIRE(pos < m_minMaxArraysByDepth[depth].size()); REQUIRE(!m_minMaxArraysByDepth[depth].empty()); ___2477 const& minMax = m_minMaxArraysByDepth[depth][pos]; ENSURE(minMax.___2065()); return minMax; } bool minMaxIsValidForEntry(EntryIndex_t entry) const { REQUIRE(entry < size()); bool const ___2065 = m_minMaxArraysByDepth[0][entry].___2065(); return ___2065; } ___2477 const& ___1757(EntryIndex_t entry) const { REQUIRE(entry < size()); ___2477 const& minMax = m_minMaxArraysByDepth[0][entry]; ENSURE(minMax.___2065()); return minMax; } void ___3497( EntryIndex_t entry, double       minVal, double       maxVal) { REQUIRE(entry < size()); REQUIRE(minVal <= maxVal); m_minMaxArraysByDepth[0][entry].___3497(minVal, maxVal); ENSURE(m_minMaxArraysByDepth[0][entry].___2065()); } void ___3497( EntryIndex_t  entry, ___2477 const& minMax) { REQUIRE(entry < size()); REQUIRE(minMax.___2065()); m_minMaxArraysByDepth[0][entry].___3497(minMax); ENSURE(m_minMaxArraysByDepth[0][entry].___2065()); } void populateTree(EntryIndex_t ___2793); ___372 populateTreeFromMinMax( ___2477 const& minMax) { ___372 ___2037 = allocUninitialized(1); if ( ___2037 ) { m_minMaxArraysByDepth[0][0] = minMax; populateTree(1); } else ___935(); ENSURE(IMPLICATION(___2037,isValidlyPopulated(1))); ENSURE(IMPLICATION(___2037,isPopulated())); ENSURE(IMPLICATION(!___2037,empty())); return ___2037; } ___372 populateTreeFromFile( ___1397& file, FieldDataType_e      ___1361, EntryIndex_t         ___2793, IODescription const& ___970) { REQUIRE(___2793>0); ___372 ___2037 = allocUninitialized(___2793); switch (___1361) { case FieldDataType_Float: ___2037 = ___2037 && readMinMaxArray<float>(file, 0, ___2793, m_minMaxArraysByDepth[0], ___970);
break; case FieldDataType_Double: ___2037 = ___2037 && readMinMaxArray<double>(file, 0, ___2793, m_minMaxArraysByDepth[0], ___970); break; case FieldDataType_Int32: ___2037 = ___2037 && readMinMaxArray<int32_t>(file, 0, ___2793, m_minMaxArraysByDepth[0], ___970); break; case FieldDataType_Int16: ___2037 = ___2037 && readMinMaxArray<int16_t>(file, 0, ___2793, m_minMaxArraysByDepth[0], ___970); break; case FieldDataType_Byte: case ___1363: ___2037 = ___2037 && readMinMaxArray<uint8_t>(file, 0, ___2793, m_minMaxArraysByDepth[0], ___970); break; default: ___476(___1303); ___2037 = ___1303; break; } if ( ___2037 ) populateTree(___2793); else ___935(); ENSURE(IMPLICATION(___2037,isValidlyPopulated(___2793))); ENSURE(IMPLICATION(___2037,isPopulated())); ENSURE(IMPLICATION(!___2037,empty())); return ___2037; } static void findEntriesContainingNVarValues( ___3267<MinMaxTree const*> const&     minMaxTrees, ___3267<double> const&                vals, EntryIndex_t                           ___2793, ___2088::___2978               ___2975, ___3267<___2088::SubzoneAddress>& entryAddresses) { size_t const numTrees = minMaxTrees.size(); REQUIRE(!minMaxTrees.empty()); REQUIRE(VALID_REF(minMaxTrees[0]) && minMaxTrees[0]->isValidlyPopulated(___2793)); REQUIRE(VALID_REF(minMaxTrees[numTrees/2]) && minMaxTrees[numTrees/2]->isValidlyPopulated(___2793)); REQUIRE(VALID_REF(minMaxTrees[numTrees-1]) && minMaxTrees[numTrees-1]->isValidlyPopulated(___2793)); REQUIRE(minMaxTrees.size() == vals.size()); REQUIRE(___2793 == minMaxTrees[0]->size() && ___2793 == minMaxTrees[numTrees/2]->size() && ___2793 == minMaxTrees[numTrees-1]->size()); if ( numTrees == 3 ) { MinMaxTree::findEntriesContaining3VarValues( *minMaxTrees[0], *minMaxTrees[1], *minMaxTrees[2], vals[0], vals[1], vals[2], ___2975, ___2793, entryAddresses); } else { EntryIndex_t startPos; EntryIndex_t endPos; minMaxTrees[0]->getChildRange(___2793, MinMaxTree::MAX_DEPTH, 0, startPos, endPos); MinMaxTree::recursivelyFindEntriesContainingNVarValues( minMaxTrees, vals, MinMaxTree::MAX_DEPTH-1, startPos, endPos, ___2793, ___2975, entryAddresses); } } static void findEntriesContaining3VarValues( MinMaxTree const&                      xMinMaxTree, MinMaxTree const&                      yMinMaxTree, MinMaxTree const&                      zMinMaxTree, double                                 xVal, double                                 yVal, double                                 zVal, ___2088::___2978               ___2975, EntryIndex_t                           ___2793, ___3267<___2088::SubzoneAddress>& entryAddresses) { REQUIRE(xMinMaxTree.isValidlyPopulated(___2793)); REQUIRE(yMinMaxTree.isValidlyPopulated(___2793)); REQUIRE(zMinMaxTree.isValidlyPopulated(___2793)); REQUIRE(MAX_DEPTH==4); EntryIndex_t const numEntriesAtDepth0 = ___2793;; ___476(numEntriesAtDepth0==getNumEntriesAtDepth(___2793,0)); EntryIndex_t const numEntriesAtDepth1 = getNumEntriesAtDepth(___2793,1);
EntryIndex_t const numEntriesAtDepth2 = getNumEntriesAtDepth(___2793,2); EntryIndex_t const numEntriesAtDepth3 = getNumEntriesAtDepth(___2793,3); EntryIndex_t depth3Start; EntryIndex_t depth3End; xMinMaxTree.getChildRangeUsingNumEntries(0, numEntriesAtDepth3, depth3Start, depth3End); for (EntryIndex_t depth3Pos = depth3Start; depth3Pos < depth3End; ++depth3Pos) { if ( xMinMaxTree.getMinMaxAtDepth(3,depth3Pos).containsValue(xVal) && yMinMaxTree.getMinMaxAtDepth(3,depth3Pos).containsValue(yVal) && zMinMaxTree.getMinMaxAtDepth(3,depth3Pos).containsValue(zVal) ) { EntryIndex_t depth2Start; EntryIndex_t depth2End; xMinMaxTree.getChildRangeUsingNumEntries(depth3Pos, numEntriesAtDepth2, depth2Start, depth2End); for (EntryIndex_t depth2Pos = depth2Start; depth2Pos < depth2End; ++depth2Pos) { if ( xMinMaxTree.getMinMaxAtDepth(2,depth2Pos).containsValue(xVal) && yMinMaxTree.getMinMaxAtDepth(2,depth2Pos).containsValue(yVal) && zMinMaxTree.getMinMaxAtDepth(2,depth2Pos).containsValue(zVal) ) { EntryIndex_t depth1Start; EntryIndex_t depth1End; xMinMaxTree.getChildRangeUsingNumEntries(depth2Pos, numEntriesAtDepth1, depth1Start, depth1End); for (EntryIndex_t depth1Pos = depth1Start; depth1Pos < depth1End; ++depth1Pos) { if ( xMinMaxTree.getMinMaxAtDepth(1,depth1Pos).containsValue(xVal) && yMinMaxTree.getMinMaxAtDepth(1,depth1Pos).containsValue(yVal) && zMinMaxTree.getMinMaxAtDepth(1,depth1Pos).containsValue(zVal) ) { EntryIndex_t depth0Start; EntryIndex_t depth0End; xMinMaxTree.getChildRangeUsingNumEntries(depth1Pos, numEntriesAtDepth0, depth0Start, depth0End); for (EntryIndex_t depth0Pos = depth0Start; depth0Pos < depth0End; ++depth0Pos) { if ( xMinMaxTree.getMinMaxAtDepth(0,depth0Pos).containsValue(xVal) && yMinMaxTree.getMinMaxAtDepth(0,depth0Pos).containsValue(yVal) && zMinMaxTree.getMinMaxAtDepth(0,depth0Pos).containsValue(zVal) ) { if (entryAddresses.empty()) entryAddresses.reserve(MIN_ENTRIES_TO_ALLOCATE); else if (entryAddresses.size() >= entryAddresses.capacity()) entryAddresses.reserve(entryAddresses.size() * ALLOCATION_EXPANSION_FACTOR); entryAddresses.append(___2088::SubzoneAddress(___2975, depth0Pos)); } } } } } } } } } private: static void recursivelyFindEntriesContainingNVarValues( ___3267<MinMaxTree const*> const&     minMaxTrees, ___3267<double> const&                vals, EntryIndex_t                           depth, EntryIndex_t                           startPos, EntryIndex_t                           endPos, EntryIndex_t                           ___2793, ___2088::___2978               ___2975, ___3267<___2088::SubzoneAddress>& entryAddresses); }; typedef ___2238<MinMaxTree>        MinMaxTreeArray; typedef ___2238<MinMaxTreeArray>   MinMaxTree2DArray; typedef ___2238<MinMaxTree2DArray> MinMaxTree3DArray; }}
