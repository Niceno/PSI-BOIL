 #pragma once
#include "SzlFileLoader.h"
#include "AltTecUtil.h"
#include "FieldData.h"
namespace tecplot { namespace ___3931 { class OrthogonalBisection { UNCOPYABLE_CLASS(OrthogonalBisection); public: enum BisectionType_e { BisectionType_ZoneCells, BisectionType_ZoneNodes }; private: static ___4350 const NUM_BISECTION_DIRECTIONS = 3; static ___2088::SubzoneOffset_t const  MAX_THREADS_PER_CORE = 4; static ___81 const MIN_THREADED_ITEM_RANGE_SIZE = 256; static ___81 const MIN_THREADED_SUBZONE_RANGE_SIZE = 1; ___4634 const               ___2675; BisectionType_e const           m_bisectionType; ___2088::ItemOffset_t const m_maxDomainSize; ___2088::SubzoneOffset_t m_maxThreadedJobs; ___2088::SubzoneOffset_t m_maxRecursion; ___81                   m_numItems; ___81                   m_numGhostItems; ___2088::SubzoneOffset_t m_numRecursionDepths; ___2088::SubzoneOffset_t m_numDomains; ___2238<___81>   m_itemList; ZoneType_e                      ___2682; ___2238<FieldDataPtr> m_nodalFieldDataPtrs; ___2238<FieldDataPtr> m_ccFieldDataPtrs; ___2238<UInt8Array>   m_reducedPrecisionSortDataArrays; public: OrthogonalBisection( ___4634               zone, BisectionType_e           bisectionType, ___2088::ItemOffset_t maxDomainSize); ~OrthogonalBisection(); ___372 performBisection(___37& ___36); ___372 getSzCoordByOriginalItemArray( ___37&               ___36, ItemAddressArray& szCoordsOfOriginalItems); ___81 queryNumItems() const { return m_numItems; } ___81 queryNumGhostItems() const { return m_numGhostItems; } ___81 queryPositionbyOffset(___81 ___2863) const { return m_itemList[___2863]; } ___2088::SubzoneOffset_t queryNumberDomains() const { return m_numDomains; } inline ___2088::ItemOffset_t getDomainSize(___2088::SubzoneOffset_t domain) const { REQUIRE(domain<m_numDomains); ___2088::ItemOffset_t domainSize; if ( domain < m_numDomains-1 ) domainSize = m_maxDomainSize; else { domainSize = ( m_numItems % m_maxDomainSize ); if ( domainSize == 0 ) domainSize = m_maxDomainSize; ___476(m_maxDomainSize*(m_numDomains-1) + domainSize == m_numItems); } ENSURE(domainSize > 0 && domainSize <= ___2088::MAX_ITEM_OFFSET+1); return domainSize; } void ___935(void); private: ___372 updateStatusLine( ___37&                  ___36, ___2088::SubzoneOffset_t recursionDepth); ___372 loadCoordinateVarZoneFieldData(___37& ___36, char axis); inline void getJobStartEndForRange( ___81                   rangeStart, ___81                   ___3266, ___2088::SubzoneOffset_t ___2116, ___2088::SubzoneOffset_t numJobs, ___81&                  jobStart, ___81&                  jobEnd) { REQUIRE(rangeStart < m_numItems); REQUIRE(___3266 > 0 && rangeStart+___3266 <= m_numItems); REQUIRE(___2116 < numJobs); REQUIRE(numJobs > 0); jobStart = ___81( rangeStart + (uint64_t(___3266)*___2116)/numJobs ); jobEnd = ___81( rangeStart + (uint64_t(___3266)*(___2116+1))/numJobs );
ENSURE(rangeStart<=jobStart && jobStart<jobEnd && jobEnd<=m_numItems); ENSURE(IMPLICATION(___2116==0, jobStart==rangeStart)); ENSURE(IMPLICATION(___2116==numJobs-1, jobEnd==rangeStart+___3266)); } void getMinMaxWeightOverRange( ___81                   rangeStart, ___81                   rangeEnd, ___2088::SubzoneOffset_t ___2116, ___2088::SubzoneOffset_t numJobs, ___4350                   axisDirToSplit, ___2477&                      weightMinMax); void rescaleWeightsOverRange( ___81                   rangeStart, ___81                   ___3266, ___2088::SubzoneOffset_t ___2116, ___2088::SubzoneOffset_t numJobs, ___4350                   axisDirToSplit, double                       scale, double                       ___2863); ___372 calcReducedPrecisionValues( ___37&                        ___36, ___81 const                   domainStart, ___81 const                   domainSize, ___4350 const                   axisDirToSplit, ___2088::SubzoneOffset_t const recursionDepth); ___372 splitDomain( ___37&                        ___36, ___81 const                   domainStart, ___81 const                   domainSize, ___4350 const                   axisDirToSplit, ___2088::SubzoneOffset_t const recursionDepth, ___2118                      ___2117); void getSzCoordsByRange( ___81                   rangeStart, ___81                   ___3266, ___2088::SubzoneOffset_t ___2116, ___2088::SubzoneOffset_t numJobs, ItemAddressArray&            szCoordArray); ___2088::SubzoneOffset_t calcNumDomains() const { return ___2088::SubzoneOffset_t((m_numItems+m_maxDomainSize-1)/m_maxDomainSize); } void getSubdomainInfo( ___81  domainStart, ___81  domainSize, ___81& leftOffset, ___81& leftSize, ___81& rightOffset, ___81& rightSize) const { REQUIRE(domainSize>0); INVARIANT(m_maxDomainSize>0); ___81 localDomainSplitSize = m_maxDomainSize; while ( localDomainSplitSize < (domainSize+1)/2 ) { localDomainSplitSize *= 2; ___476(localDomainSplitSize>0); } ___476(localDomainSplitSize<domainSize && domainSize<=2*int64_t(localDomainSplitSize)); leftOffset = domainStart; leftSize =  localDomainSplitSize * ___81( (domainSize+int64_t(localDomainSplitSize)*2-1) / (int64_t(localDomainSplitSize)*2) ); rightOffset = domainStart + leftSize; rightSize   = domainSize - leftSize; ENSURE(leftSize>=localDomainSplitSize && leftSize < domainSize); ENSURE(leftSize>=localDomainSplitSize && rightSize < domainSize); } ___2088::SubzoneOffset_t calcNumRecursionDepths() const { ___2088::SubzoneOffset_t numRecursionDepths = 0; ___81 largestDomainOffset = 0; ___81 largestDomainSize = m_numItems; while ( largestDomainSize > m_maxDomainSize ) { ___81 leftOffset; ___81 leftSize; ___81 rightOffset; ___81 rightSize; getSubdomainInfo(largestDomainOffset, largestDomainSize, leftOffset, leftSize, rightOffset, rightSize);
if ( leftSize >= rightSize ) { largestDomainSize = leftSize; largestDomainOffset = leftOffset; } else { largestDomainSize = rightSize; largestDomainOffset = rightOffset; } numRecursionDepths++; } return numRecursionDepths; } }; }}
