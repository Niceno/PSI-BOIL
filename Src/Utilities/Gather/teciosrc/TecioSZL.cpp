#include "ThirdPartyHeadersBegin.h"
#include <exception>
#include <iostream>
#include <limits>
#include <new>
#include <set>
#include <sstream>
#include <stdlib.h>
#include <string>
#include <utility>
#include <boost/algorithm/string.hpp>
#include <boost/assign.hpp>
#include <boost/foreach.hpp>
#include <boost/make_shared.hpp>
#include <boost/scoped_array.hpp>
#include <boost/scoped_ptr.hpp>
#include <boost/shared_ptr.hpp>
#include <boost/static_assert.hpp>
#include <boost/tokenizer.hpp>
#include <boost/unordered_map.hpp>
#include <boost/unordered_set.hpp>
 #if defined TECIOMPI
#include <iomanip>
#include <vector>
#include <mpi.h> 
#include "mpiDatatype.h"
#include "MPIUtil.h"
#include "TecioMPI.h"
 #endif 
#include "ThirdPartyHeadersEnd.h"
#include "MASTER.h"
#include "GLOBAL.h"
#include "ClassicFEZoneConnectivityWriter.h"
#include "ClassicZoneVariableWriter.h"
#include "CHARTYPE.h"
#include "CodeContract.h"
#include "CszConnectivity.h"
#include "DataSetWriter.h"
#include "DataWriteStatisticsInterface.h"
#include "exportSubzonePlt.h"
#include "fileio.h"
#include "fileStuff.h"
#include "FileStreamReader.h"
#include "FileStreamWriter.h"
#include "FileSystem.h"
#include "importSzPltFile.h"
 #if defined TECIOMPI
#include "DataSetWriterMPI.h"
#include "MPICommunicator.h"
#include "MPIFileReader.h"
#include "MPIFileWriter.h"
#include "MPINonBlockingCommunicationCollection.h"
 #endif
#include "readValueArray.h"
#include "SZLFEZoneWriter.h"
#include "SZLOrderedZoneWriter.h"
#include "TecioData.h"
#include "TecioSZL.h"
#include "TecioTecUtil.h"
#include "writeValueArray.h"
#include "ZoneMetadata.h"
#include "zoneUtil.h"
#include "TecplotVersion.h"
 #if defined MSWIN && defined _DEBUG
 #define ___3182(s) do { OutputDebugStringA(s); printf(s); } while (0)
 #define ___3183(s,a1) do { char ___416##__LINE__[4096]; sprintf(___416##__LINE__,s,a1); OutputDebugStringA(___416##__LINE__); printf(___416##__LINE__); } while (0)
 #define ___3184(s,a1,a2) do { char ___416##__LINE__[4096]; sprintf(___416##__LINE__,s,a1,a2); OutputDebugStringA(___416##__LINE__); printf(___416##__LINE__); } while (0)
 #define ___3185(s,a1,a2,a3) do { char ___416##__LINE__[4096]; sprintf(___416##__LINE__,s,a1,a2,a3); OutputDebugStringA(___416##__LINE__); printf(___416##__LINE__); } while (0)
 #define PRINT4(s,a1,a2,a3,a4) do { char ___416##__LINE__[4096]; sprintf(___416##__LINE__,s,a1,a2,a3,a4); OutputDebugStringA(___416##__LINE__); printf(___416##__LINE__); } while (0)
 #define PRINT5(s,a1,a2,a3,a4,a5) do { char ___416##__LINE__[4096]; sprintf(___416##__LINE__,s,a1,a2,a3,a4,a5); OutputDebugStringA(___416##__LINE__); printf(___416##__LINE__); } while (0)
 #else
 #define ___3182(s) printf(s)
 #define ___3183(s,a1) printf(s,a1)
 #define ___3184(s,a1,a2) printf(s,a1,a2)
 #define ___3185(s,a1,a2,a3) printf(s,a1,a2,a3)
 #define PRINT4(s,a1,a2,a3,a4) printf(s,a1,a2,a3,a4)
 #define PRINT5(s,a1,a2,a3,a4,a5) printf(s,a1,a2,a3,a4,a5)
 #endif
 #define ___23(n, T, s) (new T[n])
 #define ___1528(a, s) (delete[] a);
 #define ___2378 10
using namespace tecplot::___3931;
 #if defined TECIOMPI
using namespace tecplot::teciompi;
 #endif
bool _showMessage( MessageBoxType_e messageBoxType, char const*      ___2430) { switch(messageBoxType) { case ___2441: ___3183(___2430,"%s\n"); ___3182("...aborting.\n"); return false; case ___2445: case ___2446: ___3182("Warning: "); ___3183(___2430,"%s\n"); ___3182("...continuing.\n"); return true; case ___2442: ___3182("Information: "); ___3183(___2430,"%s\n"); ___3182("...continuing.\n"); return true; case ___2444: case ___2447: case ___2448: ___3182("Encountered question: "); ___3183(___2430,"%s\n"); ___3182("...assuming Yes and continuing.\n"); return true; default: return false; } } namespace tecplot { namespace tecioszl { namespace { size_t const SZPLT_READ_BUFFER_SIZE = 1048576; struct OutputInfo { OutputInfo() : m_numValuesWritten(0) , m_numErrs(0) , m_geom(tecioszl::___1554::invalidGeom()) , m_text(tecioszl::Text::invalidText()) {} OutputInfo( std::string const& ___4175, std::string const& ___4348, std::string const& ___1392, std::string const& ___3445, int32_t            ___1405, int32_t            debugLevel, int32_t            defaultVarType, OutputInfo*        gridOutputInfo) : ___2647(___4175) , m_variables(___4348) , ___2459(___1392) , ___2618(___3445) , m_fileType(___1405) , m_debugLevel(debugLevel) , m_defaultVarType(defaultVarType) , m_gridOutputInfo(gridOutputInfo) , m_numValuesWritten(0) , m_numErrs(0) , m_tecioData(___4175, ___4348, defaultVarType) , m_geom(tecioszl::___1554::invalidGeom()) , m_text(tecioszl::Text::invalidText()) , m_hasBeenFlushedToDisk(false) { size_t extensionPos = ___2459.find_last_of('.'); if (extensionPos == std::string::npos || (___2459.substr(extensionPos) != std::string(".szplt") && ___2459.substr(extensionPos) != std::string(".szptn"))) { ___2459 += ".szplt"; } } std::string       ___2647; std::string       m_variables; std::string       ___2459; std::string       ___2618; int32_t           m_fileType; int32_t           m_debugLevel; int32_t           m_defaultVarType; OutputInfo*       m_gridOutputInfo; uint64_t          m_numValuesWritten; int               m_numErrs; ___3968         m_tecioData; tecioszl::___1554    m_geom; tecioszl::Text    m_text; bool              m_hasBeenFlushedToDisk; boost::shared_ptr<___4014>  m_tecioTecUtil; boost::shared_ptr<DataSetWriter> m_dataSetWriter;
 #if defined TECIOMPI
MPI_Comm m_comm; boost::scoped_ptr<MPICommunicator> m_communicator; boost::scoped_ptr<MPINonBlockingCommunicationCollection> ___2394; int m_mainProcess; int m_localProcess;
 #endif
}; std::vector<boost::shared_ptr<OutputInfo> > outputInfos; boost::shared_ptr<OutputInfo> ___1810; class DataWriteStatistics : public ___934 { public: DataWriteStatistics() {} virtual ~DataWriteStatistics() {} virtual void addWriteTime(uint64_t  ) {} virtual void ___7(uint64_t  ) {} virtual void addTreeBytesWritten(uint64_t  ) {} virtual void setMemoryInfoString(std::string const&  ) {} }; bool getOutputInfo(OutputInfo** outputInfo, void* fileHandle, char const* routineName) { REQUIRE(VALID_REF(outputInfo)); REQUIRE(VALID_REF(fileHandle)); REQUIRE(VALID_REF(routineName)); *outputInfo = (OutputInfo*)fileHandle; if (!*outputInfo) { ___3183("Error in %s : invalid parameter fileHandle.\n", routineName); return false; } return true; } bool zoneOrPartitionDataAreComplete( OutputInfo*   outputInfo, Zone_s* const zonePtr, int32_t       zone, int32_t       ___2975, bool          checkConnectivity, char const*   routineName) { REQUIRE(VALID_REF(outputInfo)); REQUIRE(VALID_REF(zonePtr)); REQUIRE(zone > 0); REQUIRE(___2975 >= 0); REQUIRE(VALID_REF(routineName));
 #if defined TECIOMPI
bool thisProcessOwnsUnpartitionedZone = zonePtr->m_partitionOwners.size() == 1 && zonePtr->m_partitionOwners[0] == outputInfo->m_localProcess && zonePtr->m_partitionMap.empty(); if (!thisProcessOwnsUnpartitionedZone && !zonePtr->m_partitionOwners.empty()) { for (size_t i = 0; i < zonePtr->m_partitionOwners.size(); ++i) { if (zonePtr->m_partitionOwners[i] == outputInfo->m_localProcess) { int32_t partitionI = static_cast<int32_t>(i); Zone_s::ZoneMap::const_iterator it = zonePtr->m_partitionMap.find(partitionI); if (it == zonePtr->m_partitionMap.end()) { std::ostringstream ___2890; ___2890 << routineName << ": Partition " << partitionI << " of zone " << zone << " is owned by process " << outputInfo->m_localProcess << " but was never created." << std::endl; ___3183("Error in %s", ___2890.str().c_str()); ++outputInfo->m_numErrs; } else if (!zoneOrPartitionDataAreComplete(outputInfo, it->second.get(), zone, partitionI, checkConnectivity, routineName)) { return false; } } } return true; }
 #else
if (___2975 == 0 && !zonePtr->m_partitionMap.empty()) { for (Zone_s::ZoneMap::iterator valuePair = zonePtr->m_partitionMap.begin(); valuePair != zonePtr->m_partitionMap.end(); ++valuePair) { int32_t localPartition = valuePair->first; Zone_s* partitionPtr = valuePair->second.get(); if (!zoneOrPartitionDataAreComplete(outputInfo, partitionPtr, zone, localPartition, checkConnectivity, routineName)) return false; } return true; }
 #endif
bool ___3356 = true; for (size_t ___4334 = 0; ___4334 < zonePtr->___2494.size(); ++___4334) { if (!zonePtr->m_passiveVars[___4334] && !zonePtr->m_shareVarFromZone[___4334] && zonePtr->___2494[___4334]->storedValueCount() < zonePtr->___2494[___4334]->___2666) { std::ostringstream ___2890; int64_t valuesNeeded = zonePtr->___2494[___4334]->___2666 - zonePtr->___2494[___4334]->storedValueCount(); ___2890 << routineName << ": Not all variable values for zone " << zone; if (___2975 > 0) ___2890 << " partition " << ___2975; ___2890 << " have been written." << std::endl << "Currently need " << valuesNeeded << " for variable " << ___4334 + 1 << "." << std::endl; ___3183("Error in %s", ___2890.str().c_str()); ++outputInfo->m_numErrs; ___3356 = false; } } if (checkConnectivity) { if (zonePtr->___2495 && zonePtr->___2495->___2390 * zonePtr->___2495->___2498 > zonePtr->___2495->storedValueCount()) { int64_t valuesNeeded = zonePtr->___2495->___2390 * zonePtr->___2495->___2498 - zonePtr->___2495->storedValueCount(); std::ostringstream ___2890; ___2890 << routineName << ": Not all node map values for zone " << zone; if (___2975 > 0) ___2890 << " partition " << ___2975; ___2890 << " have been written." << std::endl << "Currently need " << valuesNeeded << " more values."; ___3183("Error in %s", ___2890.str().c_str()); ++outputInfo->m_numErrs; ___3356 = false; } } return ___3356; } bool dataAreComplete(OutputInfo* outputInfo, char const* routineName) { REQUIRE(VALID_REF(outputInfo)); REQUIRE(VALID_REF(routineName)); bool checkConnectivity = (outputInfo->m_fileType != 2); bool ___3356 = true; std::set<___3491> const zonesToWrite = outputInfo->m_tecioData.unflushedZoneSet(); for (std::set<___3491>::const_iterator it = zonesToWrite.begin(); it != zonesToWrite.end(); ++it) { int32_t zone = static_cast<int32_t>(*it); Zone_s* zonePtr = outputInfo->m_tecioData.zonePtr(zone); ___476(zonePtr); if (!zoneOrPartitionDataAreComplete(outputInfo, zonePtr, zone, 0, checkConnectivity, routineName)) ___3356 = false; } return ___3356; } ___372 includeRevisionNumber() { ___372 ___3356 = ___4224; char const* envName = "EXCLUDE_SZPLT_REVISION_NUMBER"; char const* envResult = getenv(envName); if (envResult != NULL) { if (boost::iequals(envResult, "TRUE")) ___3356 = ___1303; else if (boost::iequals(envResult, "FALSE")) ___3356 = ___4224; else fprintf(stderr, "Err: %s(%d): If environment variable (%s) is set, its value should be TRUE or FALSE; ignoring setting, (%s).", __FILE__, __LINE__, envName, envResult); } return ___3356; } void writeASCIIFileIndicator(bool const ___4478, FileWriterInterface &fileWriter) { char asciiFileIndicator[3]; if (___4478) asciiFileIndicator[0] = 'T'; else asciiFileIndicator[0] = 'F'; asciiFileIndicator[1] = '\r'; asciiFileIndicator[2] = '\n'; fileWriter.fwrite(asciiFileIndicator, 1, 3); }
 #if defined TECIOMPI
namespace { void renumberZones(OutputInfo& outputInfo) { std::vector<int32_t> sendCounts(1, 0); std::vector<int32_t> offsets(1, 0); std::vector<int32_t> zoneNumbers(1); std::set<___3491> unflushedZoneSet = outputInfo.m_tecioData.unflushedZoneSet(); int32_t receiveCount = 0; if (outputInfo.m_localProcess == outputInfo.m_mainProcess) { int32_t commSize; MPI_Comm_size(outputInfo.m_comm, &commSize); sendCounts.resize(commSize, 0); BOOST_FOREACH(___3491 ___4656, unflushedZoneSet) { Zone_s const* zonePtr = outputInfo.m_tecioData.zonePtr(static_cast<___4634>(___4656)); boost::unordered_set<int32_t> partitionOwners; for (size_t i = 0; i < zonePtr->m_partitionOwners.size(); ++i) { int32_t const owner = zonePtr->m_partitionOwners[i]; if (partitionOwners.insert(owner).second) { ++sendCounts[owner]; if (owner == outputInfo.m_localProcess) ++receiveCount; } } } int32_t totalSize = 0; offsets.resize(commSize + 1, 0); for (int32_t i = 0; i < commSize; ++i) { totalSize += sendCounts[i]; offsets[i + 1] = totalSize; } zoneNumbers.resize(totalSize); std::vector<int32_t> tempSendCounts(commSize, 0); BOOST_FOREACH(___3491 ___4656, unflushedZoneSet) { Zone_s const* zonePtr = outputInfo.m_tecioData.zonePtr(static_cast<___4634>(___4656)); boost::unordered_set<int32_t> partitionOwners; for (size_t i = 0; i < zonePtr->m_partitionOwners.size(); ++i) { int32_t owner = zonePtr->m_partitionOwners[i]; if (partitionOwners.insert(owner).second) { zoneNumbers[offsets[owner] + tempSendCounts[owner]++] = static_cast<int32_t>(___4656); } } } ___476(tempSendCounts == sendCounts); } else { receiveCount = static_cast<int32_t>(unflushedZoneSet.size()); } std::vector<int32_t> localZoneNumbers(receiveCount + 1); MPI_Scatterv( &zoneNumbers[0], &sendCounts[0], &offsets[0], MPI_INT32_T, &localZoneNumbers[0], receiveCount, MPI_INT32_T, outputInfo.m_mainProcess, outputInfo.m_comm); localZoneNumbers.resize(receiveCount); if (receiveCount > 0 && outputInfo.m_localProcess != outputInfo.m_mainProcess) outputInfo.m_tecioData.renumberZones(localZoneNumbers); } }
 #endif
int32_t writeAllZonesToSZLFile(OutputInfo* outputInfo, char const* routineName) { if (!dataAreComplete(outputInfo, routineName)) { ++outputInfo->m_numErrs; return -1; } outputInfo->m_tecioData.flattenSinglePartitionZones(); bool const ___4478 =
 #if defined WRITEASCII
true;
 #else
false;
 #endif
if (static_cast<DataFileType_e>(outputInfo->m_fileType) == END_DataFileType_e) { try { std::ostringstream ___2890; ___2890 << outputInfo->___2459 << ".test";
 #if defined TECIOMPI
MPIFileWriter fileWriter(___2890.str(), outputInfo->m_comm);
 #else
FileStreamWriter fileWriter(___2890.str());
 #endif
if (!fileWriter.open(false)) return 1; ___1391 myFileLoc = 0; writeASCIIFileIndicator(___4478, fileWriter);
 #if defined TECIOMPI
MPICommunicator communicator(outputInfo->m_comm); if (outputInfo->m_localProcess == outputInfo->m_mainProcess) { int commSize; MPI_Comm_size(outputInfo->m_comm, &commSize); ___1391 ___2826 = static_cast<___1391>(commSize); ___1391 sizeOfFileLoc = ___4478 ? 2 + ___199<___1391, false>::size : sizeof(___1391); ___1391 processFileLoc = 3 + (___2826 + 1) * sizeOfFileLoc; writeScalar(fileWriter, ___2826, ___4478); for (int i = 0; i < commSize; ++i) { writeScalar(fileWriter, processFileLoc, ___4478); if (i == outputInfo->m_localProcess) { myFileLoc = processFileLoc; processFileLoc += outputInfo->m_tecioData.sizeInFile(___4478); } else { communicator.sendScalar(processFileLoc, i, TecioMPI::ZONE_FILE_LOC); ___1391 zoneSize; communicator.receiveScalar(zoneSize, i, TecioMPI::ZONE_FILE_SIZE); processFileLoc += zoneSize; } } } else { ___1391 zoneSize = outputInfo->m_tecioData.sizeInFile(___4478); communicator.sendScalar(zoneSize, outputInfo->m_mainProcess, TecioMPI::ZONE_FILE_SIZE); communicator.receiveScalar(myFileLoc, outputInfo->m_mainProcess, TecioMPI::ZONE_FILE_LOC); }
 #else
___1391 ___2826 = 1; writeScalar(fileWriter, ___2826, ___4478); ___1391 fileLocLoc = fileWriter.fileLoc(); writeScalar(fileWriter, myFileLoc, ___4478); myFileLoc = fileWriter.fileLoc(); fileWriter.___3457(fileLocLoc); writeScalar(fileWriter, myFileLoc, ___4478);
 #endif
outputInfo->m_tecioData.writeToFile(fileWriter, myFileLoc, ___4478); } catch (...) { return -1; } return 0; } ___1386 ___1385( ___4478, static_cast<DataFileType_e>(outputInfo->m_fileType), DEFAULT_SUBZONE_MAX_IJK_DIM, DEFAULT_SUBZONE_MAX_FE_SIZE); ___1385.setFileVersion(SZPLT_CUR_WRITE_VERSION); ___1385.setCodeRevision(1); if (___1385.___842() == ___846) {
 #if defined TECIOMPI
___1810->___2394->___4444();
 #endif
try { outputInfo->m_tecioData.copyConnectivity(outputInfo->m_gridOutputInfo->m_tecioData); } catch (std::exception const& e) { ___3184("Error in %s: %s", routineName, e.what()); ++outputInfo->m_numErrs; return -1; } }
 #if defined TECIOMPI
renumberZones(*outputInfo);
 #endif
outputInfo->m_tecioTecUtil = boost::make_shared<___4014>(boost::ref(outputInfo->m_tecioData)); DataWriteStatistics ___933; boost::scoped_ptr<FileWriterInterface> szpltFile;
 #if defined TECIOMPI
szpltFile.reset(new MPIFileWriter(outputInfo->___2459.c_str(), outputInfo->m_comm));
 #else
szpltFile.reset(new FileStreamWriter(outputInfo->___2459.c_str()));
 #endif
if (___1385.___842() == ___846) { if (!outputInfo->m_gridOutputInfo || !outputInfo->m_gridOutputInfo->m_dataSetWriter) { ___3184("Error in %s: For SZL solution files (FileType = 2), you must output and call %s\n", routineName, routineName); ___3183("for a grid file (FileType = 1) prior to calling %s for the solution file.\n", routineName); ++outputInfo->m_numErrs; return -1; } outputInfo->m_dataSetWriter = outputInfo->m_gridOutputInfo->m_dataSetWriter; outputInfo->m_dataSetWriter->replaceDataSource(outputInfo->m_tecioTecUtil.get(), ___3499(0), ___3499(0)); } else {
 #if defined TECIOMPI
outputInfo->m_dataSetWriter = boost::make_shared<DataSetWriterMPI>( outputInfo->m_tecioTecUtil.get(), ___3499(0), ___3499(0), ___1385.___1755(), ___1385.___1754(), outputInfo->m_comm, outputInfo->m_mainProcess, outputInfo->m_localProcess);
 #else
outputInfo->m_dataSetWriter = boost::make_shared<DataSetWriter>( outputInfo->m_tecioTecUtil.get(), ___3499(0), ___3499(0), ___1385.___1755(), ___1385.___1754());
 #endif
} int32_t ___3356 = 0; if (!szpltFile->open(false)) { ___3356 = -1; ++outputInfo->m_numErrs; } else { szpltFile->___3492(___4478 ? ___4224 : ___1303); szpltFile->setDataFileType(___1385.___842());
 #if defined TECIOMPI
if (outputInfo->m_localProcess != outputInfo->m_mainProcess) { ___1390 szpltZoneHeaderFileLocs; if (outputInfo->m_tecioTecUtil->___894() && (!szpltZoneHeaderFileLocs.alloc(outputInfo->m_tecioTecUtil->___889()) || !outputInfo->m_dataSetWriter->writeDataSet(*szpltFile, szpltZoneHeaderFileLocs))) { ___3356 = -1; ++outputInfo->m_numErrs; } } else
 #endif
{ if (!___1240( *outputInfo->m_tecioTecUtil, *szpltFile, ___1385, includeRevisionNumber(), *outputInfo->m_dataSetWriter, ___3499(0), ___3499(0), ___933)) { ___3356 = -1; ++outputInfo->m_numErrs; } } } szpltFile->close(___3356 == 0); outputInfo->m_dataSetWriter->replaceDataSource(NULL, ___3499(0), ___3499(0)); return ___3356; } ___3499 zoneSetToWrite(OutputInfo* outputInfo) { ___3499 zoneSet = NULL; std::set<___3491> const zonesToWrite = outputInfo->m_tecioData.unflushedZoneSet(); if (!zonesToWrite.empty()) { zoneSet = outputInfo->m_tecioTecUtil->setAlloc(___4224); if (zoneSet) { for (std::set<___3491>::const_iterator it = zonesToWrite.begin(); it != zonesToWrite.end(); ++it) outputInfo->m_tecioTecUtil->setAddMember(zoneSet, *it, ___4224); } } return zoneSet; } void warnIfAppendingToExistingFiles(OutputInfo& outputInfo, FileWriterInterface& headerFile, char const* routineName) { if (headerFile.seekToFileEnd()) { uint64_t fileSize = headerFile.fileLoc(); if (fileSize > 0) { ___3185("Warning in %s: Appending to existing temporary files for file %s (%s, etc.).\n", routineName, outputInfo.___2459.c_str(), headerFile.___1392().c_str()); ___3183("If this is not the intent, you must delete the temporary files prior to calling %s.\n", routineName); ++outputInfo.m_numErrs; } headerFile.___3458(); } else { ___3184("Warning in %s: Error attempting file seek in file %s.\n", routineName, headerFile.___1392().c_str()); } } int32_t flushDataToIntermediateFiles(OutputInfo* outputInfo, int32_t numZonesToRetain, int32_t const* zonesToRetain, char const* routineName) { int32_t ___3356 = 0; if (!dataAreComplete(outputInfo, routineName)) { ++outputInfo->m_numErrs; ___3356 = -1; } outputInfo->m_tecioData.flattenSinglePartitionZones();
 #if defined TECIOMPI
int overallResult; MPI_Allreduce(&___3356, &overallResult, 1, MPI_INT, MPI_MIN, outputInfo->m_comm); ___3356 = overallResult;
 #else
if (___3356 == 0 && outputInfo->m_tecioData.empty()) return 0;
 #endif
bool const ___4478 =
 #if defined WRITEASCII
true;
 #else
false;
 #endif
___1386 ___1385( ___4478, static_cast<DataFileType_e>(outputInfo->m_fileType), DEFAULT_SUBZONE_MAX_IJK_DIM, DEFAULT_SUBZONE_MAX_FE_SIZE); ___1385.setFileVersion(SZPLT_CUR_WRITE_VERSION); ___1385.setCodeRevision(1); if (___3356 == 0 && ___1385.___842() == ___846) {
 #if defined TECIOMPI
___1810->___2394->___4444();
 #endif
try { outputInfo->m_tecioData.copyConnectivity(outputInfo->m_gridOutputInfo->m_tecioData); } catch (std::exception const& e) { ___3184("Error in %s: %s", routineName, e.what()); ++outputInfo->m_numErrs; ___3356 = -1; } }
 #if defined TECIOMPI
MPI_Allreduce(&___3356, &overallResult, 1, MPI_INT, MPI_MIN, outputInfo->m_comm); ___3356 = overallResult;
 #endif
uint64_t numHeadersInFile = 0; uint32_t numAuxDataInFile = 0; uint32_t numGeomsInFile = 0; uint32_t numTextsInFile = 0; uint32_t numCustomLabelsInFile = 0; std::string headerFileName = outputInfo->___2459 + HEADER_FILE_SUFFIX; std::string auxDataFileName = outputInfo->___2459 + AUX_DATA_FILE_SUFFIX; std::string geomFileName = outputInfo->___2459 + GEOMETRY_FILE_SUFFIX; std::string textFileName = outputInfo->___2459 + TEXT_FILE_SUFFIX; std::string customLabelsFileName = outputInfo->___2459 + CUSTOM_LABELS_FILE_SUFFIX;
 #if defined TECIOMPI
if (___3356 == 0 && outputInfo->m_localProcess == outputInfo->m_mainProcess) {
 #endif
FILE* testFile = filesystem::fileOpen(headerFileName, "r"); if (testFile) { fclose(testFile); boost::scoped_ptr<___1397> headerFileReader(new FileStreamReader(headerFileName.c_str())); headerFileReader->___3492(___1385.___2000()); if (headerFileReader->open() && !readValue<uint64_t, false>(*headerFileReader, numHeadersInFile, IODescription(SZPLT_NUM_INTERMEDIATE_HEADERS))) { ___3184("Error in %s: Error reading from file %s\n", routineName, headerFileName.c_str()); ++outputInfo->m_numErrs; return -1; } ___3943 ___3942 = DATASET_HEADER_TAG_MAP_INITIALIZER; ___3942[___241] = 0; boost::scoped_ptr<___1397> auxDataFileReader(new FileStreamReader(auxDataFileName)); auxDataFileReader->___3492(___1385.___2000()); if (!auxDataFileReader->open() || !readAuxDataCount(*auxDataFileReader, ___3942, numAuxDataInFile)) { ___3184("Error in %s: Error reading from file %s\n", routineName, auxDataFileName.c_str()); ++outputInfo->m_numErrs; return -1; } ___3942[___1579] = 0; boost::scoped_ptr<___1397> geomFileReader(new FileStreamReader(geomFileName)); geomFileReader->___3492(___1385.___2000()); if (!geomFileReader->open() || !readGeometriesCount(*geomFileReader, ___3942, numGeomsInFile)) { ___3184("Error in %s: Error reading from file %s\n", routineName, geomFileName.c_str()); ++outputInfo->m_numErrs; return -1; } ___3942[___4081] = 0; boost::scoped_ptr<___1397> textFileReader(new FileStreamReader(textFileName)); textFileReader->___3492(___1385.___2000()); if (!textFileReader->open() || !readTextsCount(*textFileReader, ___3942, numTextsInFile)) { ___3184("Error in %s: Error reading from file %s\n", routineName, textFileName.c_str()); ++outputInfo->m_numErrs; return -1; } ___3942[___793] = 0; boost::scoped_ptr<___1397> customLabelsFileReader(new FileStreamReader(customLabelsFileName)); customLabelsFileReader->___3492(___1385.___2000()); if (!customLabelsFileReader->open() || !readCustomLabelsCount(*customLabelsFileReader, ___3942, numCustomLabelsInFile)) { ___3184("Error in %s: Error reading from file %s\n", routineName, customLabelsFileName.c_str()); ++outputInfo->m_numErrs; return -1; } }
 #if defined TECIOMPI
}
 #endif
outputInfo->m_tecioTecUtil = boost::make_shared<___4014>(boost::ref(outputInfo->m_tecioData)); DataWriteStatistics ___933; boost::scoped_ptr<FileWriterInterface> headerFile; boost::scoped_ptr<FileWriterInterface> zoneDataFile; boost::scoped_ptr<FileWriterInterface> auxDataFile; boost::scoped_ptr<FileWriterInterface> geometryFile; boost::scoped_ptr<FileWriterInterface> textFile; boost::scoped_ptr<FileWriterInterface> customLabelsFile;
 #if defined TECIOMPI
headerFile.reset(new MPIFileWriter((outputInfo->___2459 + HEADER_FILE_SUFFIX).c_str(), outputInfo->m_comm)); zoneDataFile.reset(new MPIFileWriter((outputInfo->___2459 + ZONE_DATA_FILE_SUFFIX).c_str(), outputInfo->m_comm)); auxDataFile.reset(new MPIFileWriter((outputInfo->___2459 + AUX_DATA_FILE_SUFFIX).c_str(), outputInfo->m_comm)); geometryFile.reset(new MPIFileWriter((outputInfo->___2459 + GEOMETRY_FILE_SUFFIX).c_str(), outputInfo->m_comm)); textFile.reset(new MPIFileWriter((outputInfo->___2459 + TEXT_FILE_SUFFIX).c_str(), outputInfo->m_comm)); customLabelsFile.reset(new MPIFileWriter((outputInfo->___2459 + CUSTOM_LABELS_FILE_SUFFIX).c_str(), outputInfo->m_comm));
 #else
headerFile.reset(new FileStreamWriter((outputInfo->___2459 + HEADER_FILE_SUFFIX).c_str())); zoneDataFile.reset(new FileStreamWriter((outputInfo->___2459 + ZONE_DATA_FILE_SUFFIX).c_str())); auxDataFile.reset(new FileStreamWriter((outputInfo->___2459 + AUX_DATA_FILE_SUFFIX).c_str())); geometryFile.reset(new FileStreamWriter((outputInfo->___2459 + GEOMETRY_FILE_SUFFIX).c_str())); textFile.reset(new FileStreamWriter((outputInfo->___2459 + TEXT_FILE_SUFFIX).c_str())); customLabelsFile.reset(new FileStreamWriter((outputInfo->___2459 + CUSTOM_LABELS_FILE_SUFFIX).c_str()));
 #endif
___3499 zonesToWrite = zoneSetToWrite(outputInfo); if (___3356 == 0 && ___1385.___842() == ___846) { if (!outputInfo->m_gridOutputInfo || !outputInfo->m_gridOutputInfo->m_dataSetWriter) { ___3184("Error in %s: For SZL solution files (FileType = 2), you must output and call %s\n", routineName, routineName); ___3183("for a grid file (FileType = 1) prior to calling %s for the solution file.\n", routineName); ++outputInfo->m_numErrs; ___3356 = -1;
 #if defined TECIOMPI
MPI_Allreduce(&___3356, &overallResult, 1, MPI_INT, MPI_MIN, outputInfo->m_comm); ___3356 = overallResult;
 #endif
} outputInfo->m_dataSetWriter = outputInfo->m_gridOutputInfo->m_dataSetWriter; outputInfo->m_dataSetWriter->replaceDataSource(outputInfo->m_tecioTecUtil.get(), ___3499(0), ___3499(0)); } else { if (outputInfo->m_dataSetWriter) outputInfo->m_dataSetWriter->replaceDataSource(outputInfo->m_tecioTecUtil.get(), ___3499(0), zonesToWrite); else
 #if defined TECIOMPI
outputInfo->m_dataSetWriter = boost::shared_ptr<DataSetWriterMPI>(new DataSetWriterMPI( outputInfo->m_tecioTecUtil.get(), ___3499(0), zonesToWrite, ___1385.___1755(), ___1385.___1754(), outputInfo->m_comm, outputInfo->m_mainProcess, outputInfo->m_localProcess, true));
 #else
outputInfo->m_dataSetWriter = boost::make_shared<DataSetWriter>( outputInfo->m_tecioTecUtil.get(), ___3499(0), zonesToWrite, ___1385.___1755(), ___1385.___1754(), true);
 #endif
} if (___3356 == 0) { if (!headerFile->open(true) || !zoneDataFile->open(true) || !auxDataFile->open(true) || !geometryFile->open(true) || !textFile->open(true) || !customLabelsFile->open(true)) { ++outputInfo->m_numErrs; ___3356 = -1; }
 #if defined TECIOMPI
MPI_Allreduce(&___3356, &overallResult, 1, MPI_INT, MPI_MIN, outputInfo->m_comm); ___3356 = overallResult;
 #endif
} if (___3356 == 0) { if (!outputInfo->m_hasBeenFlushedToDisk) warnIfAppendingToExistingFiles(*outputInfo, *headerFile, routineName); headerFile->___3492(___4478 ? ___4224 : ___1303); zoneDataFile->___3492(___4478 ? ___4224 : ___1303); auxDataFile->___3492(___4478 ? ___4224 : ___1303); geometryFile->___3492(___4478 ? ___4224 : ___1303); textFile->___3492(___4478 ? ___4224 : ___1303); customLabelsFile->___3492(___4478 ? ___4224 : ___1303); headerFile->setDataFileType(___1385.___842()); zoneDataFile->setDataFileType(___1385.___842()); auxDataFile->setDataFileType(___1385.___842()); geometryFile->setDataFileType(___1385.___842()); textFile->setDataFileType(___1385.___842()); customLabelsFile->setDataFileType(___1385.___842());
 #if defined TECIOMPI
if (outputInfo->m_localProcess != outputInfo->m_mainProcess) { ___1390 szpltZoneHeaderFileLocs; if (outputInfo->m_tecioTecUtil->___894() && (!szpltZoneHeaderFileLocs.alloc(outputInfo->m_tecioTecUtil->___889()) || !outputInfo->m_dataSetWriter->writeDataSet(*zoneDataFile, szpltZoneHeaderFileLocs))) { ___3356 = -1; ++outputInfo->m_numErrs; } } else
 #endif
{ if (outputInfo->m_tecioTecUtil->___894() && !writeIntermediateFiles( *outputInfo->m_tecioTecUtil, *headerFile, *zoneDataFile, *auxDataFile, *geometryFile, *textFile, *customLabelsFile, ___1385, numHeadersInFile, numAuxDataInFile, numGeomsInFile, numTextsInFile, numCustomLabelsInFile, includeRevisionNumber(), *outputInfo->m_dataSetWriter, ___3499(0), zonesToWrite, ___933)) { ___3356 = -1; ++outputInfo->m_numErrs; } }
 #if defined TECIOMPI
outputInfo->___2394->___4444(); MPI_Allreduce(&___3356, &overallResult, 1, MPI_INT, MPI_MIN, outputInfo->m_comm); ___3356 = overallResult;
 #endif
} bool ___3359 = (___3356 == 0);
 #if defined TECIOMPI
if (outputInfo->m_localProcess != outputInfo->m_mainProcess) ___3359 = true;
 #endif
headerFile->close(___3359); zoneDataFile->close(___3359); auxDataFile->close(___3359); geometryFile->close(___3359); textFile->close(___3359); customLabelsFile->close(___3359); if ((DataFileType_e)outputInfo->m_fileType == ___843) outputInfo->m_dataSetWriter->clear(numZonesToRetain, zonesToRetain); outputInfo->m_tecioData.clear(numZonesToRetain, zonesToRetain); outputInfo->m_hasBeenFlushedToDisk = true; outputInfo->m_tecioTecUtil->___3482(&zonesToWrite); return ___3356; } int32_t renameFile(std::string const& currentName, std::string const &newName, char const* routineName) { if (filesystem::fileRename(currentName, newName) != 0) { ___3185("Error in %s: Cannot rename file %s to file %s.\n", routineName, currentName.c_str(), newName.c_str()); return -1; } return 0; } int32_t copyFileContents(std::string const& sourceFileName, FileWriterInterface& szpltFile, char const* routineName) { REQUIRE(!sourceFileName.empty()); REQUIRE(szpltFile.___2039()); REQUIRE(VALID_REF(routineName)); boost::scoped_ptr<___1397>sourceFile(new FileStreamReader(sourceFileName.c_str())); int32_t ___3356 = 0; if (!sourceFile->open()) { ___3356 = -1; } else { try { std::vector<unsigned char> ___416(SZPLT_READ_BUFFER_SIZE); size_t bytesRead = sourceFile->fread(&___416[0], 1, SZPLT_READ_BUFFER_SIZE); while (___3356 == 0 && bytesRead > 0) { if (szpltFile.fwrite(&___416[0], 1, bytesRead) != bytesRead) { ___3184("Error in %s: Error writing to file %s.\n", routineName, szpltFile.___1392().c_str()); ___3356 = -1; } bytesRead = sourceFile->fread(&___416[0], 1, SZPLT_READ_BUFFER_SIZE); } } catch (std::exception const& e) { ___3184("Error in %s: %s.\n", routineName, e.what()); ___3356 = -1; } } return ___3356; } std::vector<std::string> intermediateFileNames(std::string const& intermediateFileBaseName) { std::vector<std::string> fileSuffixes = boost::assign::list_of<std::string> (HEADER_FILE_SUFFIX) (ZONE_DATA_FILE_SUFFIX) (TEXT_FILE_SUFFIX) (GEOMETRY_FILE_SUFFIX) (AUX_DATA_FILE_SUFFIX) (CUSTOM_LABELS_FILE_SUFFIX); std::vector<std::string> ___3356; ___3356.reserve(fileSuffixes.size()); for (std::vector<std::string>::const_iterator it = fileSuffixes.begin(); it != fileSuffixes.end(); ++it) ___3356.push_back(intermediateFileBaseName + *it); return ___3356; } int32_t checkForMissingOrUnreadableIntermediateFiles(std::string const& intermediateFileBaseName, char const* routineName) { REQUIRE(VALID_REF(routineName)); std::string ___3356; std::vector<std::string> fileNames = intermediateFileNames(intermediateFileBaseName); for (std::vector<std::string>::const_iterator it = fileNames.begin(); it != fileNames.end(); ++it) { FILE* testFile = tecplot::filesystem::fileOpen(*it, "r"); if (testFile) fclose(testFile); else if (___3356.empty()) ___3356 = std::string("The following file(s) do not exist or are not readable:\n    ") + *it + "\n"; else ___3356 += std::string("    ") + *it + "\n"; } if (!___3356.empty()) { ___3184("Error(s) detected in %s. Files must exist and be readable.\n%s", routineName,
___3356.c_str()); return -1; } return 0; } int32_t checkForMissingOrUnwritableIntermediateFiles(std::string const& intermediateFileBaseName, char const* routineName) { REQUIRE(VALID_REF(routineName)); std::string readableResult; std::string writableResult; std::vector<std::string> fileNames = intermediateFileNames(intermediateFileBaseName); for (std::vector<std::string>::const_iterator it = fileNames.begin(); it != fileNames.end(); ++it) { FILE* testFile = tecplot::filesystem::fileOpen(*it, "r"); if (testFile) { fclose(testFile); testFile = tecplot::filesystem::fileOpen(*it, "r+"); if (testFile) fclose(testFile); else if (writableResult.empty()) writableResult = std::string("The following file(s) exist but are not writable:\n    ") + *it + "\n"; else writableResult += std::string("    ") + *it + "\n"; } else if (readableResult.empty()) { readableResult = std::string("The following file(s) do not exist or are not readable:\n    ") + *it + "\n"; } else { readableResult += std::string("    ") + *it + "\n"; } } if (!readableResult.empty() || !writableResult.empty()) { ___3184("Error(s) detected in %s. Files must exist and be readable and writable.\n%s", routineName, (readableResult + writableResult).c_str()); return -1; } return 0; } std::string getTempFileName(std::string const& fileBaseName) { std::ostringstream ___2890; ___2890 << fileBaseName << time(NULL); return ___2890.str(); } int32_t moveToTempFileIfExists(std::string const& ___1392, std::string& newFileName, char const* routineName) { FILE* fileHandle = tecplot::filesystem::fileOpen(___1392.c_str(), "r"); if (fileHandle) { fclose(fileHandle); fileHandle = tecplot::filesystem::fileOpen(___1392.c_str(), "rb+"); if (fileHandle) { fclose(fileHandle); newFileName = getTempFileName(___1392); if (renameFile(___1392, newFileName, routineName) != 0) { newFileName.clear(); return -1; } } else { ___3184("Error in %s: File %s is not writable.\n", routineName, ___1392.c_str()); return -1; } } return 0; } struct FileItems { ___3943     ___3942; ___4705 ___4704; ___1390    ___4627; uint64_t        ___2841; uint64_t        ___2844; }; } int32_t convertIntermediateFilesToSZLFile( void*              fileHandle, std::string const& intermediateFileBaseName, bool               cleanup, std::string const& szpltFileName, char const*        routineName) { REQUIRE(VALID_REF_OR_NULL(fileHandle)); REQUIRE(VALID_REF(routineName)); OutputInfo* outputInfo = reinterpret_cast<OutputInfo*>(fileHandle); int32_t ___3356 = 0;
 #if defined TECIOMPI
if (!outputInfo || outputInfo->m_mainProcess == outputInfo->m_localProcess) {
 #else
___4276(outputInfo);
 #endif
try { if (cleanup) ___3356 = checkForMissingOrUnwritableIntermediateFiles(intermediateFileBaseName, routineName); else ___3356 = checkForMissingOrUnreadableIntermediateFiles(intermediateFileBaseName, routineName); std::string tempFileName; if (___3356 == 0) { ___3356 = moveToTempFileIfExists(szpltFileName, tempFileName, routineName); } bool datFileMoved = false; if (___3356 == 0 && cleanup) { ___3356 = renameFile(intermediateFileBaseName + ZONE_DATA_FILE_SUFFIX, szpltFileName, routineName); if (___3356 == 0) datFileMoved = true; } boost::scoped_ptr<FileWriterInterface>szpltFile(new FileStreamWriter(szpltFileName)); if (___3356 == 0 && !szpltFile->open(true)) { ___3184("Error in %s: Cannot open file %s for writing.\n", routineName, szpltFile->___1392().c_str()); ___3356 = -1; } if (___3356 == 0 && !cleanup) { ___3356 = copyFileContents(intermediateFileBaseName + ZONE_DATA_FILE_SUFFIX, *szpltFile, routineName); } std::string headerFileName = intermediateFileBaseName + HEADER_FILE_SUFFIX; boost::scoped_ptr<___1397>headerFile(new FileStreamReader(headerFileName)); if (___3356 == 0) { if (!headerFile->open()) ___3356 = -1; } ___1386 ___1385; if (___3356 == 0) { boost::scoped_ptr<___1397> szpltFileReader(new FileStreamReader(szpltFileName)); uint64_t       byteOrderIndicator; uint64_t       dataSetHeaderLocation; if (szpltFileReader->open() && readDataFileHeader(*szpltFileReader, ___1385, byteOrderIndicator, dataSetHeaderLocation)) { headerFile->___3492(szpltFileReader->___2000()); szpltFile->___3492(szpltFileReader->___2000()); szpltFile->setDataFileType(szpltFileReader->___842()); } else { ___3356 = -1; } szpltFileReader->close(true); } uint64_t numHeadersInFile = 0; if (___3356 == 0) { if (!readValue<uint64_t, false>(*headerFile, numHeadersInFile, IODescription(SZPLT_NUM_INTERMEDIATE_HEADERS))) { ___3356 = -1; } else if (numHeadersInFile == 0) { ___3184("Error in %s: The header file (%s) contains no headers.\n", routineName, headerFileName.c_str()); ___3356 = -1; } } ___2238<FileItems> fileItemsArray; if (___3356 == 0 && !fileItemsArray.alloc(numHeadersInFile)) { ___3183("Error in %s: Out of memory while reading files.\n", routineName); ___3356 = -1; } std::string dataSetTitle; uint64_t    totalNumZones = 0; uint64_t    ___2841 = 0; for (uint64_t i = 0; ___3356 == 0 && i < numHeadersInFile; ++i) { ___372 ___2037 = readDataSetHeaderTags(*headerFile, ___1385, fileItemsArray[i].___3942); std::string localDataSetTitle; ___2037 = ___2037 && readDataSetHeader(*headerFile, fileItemsArray[i].___3942, localDataSetTitle, fileItemsArray[i].___4704, fileItemsArray[i].___4627); if (___2037) { fileItemsArray[i].___2844 = fileItemsArray[i].___3942[___2847]; fileItemsArray[i].___2841 = fileItemsArray[i].___3942[___2843]; if (i == 0) { dataSetTitle = localDataSetTitle; ___2841 = fileItemsArray[i].___2841; } else if (fileItemsArray[i].___2841 != ___2841) { ___3183("Error in %s: Inconsistent number of variables between successive file flushes. Cannot continue.", routineName);
___3356 = -1; } totalNumZones += fileItemsArray[i].___2844; } else { ___3356 = -1; } } ___4705 ___4704; ___1390 ___4627; if (___3356 == 0 && totalNumZones > 0) { if (!___4627.alloc(totalNumZones) || !___4704.alloc(totalNumZones, ___2841)) { ___3183("Error in %s: Out of memory allocating data set header arrays.\n", routineName); ___3356 = -1; } uint64_t zoneOffset = 0; for (uint64_t i = 0; ___3356 == 0 && i < numHeadersInFile; ++i) { for (uint64_t zone = 0; zone < fileItemsArray[i].___2844; ++zone) { ___4627[zoneOffset + zone] = fileItemsArray[i].___4627[zone]; if (!___4704.assign(fileItemsArray[i].___4704, zoneOffset, 0)) { ___3183("Error in %s: Out of memory copying data set header arrays.\n", routineName); ___3356 = -1; } } zoneOffset += fileItemsArray[i].___2844; } } ___3943 ___3942 = DATASET_HEADER_TAG_MAP_INITIALIZER; if (___3356 == 0) { ___3942[___2847] = totalNumZones; ___3942[___2843] = ___2841; ___3942[SUBZONE_MAX_I_SIZE_TAG] = fileItemsArray[0].___3942[SUBZONE_MAX_I_SIZE_TAG]; ___3942[SUBZONE_MAX_J_SIZE_TAG] = fileItemsArray[0].___3942[SUBZONE_MAX_J_SIZE_TAG]; ___3942[SUBZONE_MAX_K_SIZE_TAG] = fileItemsArray[0].___3942[SUBZONE_MAX_K_SIZE_TAG]; ___3942[SUBZONE_MAX_FE_SIZE_TAG] = fileItemsArray[0].___3942[SUBZONE_MAX_FE_SIZE_TAG]; szpltFile->seekToFileEnd(); } std::string auxDataFileName = intermediateFileBaseName + AUX_DATA_FILE_SUFFIX; if (___3356 == 0) { ___3942[___241] = szpltFile->fileLoc(); ___3356 = copyFileContents(auxDataFileName, *szpltFile, routineName); } std::string geometryFileName = intermediateFileBaseName + GEOMETRY_FILE_SUFFIX; if (___3356 == 0) { ___3942[___1579] = szpltFile->fileLoc(); ___3356 = copyFileContents(geometryFileName, *szpltFile, routineName); } std::string textFileName = intermediateFileBaseName + TEXT_FILE_SUFFIX; if (___3356 == 0) { ___3942[___4081] = szpltFile->fileLoc(); ___3356 = copyFileContents(textFileName, *szpltFile, routineName); } std::string customLabelsFileName = intermediateFileBaseName + CUSTOM_LABELS_FILE_SUFFIX; if (___3356 == 0) { ___3942[___793] = szpltFile->fileLoc(); ___3356 = copyFileContents(customLabelsFileName, *szpltFile, routineName); } if (___3356 == 0) { ___1391 dataSetHeaderLocation = szpltFile->fileLoc(); ___372 dataSetIsAvailable = (totalNumZones > 0); DataWriteStatistics ___933; if (!writeDataSetHeaders(*szpltFile, dataSetIsAvailable, dataSetTitle, static_cast<___4350>(___2841), static_cast<___4634>(totalNumZones), ___3942, ___4704, ___4627, ___933) || !szpltFile->___3458() || !___4514(*szpltFile, SZPLT_FILE_TYPE, SZPLT_CUR_WRITE_VERSION, includeRevisionNumber(), dataSetHeaderLocation)) { ___3356 = -1; } } if (___3356 == 0 && !szpltFile->close(true)) { ___3184("Error in %s: Error attempting to close file %s.\n", routineName, szpltFile->___1392().c_str());
___3356 = -1; } if (___3356 == 0) { if (!tempFileName.empty()) filesystem::fileRemove(tempFileName); headerFile->close(!cleanup); if (cleanup) { filesystem::fileRemove(auxDataFileName); filesystem::fileRemove(geometryFileName); filesystem::fileRemove(textFileName); filesystem::fileRemove(customLabelsFileName); } } else { headerFile->close(true); if (cleanup) { szpltFile->close(true); if (datFileMoved) filesystem::fileRename(szpltFileName, intermediateFileBaseName + ZONE_DATA_FILE_SUFFIX); } else { szpltFile->close(false); } if (!tempFileName.empty()) filesystem::fileRename(tempFileName, szpltFileName); } } catch (std::bad_alloc const&) { ___3183("Error in %s: Out of memory.\n", routineName); ___3356 = -1; }
 #if defined TECIOMPI
} if (outputInfo) MPI_Bcast(&___3356, 1, MPI_INT, outputInfo->m_mainProcess, outputInfo->m_comm);
 #endif
return ___3356; } int32_t tecFileWriterOpen_SZL( char const* ___1392, char const* dataSetTitle, char const* variableList, int32_t     ___1405, int32_t     defaultVarType, void*       gridFileHandle, void**      fileHandle) { try { OutputInfo* gridOutputInfo = (OutputInfo*)gridFileHandle; if (___1405 == 2) { if (!gridOutputInfo) { ___3182("Error in tecFileWriterOpen: You must supply an open grid file (FileType = 1)\nto output a solution file (FileType = 2).\n"); return -1; } if (gridOutputInfo->m_debugLevel) { ___3182("Writing grid file prior to opening first solution file.\n"); } if (!gridOutputInfo->m_dataSetWriter && writeAllZonesToSZLFile(gridOutputInfo, "tecFileWriterOpen") != 0) { return -1; } } OutputInfo* outputInfo = new OutputInfo( dataSetTitle, variableList, ___1392, ".", ___1405, 0, defaultVarType, gridOutputInfo); *fileHandle = outputInfo;
 #if defined TECIOMPI
outputInfo->m_comm = MPI_COMM_SELF; outputInfo->m_communicator.reset(new MPICommunicator(MPI_COMM_SELF)); outputInfo->___2394.reset(new MPINonBlockingCommunicationCollection(MPI_COMM_SELF)); outputInfo->m_localProcess = 0; outputInfo->m_mainProcess = 0;
 #endif
} catch (std::exception const& e) { ___3183("Error in tecFileWriterOpen: %s\n", e.what()); return -1; } return 0; } int32_t tecFileSetDiagnosticsLevel_SZL(void* fileHandle, int32_t level) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecFileSetDiagnosticsLevel")) return -1; outputInfo->m_debugLevel = level; if (outputInfo->m_debugLevel) { ___3183("Enabling diagnostics for file \"%s\"\n", outputInfo->___2459.c_str()); ___3183("NumVars = %d\n", outputInfo->m_tecioData.___2841()); } return 0; }
 #if defined TECIOMPI
namespace {
 #if !defined NO_ASSERTS
size_t mpiSizeof(MPI_Datatype mpiDatatype) { int datatypeSize; if (MPI_Type_size(mpiDatatype, &datatypeSize) != MPI_SUCCESS) return 0; else return static_cast<size_t>(datatypeSize); }
 #endif
bool mpiBroadcastString(std::string& str, OutputInfo& outputInfo) { int length = static_cast<int>(str.size()); if (MPI_Bcast(&length, 1, MPI_INT, outputInfo.m_mainProcess, outputInfo.m_comm) != MPI_SUCCESS) return false; str.resize(static_cast<size_t>(length)); return (MPI_Bcast(&str[0], length, MPI_CHAR, outputInfo.m_mainProcess, outputInfo.m_comm) == MPI_SUCCESS); } int32_t szlMPIInit(OutputInfo* outputInfo, MPI_Comm comm, int mainProcess) { int32_t  ___3356 = 0; int rank; if (MPI_Comm_rank(comm, &rank) != MPI_SUCCESS) ___3356 = -1; if (___3356 == 0) { outputInfo->m_comm = comm; outputInfo->m_communicator.reset(new MPICommunicator(comm)); outputInfo->___2394.reset(new MPINonBlockingCommunicationCollection(comm)); outputInfo->m_mainProcess = mainProcess; outputInfo->m_localProcess = rank; if (!mpiBroadcastString(outputInfo->___2459, *outputInfo)) ___3356 = -1; } return ___3356; } } int32_t tecMPIInitialize_SZL(void* fileHandle, MPI_Comm communicator, int32_t mainRank) { BOOST_STATIC_ASSERT(sizeof(int) == 4); INVARIANT(mpiSizeof(MPI_INT) == 4); OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecMPIInitialize")) return -1; return szlMPIInit(outputInfo, communicator, mainRank); }
 #endif
namespace { char const* zoneTypeStrings[] = { "ORDERED", "FELINESEG", "FETRIANGLE", "FEQUADRILATERAL", "FETETRAHEDRON", "FEBRICK", "FEPOLYGON", "FEPOLYHEDRON" }; char const* varTypeStrings[] = { "", "FLOAT", "DOUBLE", "INT32", "INT16", "BYTE" }; void printVarInfo(int32_t const* varTypes, int32_t const* ___3549, int ___2841) { if (___3549) { std::ostringstream ___2890; for (int i = 0; i < ___2841; ++i) { if (i > 0) ___2890 << ","; ___2890 << ___3549[i]; } ___3183("      shareVarFromZone = %s\n", ___2890.str().c_str()); } else if (varTypes) { std::ostringstream ___2890; for (int i = 0; i < ___2841; ++i) { if (i > 0) ___2890 << ","; ___2890 << varTypeStrings[varTypes[i]]; } ___3183("      varTypes = %s\n", ___2890.str().c_str()); } } } int32_t tecZoneCreateIJK_SZL( void*          fileHandle, char const*    ___4688, int64_t        imax, int64_t        jmax, int64_t        kmax, int32_t const* varTypes, int32_t const* ___3549, int32_t const* valueLocations, int32_t const* ___2980, int32_t        shareFaceNeighborsFromZone, int64_t        ___2800, int32_t        ___1282, int32_t*       zone) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecZoneCreateIJK")) return -1; try { outputInfo->m_tecioData.___19( ___4688, 0, imax, jmax, kmax, 0.0, 0, 0, ___2800, ___1282, 0, 0, 0, varTypes, ___2980, valueLocations, ___3549, shareFaceNeighborsFromZone); *zone = static_cast<int32_t>(outputInfo->m_tecioData.___2844()); outputInfo->m_numValuesWritten = 0; if (outputInfo->m_debugLevel) { ___3183("Creating Zone %d:\n", outputInfo->m_tecioData.___2844()); ___3183("      Title = %s\n", ___4688); ___3182("      Type  = ORDERED\n"); ___3183("      IMax  = %" PRId64 "\n", imax); ___3183("      JMax  = %" PRId64 "\n", jmax); ___3183("      KMax  = %" PRId64 "\n", kmax); printVarInfo(varTypes, ___3549, outputInfo->m_tecioData.___2841()); } } catch (std::exception const& e) { ___3183("Error in tecZoneCreateIJK: %s\n", e.what()); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecZoneCreateFE_SZL( void*          fileHandle, char const*    ___4688, int32_t        ___4690, int64_t        ___2819, int64_t        ___2779, int32_t const* varTypes, int32_t const* ___3549, int32_t const* valueLocations, int32_t const* ___2980, int32_t        ___3547, int64_t        ___2800, int32_t        ___1282, int32_t*       zone) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecZoneCreateFE")) return -1; try { outputInfo->m_tecioData.___19( ___4688, ___4690, ___2819, ___2779, 0, 0.0, 0, 0, ___2800, ___1282, 0, 0, 0, varTypes, ___2980, valueLocations, ___3549, ___3547); *zone = static_cast<int32_t>(outputInfo->m_tecioData.___2844()); outputInfo->m_numValuesWritten = 0; if (outputInfo->m_debugLevel)
{ ___3183("Creating Zone %d:\n", outputInfo->m_tecioData.___2844()); ___3183("      Title = %s\n", ___4688); ___3183("      Type  = %s\n", zoneTypeStrings[___4690]); ___3183("      NumNodes  = %" PRId64 "\n", ___2819); ___3183("      NumCells  = %" PRId64 "\n", ___2779); printVarInfo(varTypes, ___3549, outputInfo->m_tecioData.___2841()); } } catch (std::exception const& e) { ___3183("Error in tecZoneCreateFE: %s\n", e.what()); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecZoneCreatePoly_SZL( void*          fileHandle, char const*    ___4688, int32_t        ___4690, int64_t        ___2819, int64_t        numFaces, int64_t        ___2779, int64_t        ___4190, int32_t const* varTypes, int32_t const* ___3549, int32_t const* valueLocations, int32_t const* ___2980, int32_t        ___3547, int64_t        ___2784, int64_t        ___4186, int32_t*       zone) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecZoneCreatePoly")) return -1; try { outputInfo->m_tecioData.___19( ___4688, ___4690, ___2819, ___2779, numFaces, 0.0, 0, 0, 0, 0, ___4190, ___2784, ___4186, varTypes, ___2980, valueLocations, ___3549, ___3547); *zone = static_cast<int32_t>(outputInfo->m_tecioData.___2844()); outputInfo->m_numValuesWritten = 0; if (outputInfo->m_debugLevel) { ___3183("Creating Zone %d:\n", outputInfo->m_tecioData.___2844()); ___3183("      Title = %s\n", ___4688); ___3183("      Type  = %s\n", zoneTypeStrings[___4690]); ___3183("      NumNodes  = %" PRId64 "\n", ___2819); ___3183("      NumFaces  = %" PRId64 "\n", numFaces); ___3183("      NumCells  = %" PRId64 "\n", ___2779); printVarInfo(varTypes, ___3549, outputInfo->m_tecioData.___2841()); } } catch (std::exception const& e) { ___3183("Error in tecZoneCreatePoly: %s\n", e.what()); ++outputInfo->m_numErrs; return -1; } return 0; } namespace { bool getOutputInfoAndZonePtr(OutputInfo** outputInfo, Zone_s** zonePtr, void* fileHandle, int32_t zone, char const* routineName) { REQUIRE(VALID_REF(outputInfo)); REQUIRE(VALID_REF(zonePtr)); REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(routineName)); if (!getOutputInfo(outputInfo, fileHandle, routineName)) return false; if (zone <= 0 || !(*outputInfo)->m_tecioData.zonePtr(zone)) { ___3184("Error in %s : invalid zone input parameter (%d).\n", routineName, zone); ++(*outputInfo)->m_numErrs; return false; } *zonePtr = (*outputInfo)->m_tecioData.zonePtr(zone); return true; } } int32_t tecZoneSetUnsteadyOptions_SZL( void*   fileHandle, int32_t zone, double  ___3638, int32_t ___3783) { OutputInfo* outputInfo; Zone_s* zonePtr; if (!getOutputInfoAndZonePtr(&outputInfo, &zonePtr, fileHandle, zone, "tecZoneSetUnsteadyOptions")) return -1; if (___3783 < 0) { ___3183("Error in tecZoneSetUnsteadyOptions : invalid strandID input parameter (%d).\n", ___3783);
++outputInfo->m_numErrs; return -1; } zonePtr->___2619 = ___3638; zonePtr->___2620 = ___3783; return 0; } int32_t tecZoneSetParentZone_SZL(void* fileHandle, int32_t zone, int32_t ___2972) { OutputInfo* outputInfo; Zone_s* zonePtr; if (!getOutputInfoAndZonePtr(&outputInfo, &zonePtr, fileHandle, zone, "tecZoneSetParentZone")) return -1; if (zone == ___2972 || outputInfo->m_tecioData.___2844() <= ___2972) { ___3183("Error in tecZoneSetParentZone : invalid parentZone input parameter (%d).\n", ___2972); ++outputInfo->m_numErrs; return -1; } zonePtr->___2612 = ___2972; return 0; }
 #if defined TECIOMPI
namespace { int32_t storeZonePartitionInfo( OutputInfo*    outputInfo, int32_t const  npartitions, int32_t const* ptnworkers, char const*    errorMessagePreamble) { try { std::vector<int32_t> partitionOwners(ptnworkers, ptnworkers + npartitions); bool keepZone = false; if (outputInfo->m_localProcess == outputInfo->m_mainProcess) { keepZone = true; } else { BOOST_FOREACH(int32_t owner, partitionOwners) { if (owner == outputInfo->m_localProcess) keepZone = true; } } if (keepZone) outputInfo->m_tecioData.setPartitionOwners(partitionOwners); else outputInfo->m_tecioData.dropLastZone(); } catch (std::exception const& e) { ___3184("%s: %s\n", errorMessagePreamble, e.what()); ++(outputInfo->m_numErrs); return -1; } return 0; } } int32_t tecZoneMapPartitionsToMPIRanks_SZL( void*          fileHandle, int32_t        numPartitions, int32_t const* mpiRanksForPartitions) { REQUIRE(numPartitions > 0); REQUIRE(VALID_REF(mpiRanksForPartitions)); OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecZoneMapPartitionsToMPIRanks")) return -1; return storeZonePartitionInfo(outputInfo, numPartitions, mpiRanksForPartitions, "Error in tecZoneMapPartitionsToMPIRanks"); }
 #endif
namespace { template <typename T> int32_t fePartitionCreate( char const*    routineName, void*          fileHandle, int32_t        zone, int32_t        ___2975, int64_t        ___2819, int64_t        ___2779, int64_t        numGhostNodes, T const*       ghostNodes, int32_t const* neighborPartitions, T const*       neighborPartitionNodes, int64_t        numGhostCells, T const*       ghostCells) { OutputInfo* outputInfo; Zone_s* zonePtr; if (!getOutputInfoAndZonePtr(&outputInfo, &zonePtr, fileHandle, zone, "tecFEPartitionCreate64")) return -1; if (___2975 < 1) { ___3184("Error in %s: invalid partition input parameter (%d).\n", routineName, ___2975); ++outputInfo->m_numErrs; return -1; } if (!___3892(zonePtr->___2682)) { ___3183("Error in %s: Called for the wrong zone type; can be called only for 3D FE zones.\n", routineName); ++outputInfo->m_numErrs; return -1; } if (___2819 < 1) { ___3184("Error in %s: Invalid numNodes input parameter (%" PRId64 ").\n", routineName, ___2819); ++outputInfo->m_numErrs; return -1; } if (___2779 < 1) { ___3184("Error in %s: Invalid numCells input parameter (%" PRId64 ").\n", routineName, ___2779); ++outputInfo->m_numErrs; return -1; } if (numGhostNodes < 0) { ___3184("Error in %s: Invalid numGhostNodes input parameter (%" PRId64 ").\n", routineName, numGhostNodes); ++outputInfo->m_numErrs; return -1; } if (numGhostNodes > 0) { if (!ghostNodes) { ___3183("Error in %s: Invalid ghostNodes input parameter.\n", routineName); ++outputInfo->m_numErrs; return -1; } else if (!neighborPartitions) { ___3183("Error in %s: Invalid neighborPartitions input parameter.\n", routineName); ++outputInfo->m_numErrs; return -1; } else if (!neighborPartitionNodes) { ___3183("Error in %s: Invalid neighborPartitionNodes input parameter.\n", routineName); ++outputInfo->m_numErrs; return -1; } } if (numGhostCells < 0) { ___3184("Error in %s: Invalid NGCells input parameter (%" PRId64 ").\n", routineName, numGhostCells); ++outputInfo->m_numErrs; return -1; } if (numGhostCells > 0 && !ghostCells) { ___3183("Error in %s: Invalid ghostCells input parameter.\n", routineName); ++outputInfo->m_numErrs; return -1; } try {
 #if defined TECIOMPI
if (zonePtr->m_partitionOwners.empty()) { throw std::logic_error(std::string("Must call tecZoneMapPartitionsToMPIRanks prior to calling ") + routineName); } else if (static_cast<size_t>(___2975) > zonePtr->m_partitionOwners.size()) { std::ostringstream ___2890; ___2890 << "Invalid partition number passed to " << routineName << ": " << ___2975; throw std::logic_error(___2890.str().c_str()); }
 #endif 
outputInfo->m_tecioData.addFEZonePartition( zone, ___2975, ___2819, ___2779, std::vector<T>(ghostNodes, ghostNodes + numGhostNodes), std::vector<int32_t>(neighborPartitions, neighborPartitions + numGhostNodes), std::vector<T>(neighborPartitionNodes, neighborPartitionNodes + numGhostNodes), std::vector<T>(ghostCells, ghostCells + numGhostCells)); } catch (std::exception const& e) { ___3184("Error in %s: %s\n", routineName, e.what()); ++outputInfo->m_numErrs; return -1; } return 0; } } int32_t tecFEPartitionCreate32_SZL( void*          fileHandle, int32_t        zone, int32_t        ___2975, int64_t        ___2819, int64_t        ___2779, int64_t        numGhostNodes, int32_t const* ghostNodes, int32_t const* neighborPartitions, int32_t const* neighborPartitionNodes, int64_t        numGhostCells, int32_t const* ghostCells) { return fePartitionCreate( "tecFEPartitionCreate32", fileHandle, zone, ___2975, ___2819, ___2779, numGhostNodes, ghostNodes, neighborPartitions, neighborPartitionNodes, numGhostCells, ghostCells); } int32_t tecFEPartitionCreate64_SZL( void*          fileHandle, int32_t        zone, int32_t        ___2975, int64_t        ___2819, int64_t        ___2779, int64_t        numGhostNodes, int64_t const* ghostNodes, int32_t const* neighborPartitions, int64_t const* neighborPartitionNodes, int64_t        numGhostCells, int64_t const* ghostCells) { return fePartitionCreate( "tecFEPartitionCreate64", fileHandle, zone, ___2975, ___2819, ___2779, numGhostNodes, ghostNodes, neighborPartitions, neighborPartitionNodes, numGhostCells, ghostCells); } namespace { bool checkParameter(int64_t parameter, char const* parameterName, int64_t minValue, int64_t maxValue) { if (parameter < minValue || parameter > maxValue) { ___3184("Error in tecIJKPartitionCreate: Invalid %s input parameter (%" PRId64 ").\n", parameterName, parameter); return false; } else { return true; } } } int32_t tecIJKPartitionCreate_SZL( void*   fileHandle, int32_t zone, int32_t ___2975, int64_t imin, int64_t jmin, int64_t kmin, int64_t imax, int64_t jmax, int64_t kmax) { OutputInfo* outputInfo; Zone_s* zonePtr; if (!getOutputInfoAndZonePtr(&outputInfo, &zonePtr, fileHandle, zone, "tecIJKPartitionCreate")) return -1; if (___2975 < 1) { ___3183("Error in tecIJKPartitionCreate : invalid partition input parameter (%d).\n", ___2975); ++outputInfo->m_numErrs; return -1; } if (!supportedOrderedVolumeZoneType(zonePtr->___2682, zonePtr->___2680)) { ___3182("Error in tecIJKPartitionCreate: Called for the wrong zone type; can be called only for 3D ordered zones.\n"); ++outputInfo->m_numErrs; return -1; } if (___2975 < 1) { ___3183("Error in tecIJKPartitionCreate: Invalid Partition input parameter (%d).\n", ___2975); ++outputInfo->m_numErrs; return -1; } if (!checkParameter(imin, "imin", 1, zonePtr->___2680.i()) || !checkParameter(jmin, "jmin", 1, zonePtr->___2680.___2103()) || !checkParameter(kmin, "kmin", 1, zonePtr->___2680.___2132()) || !checkParameter(imax, "imax", imin, zonePtr->___2680.i()) ||
!checkParameter(jmax, "jmax", jmin, zonePtr->___2680.___2103()) || !checkParameter(kmax, "kmax", kmin, zonePtr->___2680.___2132())) { ++outputInfo->m_numErrs; return -1; } try {
 #if defined TECIOMPI
if (zonePtr->m_partitionOwners.empty()) { throw std::logic_error("Must call tecZoneMapPartitionsToMPIRanks prior to calling tecIJKPartitionCreate"); } else if (static_cast<size_t>(___2975) > zonePtr->m_partitionOwners.size()) { std::ostringstream ___2890; ___2890 << "Invalid partition number passed to tecIJKPartitionCreate: " << ___2975; throw std::logic_error(___2890.str().c_str()); }
 #endif 
outputInfo->m_tecioData.addIJKZonePartition(zone, ___2975, imin, jmin, kmin, imax, jmax, kmax); } catch (std::exception const& e) { ___3183("Error in tecZoneMapPartitionsToMPIRanks: %s\n", e.what()); ++outputInfo->m_numErrs; return -1; } return 0; } namespace { bool getOutputInfoAndZoneOrPartitionPtr(OutputInfo** outputInfo, Zone_s** zoneOrPartitionPtr, void* fileHandle, int32_t zone, int32_t ___2975, char const* routineName) { REQUIRE(VALID_REF(outputInfo)); REQUIRE(VALID_REF(zoneOrPartitionPtr)); REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___2975 >= 0); REQUIRE(VALID_REF(routineName)); if (!getOutputInfoAndZonePtr(outputInfo, zoneOrPartitionPtr, fileHandle, zone, routineName)) return false; if (!(*zoneOrPartitionPtr)->m_partitionMap.empty()) { if ((*zoneOrPartitionPtr)->m_partitionMap.find(___2975 - 1) == (*zoneOrPartitionPtr)->m_partitionMap.end()) { ___3184("Error in %s : invalid partition input parameter (%d).\n", routineName, ___2975); ++(*outputInfo)->m_numErrs; return false; } (*zoneOrPartitionPtr) = (*zoneOrPartitionPtr)->m_partitionMap[___2975 - 1].get(); } return true; } template <typename T> int32_t zoneVarWriteValues( void*       fileHandle, int32_t     zone, int32_t     ___4334, int32_t     ___2975, int64_t     count, T const*    values, char const* routineName) { OutputInfo* outputInfo; Zone_s* zonePtr; if (!getOutputInfoAndZoneOrPartitionPtr(&outputInfo, &zonePtr, fileHandle, zone, ___2975, routineName)) return -1; if (zonePtr->m_passiveVars[___4334 - 1]) { ___3184("Error in %s : Variable %d is a passive var, so values cannot be written to it.\n", routineName, ___4334); ++outputInfo->m_numErrs; return -1; } else if (zonePtr->m_shareVarFromZone[___4334 - 1]) { ___3185("Error in %s : Variable %d is shared with zone %d, so values cannot be written to it.\n", routineName, ___4334, zone); ++outputInfo->m_numErrs; return -1; } ___1360* ___1349 = zonePtr->___2494[___4334 - 1].get(); if (outputInfo->m_debugLevel && (count > 1)) ___3185("Writing %" PRId64 " values to zone %d, var %d.\n", count, zone, ___4334); if (___1349->storedValueCount() == 0) ___1349->reserveValues(___1349->___2666); for (int64_t i = 0; i < count; ++i) { if (___1349->storedValueCount() >= ___1349->___2666) { int64_t extraValues = count - i; if (___2975 == 0) PRINT4("Error in %s: Too many values supplied for zone %d var %d (%" PRId64 " extra values).\n", routineName, zone, ___4334, extraValues); else PRINT5("Error in %s: Too many values supplied for zone %d var %d partition %d (%" PRId64 " extra values).\n", routineName, zone, ___4334, ___2975, extraValues); ++outputInfo->m_numErrs; return -1; } ___1349->appendValue(checked_numeric_cast<double>(values[i])); if (zonePtr->___2682 == ___4702 && ___1349->___2667 == ___4326) { padCCValuesIfNecessary(*___1349, zonePtr->___2680.i(), zonePtr->___2680.___2103(), zonePtr->___2680.___2132()); } } return 0; } } int32_t tecZoneVarWriteDoubleValues_SZL( void*         fileHandle,
int32_t       zone, int32_t       ___4334, int32_t       ___2975, int64_t       count, double const* values) { return zoneVarWriteValues( fileHandle, zone, ___4334, ___2975, count, values, "tecZoneVarWriteDoubleValues"); } int32_t tecZoneVarWriteFloatValues_SZL( void*         fileHandle, int32_t       zone, int32_t       ___4334, int32_t       ___2975, int64_t       count, float const*  values) { return zoneVarWriteValues( fileHandle, zone, ___4334, ___2975, count, values, "tecZoneVarWriteFloatValues"); } int32_t tecZoneVarWriteInt32Values_SZL( void*          fileHandle, int32_t        zone, int32_t        ___4334, int32_t        ___2975, int64_t        count, int32_t const* values) { return zoneVarWriteValues( fileHandle, zone, ___4334, ___2975, count, values, "tecZoneVarWriteInt32Values"); } int32_t tecZoneVarWriteInt16Values_SZL( void*          fileHandle, int32_t        zone, int32_t        ___4334, int32_t        ___2975, int64_t        count, int16_t const* values) { return zoneVarWriteValues( fileHandle, zone, ___4334, ___2975, count, values, "tecZoneVarWriteInt16Values"); } int32_t tecZoneVarWriteUInt8Values_SZL( void*          fileHandle, int32_t        zone, int32_t        ___4334, int32_t        ___2975, int64_t        count, uint8_t const* values) { return zoneVarWriteValues( fileHandle, zone, ___4334, ___2975, count, values, "tecZoneVarWriteUInt8Values"); } namespace { template <typename T> int32_t zoneNodeMapWrite( void*       fileHandle, int32_t     zone, int32_t     ___2975, int32_t     nodesAreOneBased, int64_t     count, T const*    nodes, char const* routineName) { OutputInfo* outputInfo; Zone_s* zonePtr; if (!getOutputInfoAndZoneOrPartitionPtr(&outputInfo, &zonePtr, fileHandle, zone, ___2975, routineName)) return -1; if (count + zonePtr->___2495->storedValueCount() > zonePtr->___2495->___2498 * zonePtr->___2495->___2390) { ___3185("Error in %s: Too many node map values for this zone. %" PRIu64 " supplied, need only %" PRIu64 ".\n", routineName, count, zonePtr->___2495->___2498 * zonePtr->___2495->___2390 - zonePtr->___2495->storedValueCount()); ++outputInfo->m_numErrs; return -1; } if (outputInfo->m_debugLevel && (count > 1)) ___3184("Writing %" PRId64 " nodes to zone %d.\n", count, zone); for (int64_t i = 0; i < count; ++i) { T ___2707 = nodes[i]; if (nodesAreOneBased) --___2707; if (___2707 < 0 || zonePtr->___2680.i() <= (___81)___2707) { T maxValue = static_cast<T>(zonePtr->___2680.i()); if (!nodesAreOneBased) --maxValue; std::ostringstream ___2890; ___2890 << routineName << ": Invalid node map value at position " << i << std::endl << "     node map value = " << nodes[i] << ", max value = " << maxValue << "." << std::endl; ___3183("Error in %s", ___2890.str().c_str()); ++outputInfo->m_numErrs; return -1; } zonePtr->___2495->appendValue(___2707); } return 0; } } int32_t tecZoneNodeMapWrite32_SZL( void*          fileHandle, int32_t        zone, int32_t        ___2975, int32_t        nodesAreOneBased,
int64_t        count, int32_t const* nodes) { return zoneNodeMapWrite(fileHandle, zone, ___2975, nodesAreOneBased, count, nodes, "tecZoneNodeMapWrite32"); } int32_t tecZoneNodeMapWrite64_SZL( void*          fileHandle, int32_t        zone, int32_t        ___2975, int32_t        nodesAreOneBased, int64_t        count, int64_t const* nodes) { return zoneNodeMapWrite(fileHandle, zone, ___2975, nodesAreOneBased, count, nodes, "tecZoneNodeMapWrite64"); } namespace { template <typename T> int32_t zoneFaceNbrWriteConnections( void*       fileHandle, int32_t     zone, T const*    faceNeighbors, char const* routineName) { OutputInfo* outputInfo = (OutputInfo*)fileHandle; Zone_s* zonePtr = outputInfo->m_tecioData.zonePtr(zone); if (!getOutputInfoAndZonePtr(&outputInfo, &zonePtr, fileHandle, zone, routineName)) return -1; if (outputInfo->m_debugLevel) ___3183("\nInserting face neighbor data for zone %d\n", zone); try { if (outputInfo->m_debugLevel) ___3183("\nInserting face neighbor data for zone %d\n", zone); outputInfo->m_tecioData.___430(zonePtr, faceNeighbors); } catch (std::exception const& e) { ___3184("Error in %s: %s\n", routineName, e.what()); ++outputInfo->m_numErrs; return -1; } return 0; } } int32_t tecZoneFaceNbrWriteConnections32_SZL( void*          fileHandle, int32_t        zone, int32_t const* faceNeighbors) { return zoneFaceNbrWriteConnections(fileHandle, zone, faceNeighbors, "tecZoneFaceNbrWriteConnections32"); } int32_t tecZoneFaceNbrWriteConnections64_SZL( void*          fileHandle, int32_t        zone, int64_t const* faceNeighbors) { return zoneFaceNbrWriteConnections(fileHandle, zone, faceNeighbors, "tecZoneFaceNbrWriteConnections64"); } int32_t tecZoneWritePolyFaces32_SZL( void*           , int32_t         , int32_t         , int32_t         , int32_t const*  , int32_t const*  , int32_t const*  , int32_t const*  , int32_t         ) { return 0; } int32_t tecZoneWritePolyFaces64_SZL( void*           , int32_t         , int32_t         , int64_t         , int32_t const*  , int64_t const*  , int64_t const*  , int64_t const*  , int32_t         ) { return 0; } int32_t tecZoneWritePolyBoundaryConnections32_SZL( void*           , int32_t         , int32_t         , int32_t         , int32_t const*  , int32_t const*  , int32_t const*  , int32_t         ) { return 0; } int32_t tecZoneWritePolyBoundaryConnections64_SZL( void*           , int32_t         , int32_t         , int64_t         , int32_t const*  , int64_t const*  , int32_t const*  , int32_t         ) { return 0; } namespace { bool auxDataIsValidNameChar(char c, bool isLeadChar) { REQUIRE(0 <= c && "c <= 127"); bool isValidNameChar = (c == '_' || tecplot::___1996(c)); if (!isLeadChar) isValidNameChar = (isValidNameChar || c == '.' || tecplot::___2010(c)); return isValidNameChar; } bool auxDataIsValidName(char const* ___2683) { REQUIRE(VALID_REF(___2683)); bool isValidName = auxDataIsValidNameChar(*___2683, true); for (char const* nPtr = ___2683; isValidName && *nPtr != '\0'; ++nPtr)
isValidName = auxDataIsValidNameChar(*nPtr, false); return isValidName; } bool checkAuxNameAndValue(OutputInfo* outputInfo, char const* ___2683, char const* ___4312, char const* routineName) { if ((___2683 == NULL) || !auxDataIsValidName(___2683)) { ___3183("Error in %s: Invalid Name string\n", routineName); ++outputInfo->m_numErrs; return false; } if ((___4312 == NULL) || (*___4312 == '\0')) { ___3183("Error in %s: Invalid Value string\n", routineName); ++outputInfo->m_numErrs; return false; } return true; } } int32_t tecDataSetAddAuxData_SZL( void*       fileHandle, char const* ___2683, char const* ___4312) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecDataSetAddAuxData")) return -1; if (outputInfo->m_debugLevel) ___3184("\nInserting data set aux data: '%s' = '%s'\n", ___2683, ___4312); if (!checkAuxNameAndValue(outputInfo, ___2683, ___4312, "TECAUXSTR")) return -1; outputInfo->m_tecioData.___8(___2683, ___4312); return 0; } int32_t tecVarAddAuxData_SZL( void*       fileHandle, int32_t     ___4334, char const* ___2683, char const* ___4312) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecVarAddAuxData")) return -1; if (outputInfo->m_debugLevel) ___3184("\nInserting variable aux data: '%s' = '%s'\n", ___2683, ___4312); if (!checkAuxNameAndValue(outputInfo, ___2683, ___4312, "tecVarAddAuxData")) return -1; outputInfo->m_tecioData.___18(___4334, ___2683, ___4312); return 0; } int32_t tecZoneAddAuxData_SZL( void*       fileHandle, int32_t     zone, char const* ___2683, char const* ___4312) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecZoneAddAuxData")) return -1; if (outputInfo->m_debugLevel) ___3184("\nInserting zone aux data: '%s' = '%s'\n", ___2683, ___4312); if (!checkAuxNameAndValue(outputInfo, ___2683, ___4312, "tecZoneAddAuxData")) return -1; outputInfo->m_tecioData.___20(zone, ___2683, ___4312); return 0; } namespace { char const* geomTypeStrings[] = { "2D Line", "Rectangle", "Square", "Circle", "Ellipse", "3D Line" }; } int32_t tecGeom2DLineSegmentsBegin_SZL( void*         fileHandle, double        xOrigin, double        yOrigin, int32_t       numPoints, double const* relativeX, double const* relativeY, int32_t       ___3157) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeom2DLineSegmentsBegin")) return -1; if (outputInfo->m_geom.___2065()) { ___3182("Error in tecGeom2DLineSegmentsBegin: You must end the current geometry by calling tecGeomEnd before beginning a new geometry.\n"); ++outputInfo->m_numErrs; return -1; } if (numPoints < 2) { ___3183("Error in tecGeom2DLineSegmentsBegin: numPoints = %d. numPoints must be >= 2.\n", numPoints); ++outputInfo->m_numErrs; return -1; } if (___3157 != 0 && ___3157 != 1) { ___3183("Error in tecGeom2DLineSegmentsBegin: posCoordMode = %d. posCoordMode must be 0 or 1.\n", numPoints); ++outputInfo->m_numErrs; return -1; } if (outputInfo->m_debugLevel) ___3182("\nInserting line segment Geometry\n"); try { outputInfo->m_geom.___2615[0] = xOrigin;
outputInfo->m_geom.___2615[1] = yOrigin; outputInfo->m_geom.___2462.resize(1); outputInfo->m_geom.___2462[0].reserve(numPoints); for (int32_t i = 0; i < numPoints; ++i) { outputInfo->m_geom.___2462[0].push_back(___4578(relativeX[i], relativeY[i], 0.0)); } outputInfo->m_geom.___2464 = GeomType_LineSegs; outputInfo->m_geom.___2614 = (CoordSys_e)___3157; } catch (std::bad_alloc const&) { ___3182("Error in tecGeom2DLineSegmentsBegin : Out of memory.\n"); outputInfo->m_geom = ___1554::invalidGeom(); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecGeom2DMultiLineSegmentsBegin_SZL( void*          fileHandle, double         xOrigin, double         yOrigin, int32_t        ___2833, int32_t const* numSegmentPoints, double const*  relativeX, double const*  relativeY, int32_t        ___3157) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeom2DMultiLineSegmentsBegin")) return -1; if (outputInfo->m_geom.___2065()) { ___3182("Error in tecGeom2DMultiLineSegmentsBegin: You must end the current geometry by calling tecGeomEnd before beginning a new geometry.\n"); ++outputInfo->m_numErrs; return -1; } if (___2833 <= 0) { ___3183("Error in tecGeom2DMultiLineSegmentsBegin: numSegments = %d. numSegments must be > 0.\n", ___2833); ++outputInfo->m_numErrs; return -1; } if (outputInfo->m_debugLevel) ___3182("\nInserting multi-line segment Geometry\n"); try { outputInfo->m_geom.___2615[0] = xOrigin; outputInfo->m_geom.___2615[1] = yOrigin; outputInfo->m_geom.___2462.resize(___2833); int32_t pos = 0; for (int32_t i = 0; i < ___2833; ++i) { if (numSegmentPoints[i] < 2) { ___3184("Error in tecGeom2DMultiLineSegmentsBegin: numSegmentsPoints[%d] = %d.\n" "Each entry of numSegmentPoints must be >= 2.\n", i, numSegmentPoints[i]); outputInfo->m_geom = ___1554::invalidGeom(); ++outputInfo->m_numErrs; return -1; } outputInfo->m_geom.___2462[i].reserve(numSegmentPoints[i]); for (int32_t ___2103 = 0; ___2103 < numSegmentPoints[i]; ++___2103) { outputInfo->m_geom.___2462[i].push_back(___4578(relativeX[pos], relativeY[pos], 0.0)); ++pos; } } outputInfo->m_geom.___2464 = GeomType_LineSegs; outputInfo->m_geom.___2614 = (CoordSys_e)___3157; } catch (std::bad_alloc const&) { ___3182("Error in tecGeom2DMultiLineSegmentsBegin : Out of memory.\n"); outputInfo->m_geom = ___1554::invalidGeom(); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecGeom3DLineSegmentsBegin_SZL( void* fileHandle, double xOrigin, double yOrigin, double zOrigin, int32_t numPoints, double const* relativeX, double const* relativeY, double const* relativeZ) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeom3DLineSegmentsBegin")) return -1; if (outputInfo->m_geom.___2065()) { ___3182("Error in tecGeom3DLineSegmentsBegin: You must end the current geometry by calling tecGeomEnd before beginning a new geometry.\n"); ++outputInfo->m_numErrs; return -1; } if (numPoints < 2) { ___3183("Error in tecGeom3DLineSegmentsBegin: numPoints = %d. numPoints must be >= 2.\n", numPoints);
++outputInfo->m_numErrs; return -1; } if (outputInfo->m_debugLevel) ___3182("\nInserting 3D line segment Geometry\n"); try { outputInfo->m_geom.___2615[0] = xOrigin; outputInfo->m_geom.___2615[1] = yOrigin; outputInfo->m_geom.___2615[2] = zOrigin; outputInfo->m_geom.___2462.resize(1); outputInfo->m_geom.___2462[0].reserve(numPoints); for (int32_t i = 0; i < numPoints; ++i) { outputInfo->m_geom.___2462[0].push_back(___4578(relativeX[i], relativeY[i], relativeZ[i])); } outputInfo->m_geom.___2464 = GeomType_LineSegs3D; outputInfo->m_geom.___2614 = CoordSys_Grid3D; } catch (std::bad_alloc const&) { ___3182("Error in tecGeom3DLineSegmentsBegin : Out of memory.\n"); outputInfo->m_geom = ___1554::invalidGeom(); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecGeom3DMultiLineSegmentsBegin_SZL( void*          fileHandle, double         xOrigin, double         yOrigin, double         zOrigin, int32_t        ___2833, int32_t const* numSegmentPoints, double const*  relativeX, double const*  relativeY, double const*  relativeZ) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeom3DMultiLineSegmentsBegin")) return -1; if (outputInfo->m_geom.___2065()) { ___3182("Error in tecGeom3DMultiLineSegmentsBegin: You must end the current geometry by calling tecGeomEnd before beginning a new geometry.\n"); ++outputInfo->m_numErrs; return -1; } if (___2833 <= 0) { ___3183("Error in tecGeom3DMultiLineSegmentsBegin: numSegments = %d. numSegments must be > 0.\n", ___2833); ++outputInfo->m_numErrs; return -1; } if (outputInfo->m_debugLevel) ___3182("\nInserting 3D multi-line segment Geometry\n"); try { outputInfo->m_geom.___2615[0] = xOrigin; outputInfo->m_geom.___2615[1] = yOrigin; outputInfo->m_geom.___2615[2] = zOrigin; outputInfo->m_geom.___2462.resize(___2833); int32_t pos = 0; for (int32_t i = 0; i < ___2833; ++i) { if (numSegmentPoints[i] < 2) { ___3184("Error in tecGeom3DMultiLineSegmentsBegin: numSegmentsPoints[%d] = %d.\n" "Each entry of numSegmentPoints must be >= 2.\n", i, numSegmentPoints[i]); outputInfo->m_geom = ___1554::invalidGeom(); ++outputInfo->m_numErrs; return -1; } outputInfo->m_geom.___2462[i].reserve(numSegmentPoints[i]); for (int32_t ___2103 = 0; ___2103 < numSegmentPoints[i]; ++___2103) { outputInfo->m_geom.___2462[i].push_back(___4578(relativeX[pos], relativeY[pos], relativeZ[pos])); ++pos; } } outputInfo->m_geom.___2464 = GeomType_LineSegs3D; outputInfo->m_geom.___2614 = CoordSys_Grid3D; } catch (std::bad_alloc const&) { ___3182("Error in tecGeom3DMultiLineSegmentsBegin : Out of memory.\n"); outputInfo->m_geom = ___1554::invalidGeom(); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecGeomCircleBegin_SZL( void*   fileHandle, double  xCenter, double  yCenter, double  radius, int32_t ___3157) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeomCircleBegin")) return -1; if (outputInfo->m_geom.___2065()) { ___3182("Error in tecGeomCircleBegin: You must end the current geometry by calling tecGeomEnd before beginning a new geometry.\n");
++outputInfo->m_numErrs; return -1; } if (outputInfo->m_debugLevel) ___3182("\nInserting circle Geometry\n"); outputInfo->m_geom.___2615[0] = xCenter; outputInfo->m_geom.___2615[1] = yCenter; outputInfo->m_geom.___2464 = GeomType_Circle; outputInfo->m_geom.___2614 = (CoordSys_e)___3157; try { outputInfo->m_geom.___2462.resize(1); outputInfo->m_geom.___2462[0].push_back(___4578(radius, 0.0, 0.0)); } catch (std::bad_alloc const&) { ___3182("Error in tecGeomCircleBegin : Out of memory.\n"); outputInfo->m_geom = ___1554::invalidGeom(); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecGeomEllipseBegin_SZL( void*   fileHandle, double  xCenter, double  yCenter, double  ___4456, double  ___1824, int32_t ___3157) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeomEllipseBegin")) return -1; if (outputInfo->m_geom.___2065()) { ___3182("Error in tecGeomEllipseBegin: You must end the current geometry by calling tecGeomEnd before beginning a new geometry.\n"); ++outputInfo->m_numErrs; return -1; } if (outputInfo->m_debugLevel) ___3182("\nInserting ellipse Geometry\n"); outputInfo->m_geom.___2615[0] = xCenter; outputInfo->m_geom.___2615[1] = yCenter; outputInfo->m_geom.___2464 = GeomType_Ellipse; outputInfo->m_geom.___2614 = (CoordSys_e)___3157; try { outputInfo->m_geom.___2462.resize(1); outputInfo->m_geom.___2462[0].push_back(___4578(___4456, ___1824, 0.0)); } catch (std::bad_alloc const&) { ___3182("Error in tecGeomEllipseBegin : Out of memory.\n"); outputInfo->m_geom = ___1554::invalidGeom(); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecGeomRectangleBegin_SZL( void*   fileHandle, double  xMin, double  yMin, double  xMax, double  yMax, int32_t ___3157) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeomRectangleBegin")) return -1; if (outputInfo->m_geom.___2065()) { ___3182("Error in tecGeomRectangleBegin: You must end the current geometry by calling tecGeomEnd before beginning a new geometry.\n"); ++outputInfo->m_numErrs; return -1; } if (outputInfo->m_debugLevel) ___3182("\nInserting rectangle Geometry\n"); outputInfo->m_geom.___2615[0] = xMin; outputInfo->m_geom.___2615[1] = yMin; outputInfo->m_geom.___2464 = GeomType_Rectangle; outputInfo->m_geom.___2614 = (CoordSys_e)___3157; try { outputInfo->m_geom.___2462.resize(1); outputInfo->m_geom.___2462[0].push_back(___4578(xMax - xMin, yMax - yMin, 0.0)); } catch (std::bad_alloc const&) { ___3182("Error in tecGeomRectangleBegin : Out of memory.\n"); outputInfo->m_geom = ___1554::invalidGeom(); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecGeomSquareBegin_SZL( void*   fileHandle, double  xMin, double  yMin, double  size, int32_t ___3157) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeomSquareBegin")) return -1; if (outputInfo->m_geom.___2065()) { ___3182("Error in tecGeomSquareBegin: You must end the current geometry by calling tecGeomEnd before beginning a new geometry.\n");
++outputInfo->m_numErrs; return -1; } if (outputInfo->m_debugLevel) ___3182("\nInserting square Geometry\n"); outputInfo->m_geom.___2615[0] = xMin; outputInfo->m_geom.___2615[1] = yMin; outputInfo->m_geom.___2464 = GeomType_Square; outputInfo->m_geom.___2614 = (CoordSys_e)___3157; try { outputInfo->m_geom.___2462.resize(1); outputInfo->m_geom.___2462[0].push_back(___4578(size, 0.0, 0.0)); } catch (std::bad_alloc const&) { ___3182("Error in tecGeomSquareBegin : Out of memory.\n"); outputInfo->m_geom = ___1554::invalidGeom(); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecGeomArrowheadSetInfo_SZL( void*   fileHandle, double  ___56, int32_t attachment, double  size, int32_t style) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeomArrowheadSetInfo")) return -1; if (!outputInfo->m_geom.___2065()) { ___3182("Error in tecGeomArrowheadSetInfo: You must begin a geometry by calling tecGeom2DLineSegmentsBegin\n" "or tecGeom3DLineSegmentsBegin before calling tecGeomArrowheadSetInfo.\n"); ++outputInfo->m_numErrs; return -1; } if (outputInfo->m_geom.___2464 != GeomType_LineSegs && outputInfo->m_geom.___2464 != GeomType_LineSegs3D) { ___3183("Warning in tecGeomArrowheadSetInfo: Arrowhead info affects only line segment geometries.\n" " The current grometry type is %s. Continuing...\n", geomTypeStrings[outputInfo->m_geom.___2464]); } if (___56 <= 0.0) { ___3183("Error in tecGeomArrowheadSetInfo: angle = %g. angle must be > 0.\n", ___56); ++outputInfo->m_numErrs; return -1; } if (attachment < 0 || 3 < attachment) { ___3183("Error in tecGeomArrowheadSetInfo: attachment = %d. Must be 0 <= attachment <= 3.\n", attachment); ++outputInfo->m_numErrs; return -1; } if (size < 0.0) { ___3183("tecGeomArrowheadSetInfo: size = %g. size must be >= 0.\n", size); ++outputInfo->m_numErrs; return -1; } if (style < 0 || 2 < style) { ___3183("Error in tecGeomArrowheadSetInfo: style = %d. Must be 0 <= style <= 2.\n", style); ++outputInfo->m_numErrs; return -1; } outputInfo->m_geom.___2338      = ___56; outputInfo->m_geom.___2339 = (ArrowheadAttachment_e)attachment; outputInfo->m_geom.___2340       = size; outputInfo->m_geom.___2341      = (ArrowheadStyle_e)style; return 0; } int32_t tecGeomEllipseSetNumPoints_SZL( void*   fileHandle, int32_t numEllipsePoints) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeomEllipseSetNumPoints")) return -1; if (!outputInfo->m_geom.___2065()) { ___3182("Error in tecGeomSetNumEllipsePoints: You must begin a geometry before calling tecGeomEllipseSetNumPoints.\n"); ++outputInfo->m_numErrs; return -1; } if (numEllipsePoints < 3 || 720 < numEllipsePoints) { ___3183("Error in tecGeomEllipseSetNumPoints: numEllipsePoints = %d. Must be 3 <= numEllipsePoints <= 720.\n", numEllipsePoints); ++outputInfo->m_numErrs; return -1; } if (outputInfo->m_geom.___2464 != GeomType_Circle && outputInfo->m_geom.___2464 != GeomType_Ellipse) {
___3183("Warning in tecGeomEllipseSetNumPoints: numEllipsePts affects only circle and ellipse geometries.\n" "The current geometry's type is %s. Continuing...\n", geomTypeStrings[outputInfo->m_geom.___2464]); } outputInfo->m_geom.___2500 = static_cast<uint16_t>(numEllipsePoints); return 0; } int32_t tecGeomSetClipping_SZL( void*   fileHandle, int32_t ___493) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeomSetClipping")) return -1; if (!outputInfo->m_geom.___2065()) { ___3182("Error in tecGeomSetClipping: You must begin a geometry before calling tecGeomSetClipping.\n"); ++outputInfo->m_numErrs; return -1; } if (___493 != 0 && ___493 != 1) { ___3183("Error in tecGeomSetClipping: clipping = %d. clipping must = 0 or 1.\n", ___493); ++outputInfo->m_numErrs; return -1; } outputInfo->m_geom.___2392 = static_cast<Clipping_e>(___493); return 0; } int32_t tecGeomSetLineInfo_SZL( void*   fileHandle, int32_t ___2261, double  ___2984, double  thickness, int32_t color) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeomSetLineInfo")) return -1; if (!outputInfo->m_geom.___2065()) { ___3182("Error in tecGeomSetLineInfo: You must begin a geometry before calling tecGeomSetLineInfo.\n"); ++outputInfo->m_numErrs; return -1; } if (___2261 < 0 || 5 < ___2261) { ___3183("Error in tecGeomSetLineInfo: linePattern = %d. Must be 0 <= linePattern <= 5.\n", ___2261); ++outputInfo->m_numErrs; return -1; } if (___2984 < .0001 || 100.0 < ___2984) { ___3183("Error in tecGeomSetLineInfo: patternLength = %g. Must be 0.0001 <= patternLength <= 100.\n", ___2984); ++outputInfo->m_numErrs; return -1; } if (thickness < .01 || 100.0 < thickness) { ___3183("Error in tecGeomSetLineInfo: thickness = %g. Must be 0.01 <= thickness <= 100.\n", thickness); ++outputInfo->m_numErrs; return -1; } if (color < 0 || 15 < color) { ___3183("Error in tecGeomSetLineInfo: color = %d. Must be 0 <= color <= 15.\n", color); ++outputInfo->m_numErrs; return -1; } outputInfo->m_geom.___2487 = (LinePattern_e)___2261; outputInfo->m_geom.___2613 = ___2984; outputInfo->m_geom.___2488 = thickness; outputInfo->m_geom.___2393 = color; return 0; } int32_t tecGeomSetMacroFunctionCmd_SZL( void*       fileHandle, char const* macroFunctionCmd) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeomSetMacroFunctionCmd")) return -1; if (!outputInfo->m_geom.___2065()) { ___3182("Error in tecGeomSetMacroFunctionCmd: You must begin a geometry before calling tecGeomSetMacroFunctionCmd.\n"); ++outputInfo->m_numErrs; return -1; } outputInfo->m_geom.___2489 = macroFunctionCmd; return 0; } int32_t tecGeomSetScope_SZL( void*   fileHandle, int32_t ___3440) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeomSetScope")) return -1; if (!outputInfo->m_geom.___2065()) { ___3182("Error in tecGeomSetScope: You must begin a geometry before calling tecGeomSetScope.\n");
++outputInfo->m_numErrs; return -1; } if (___3440 != 0 && ___3440 != 1) { ___3183("Error in tecGeomSetScope: ___3440 = %d. Must be 0 or 1.\n", ___3440); ++outputInfo->m_numErrs; return -1; } outputInfo->m_geom.___2617 = (Scope_e)___3440; return 0; } int32_t tecGeomAttachToZone_SZL( void*   fileHandle, int32_t zone) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeomAttachToZone")) return -1; if (!outputInfo->m_geom.___2065()) { ___3182("Error in tecGeomAttachToZone: You must begin a geometry before calling tecGeomAttachToZone.\n"); ++outputInfo->m_numErrs; return -1; } if (zone <= 0) { ___3183("Error in tecGeomAttachToZone: zone = %d. Must be > 0.\n", zone); ++outputInfo->m_numErrs; return -1; } outputInfo->m_geom.___2482 = ___4224; outputInfo->m_geom.___2675 = zone; return 0; } int32_t tecGeomFill_SZL( void*   fileHandle, int32_t ___1409) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeomFill")) return -1; if (!outputInfo->m_geom.___2065()) { ___3182("Error in tecGeomFill: You must begin a geometry before calling tecGeomFill.\n"); ++outputInfo->m_numErrs; return -1; } if (___1409 < 0 || 15 < ___1409) { ___3183("Error in tecGeomFill: ___1409 = %d. Must be 0 <= ___1409 <= 15.\n", ___1409); ++outputInfo->m_numErrs; return -1; } outputInfo->m_geom.___2484 = ___4224; outputInfo->m_geom.___2460 = ___1409; return 0; } int32_t tecGeomEnd_SZL(void* fileHandle) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecGeomEnd")) return -1; if (!outputInfo->m_geom.___2065()) { ___3182("Error in tecGeomEnd: You must begin a geometry before calling tecGeomEnd.\n"); ++outputInfo->m_numErrs; return -1; } try { outputInfo->m_tecioData.___9(outputInfo->m_geom); outputInfo->m_geom = ___1554::invalidGeom(); return 0; } catch (std::bad_alloc const&) { ___3182("Error in tecGeomEnd: Out of memory.\n"); outputInfo->m_geom = ___1554::invalidGeom(); ++outputInfo->m_numErrs; return -1; } } int32_t tecCustomLabelsAddSet_SZL( void*       fileHandle, char const* ___2171) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecCustomLabelsAddSet")) return -1; if (outputInfo->m_debugLevel) ___3182("\nInserting Custom Labels:\n"); std::string inputString(___2171); boost::escaped_list_separator<char> ___3473("\\", ", \t", "\""); typedef boost::tokenizer<boost::escaped_list_separator<char> > LabelTokenizer_t; LabelTokenizer_t labelTokenizer(inputString, ___3473); std::vector<std::string> ___2169; for (LabelTokenizer_t::iterator labelIt = labelTokenizer.begin(); labelIt != labelTokenizer.end(); ++labelIt) { std::string label = *labelIt; if (!label.empty()) { boost::trim(label); ___2169.push_back(label); if (outputInfo->m_debugLevel) ___3183("          %s\n", label.c_str()); } } outputInfo->m_tecioData.___6(___2169); return 0; } namespace { bool validateTextHeightAndUnits(OutputInfo* outputInfo, double ___1824, int32_t sizeUnits, char const* routineName) { if (sizeUnits < 0 || 2 < sizeUnits)
{ ___3184("Error in %s: sizeUnits = %d. Must be 0 <= sizeUnits <= 2.\n", routineName, sizeUnits); ++outputInfo->m_numErrs; return false; } if (sizeUnits == 1) { if (___1824 < 0.0 || 100.0 < ___1824) { ___3184("Error in %s: height = %g. Must 0 <= height <= 100 when sizeUnits = 1 (Frame coordinates).\n", routineName, ___1824); ++outputInfo->m_numErrs; return false; } } else if (___1824 < 0.0) { ___3184("Error in %s: height = %g. height must >= 0.\n", routineName, ___1824); ++outputInfo->m_numErrs; return false; } return true; } } int32_t tecText2DBegin_SZL( void*       fileHandle, char const* string, double      x, double      ___4581, int32_t     ___3157, double      ___1824, int32_t     sizeUnits) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecText2DBegin")) return -1; if (outputInfo->m_text.___2065()) { ___3182("Error in tecText2DBegin: You must end the current text by calling tecTextEnd before beginning a new text.\n"); ++outputInfo->m_numErrs; return -1; } if (!VALID_REF(string)) { ___3182("Error in tecText2DBegin: Invalid string input parameter.\n"); ++outputInfo->m_numErrs; return -1; } if (___3157 != 0 && ___3157 != 1) { ___3183("Error in tecText2DBegin: posCoordMode = %d. posCoordMode must be zero or 1.\n", ___3157); ++outputInfo->m_numErrs; return -1; } if (!validateTextHeightAndUnits(outputInfo, ___1824, sizeUnits, "tecText2DBegin")) return -1; if (outputInfo->m_debugLevel) ___3183("\nInserting Text: %s\n", string); try { outputInfo->m_text.___2641 = string; outputInfo->m_text.___2624[0] = x; outputInfo->m_text.___2624[1] = ___4581; outputInfo->m_text.___2637 = (CoordSys_e)___3157; outputInfo->m_text.___2633 = ___1824; outputInfo->m_text.___2640 = (Units_e)sizeUnits; } catch (std::bad_alloc const&) { ___3182("Error in tecText2DBegin: Out of memory.\n"); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecText3DBegin_SZL( void*       fileHandle, char const* string, double      x, double      ___4581, double      z, double      ___1824, int32_t     sizeUnits) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecText3DBegin")) return -1; if (outputInfo->m_text.___2065()) { ___3182("Error in tecText3DBegin: You must end the current text by calling tecTextEnd before beginning a new text.\n"); ++outputInfo->m_numErrs; return -1; } if (!VALID_REF(string)) { ___3182("Error in tecText3DBegin: Invalid string input parameter.\n"); ++outputInfo->m_numErrs; return -1; } if (!validateTextHeightAndUnits(outputInfo, ___1824, sizeUnits, "tecText3DBegin")) return -1; if (outputInfo->m_debugLevel) ___3183("\nInserting 3D Text: %s\n", string); try { outputInfo->m_text.___2641 = string; outputInfo->m_text.___2624[0] = x; outputInfo->m_text.___2624[1] = ___4581; outputInfo->m_text.___2624[1] = z; outputInfo->m_text.___2637 = CoordSys_Grid3D; outputInfo->m_text.___2633 = ___1824; outputInfo->m_text.___2640 = (Units_e)sizeUnits;
} catch (std::bad_alloc const&) { ___3182("Error in tecText2DBegin: Out of memory.\n"); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecTextAttachToZone_SZL(void* fileHandle, int32_t zone) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecTextAttachToZone")) return -1; if (!outputInfo->m_text.___2065()) { ___3182("Error in tecTextAttachToZone: You must begin a text by calling tecText2DBegin or tecText3DBegin before calling tecTextAttachToZone.\n"); ++outputInfo->m_numErrs; return -1; } if (zone <= 0) { ___3183("Error in tecTextAttachToZone: zone = %d. zone must be > 0.\n", zone); ++outputInfo->m_numErrs; return -1; } outputInfo->m_text.___2645  = zone; outputInfo->m_text.___2634 = true; return 0; } int32_t tecTextBoxSetInfo_SZL( void*   fileHandle, int32_t ___410, int32_t lineColor, int32_t ___1409, double  ___2287, double  margin) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecTextBoxSetInfo")) return -1; if (!outputInfo->m_text.___2065()) { ___3182("Error in tecTextBoxSetInfo: You must begin a text by calling tecText2DBegin or tecText3DBegin before calling tecTextBoxSetInfo.\n"); ++outputInfo->m_numErrs; return -1; } if (___410 < 0 || 2 < ___410) { ___3183("Error in tecTextBoxSetInfo: boxType = %d. Must be 0 <= boxType <= 2.\n", ___410); ++outputInfo->m_numErrs; return -1; } if (lineColor < 0 || 15 < lineColor) { ___3183("Error in tecTextBoxSetInfo: lineColor = %d. Must be 0 <= lineColor <= 15.\n", lineColor); ++outputInfo->m_numErrs; return -1; } if (___1409 < 0 || 15 < ___1409) { ___3183("Error in tecTextBoxSetInfo: fillColor = %d. Must be 0 <= fillColor <= 15.\n", ___1409); ++outputInfo->m_numErrs; return -1; } if (___2287 < .0001 || 100.0 < ___2287) { ___3183("Error in tecTextBoxSetInfo: lineThickness = %g. Must be 0.0001 <= lineThickness <= 100.\n", ___2287); ++outputInfo->m_numErrs; return -1; } if (margin < 0.0 || 100.0 < margin) { ___3183("Error in tecTextBoxSetInfo: margin = %g. Must be 0 <= margin <= 100.\n", margin); ++outputInfo->m_numErrs; return -1; } outputInfo->m_text.___2630 = (TextBox_e)___410; outputInfo->m_text.___2626 = lineColor; outputInfo->m_text.___2627 = ___1409; outputInfo->m_text.___2628 = ___2287; outputInfo->m_text.___2629 = margin; return 0; } int32_t tecTextSetAnchor_SZL( void*   fileHandle, int32_t ___38) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecTextSetAnchor")) return -1; if (!outputInfo->m_text.___2065()) { ___3182("Error in tecTextSetAnchor: You must begin a text by calling tecText2DBegin or tecText3DBegin before calling tecTextSetAnchor.\n"); ++outputInfo->m_numErrs; return -1; } if (___38 < 0 || 8 < ___38) { ___3183("Error in tecTextSetAnchor: anchor = %d. Must be 0 <= anchor <= 8.\n", ___38); ++outputInfo->m_numErrs; return -1; } outputInfo->m_text.___2623 = (TextAnchor_e)___38; return 0; } int32_t tecTextSetAngle_SZL(
void*  fileHandle, double ___56) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecTextSetAngle")) return -1; if (!outputInfo->m_text.___2065()) { ___3182("Error in tecTextSetAngle: You must begin a text by calling tecText2DBegin or tecText3DBegin before calling tecTextSetAngle.\n"); ++outputInfo->m_numErrs; return -1; } outputInfo->m_text.___2625 = ___56; return 0; } int32_t tecTextSetClipping_SZL( void*   fileHandle, int32_t ___493) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecTextSetClipping")) return -1; if (!outputInfo->m_text.___2065()) { ___3182("Error in tecTextSetClipping: You must begin a text by calling tecText2DBegin\n" "or tecText3DBegin before calling tecTextSetClipping.\n"); ++outputInfo->m_numErrs; return -1; } if (___493 != 0 && ___493 != 1) { ___3183("Error in tecTextSetClipping: clipping = %d. Must be 0 or 1.\n", ___493); ++outputInfo->m_numErrs; return -1; } outputInfo->m_text.___2631 = (Clipping_e)___493; return 0; } int32_t tecTextSetColor_SZL( void*   fileHandle, int32_t color) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecTextSetColor")) return -1; if (!outputInfo->m_text.___2065()) { ___3182("Error in tecTextSetColor: You must begin a text by calling tecText2DBegin\n" "or tecText3DBegin before calling tecTextSetColor.\n"); ++outputInfo->m_numErrs; return -1; } if (color < 0 || 15 < color) { ___3183("Error in tecTextSetColor: color = %d. Must be 0 <= color <= 15.\n", color); ++outputInfo->m_numErrs; return -1; } outputInfo->m_text.___2632 = color; return 0; } int32_t tecTextSetTypeface_SZL( void*       fileHandle, char const* family, int32_t     isBold, int32_t     isItalic) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecTextSetTypeface")) return -1; if (!outputInfo->m_text.___2065()) { ___3182("Error in tecTextSetTypeface: You must begin a text by calling tecText2DBegin\n" "or tecText3DBegin before calling tecTextSetTypeface.\n"); ++outputInfo->m_numErrs; return -1; } if (!VALID_REF(family)) { ___3182("Error in tecTextSetTypeface: Invalid family input parameter.\n"); ++outputInfo->m_numErrs; return -1; } try { outputInfo->m_text.___2642 = family; if (isBold) outputInfo->m_text.___2643 = true; else outputInfo->m_text.___2643 = false; if (isItalic) outputInfo->m_text.___2644 = true; else outputInfo->m_text.___2644 = false; } catch (std::bad_alloc const&) { ___3182("Error in tecTextSetTypeface: Out of memory.\n"); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecTextSetLineSpacing_SZL( void*  fileHandle, double ___2285) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecTextSetLineSpacing")) return -1; if (!outputInfo->m_text.___2065()) { ___3182("Error in tecTextSetLineSpacing: You must begin a text by calling tecText2DBegin\n" "or tecText3DBegin before calling tecTextSetLineSpacing.\n"); ++outputInfo->m_numErrs;
return -1; } outputInfo->m_text.___2635 = ___2285; return 0; } int32_t tecTextSetMacroFunctionCmd_SZL( void*       fileHandle, char const* macroFunctionCmd) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecTextSetMacroFunctionCmd")) return -1; if (!outputInfo->m_text.___2065()) { ___3182("Error in tecTextSetMacroFunctionCmd: You must begin a text by calling tecText2DBegin\n" "or tecText3DBegin before calling tecTextSetMacroFunctionCmd.\n"); ++outputInfo->m_numErrs; return -1; } try { outputInfo->m_text.___2636 = macroFunctionCmd; } catch (std::bad_alloc const&) { ___3182("Error in tecTextSetMacroFunctionCmd: Out of memory.\n"); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecTextSetScope_SZL( void*   fileHandle, int32_t ___3440) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecTextSetScope")) return -1; if (!outputInfo->m_text.___2065()) { ___3182("Error in tecTextSetScope: You must begin a text by calling tecText2DBegin\n" "or tecText3DBegin before calling tecTextSetScope.\n"); ++outputInfo->m_numErrs; return -1; } if (___3440 != 0 && ___3440 != 1) { ___3183("Error in tecTextSetScope: scope = %d. Must be 0 or 1.\n", ___3440); ++outputInfo->m_numErrs; return -1; } outputInfo->m_text.___2639 = (Scope_e)___3440; return 0; } int32_t tecTextEnd_SZL(void* fileHandle) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecTextEnd")) return -1; if (!outputInfo->m_text.___2065()) { ___3182("Error in tecTextEnd: You must begin a text by calling tecText2DBegin\n" "or tecText3DBegin before calling tecTextEnd.\n"); ++outputInfo->m_numErrs; return -1; } try { outputInfo->m_tecioData.___16(outputInfo->m_text); outputInfo->m_text = tecioszl::Text::invalidText(); } catch (std::bad_alloc const&) { ___3182("Error in tecTextEnd: Out of memory.\n"); outputInfo->m_text = tecioszl::Text::invalidText(); ++outputInfo->m_numErrs; return -1; } return 0; } int32_t tecUserRecAdd_SZL( void*       fileHandle, char const*  ) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecUserRecAdd")) return -1; ___3182("Error in tecUserRecAdd: User records not currently supported for subzone-load-on-demand files.\n"); ++outputInfo->m_numErrs; return -1; } int32_t tecFileWriterFlush_SZL( void*          fileHandle, int32_t        numZonesToRetain, int32_t const* zonesToRetain) { OutputInfo* outputInfo; if (!getOutputInfo(&outputInfo, fileHandle, "tecFileWriterFlush")) return -1; return flushDataToIntermediateFiles(outputInfo, numZonesToRetain, zonesToRetain, "tecFileWriterFlush"); } int32_t tecFileWriterClose_SZL(void** fileHandle) { OutputInfo* outputInfo; if (!fileHandle || !getOutputInfo(&outputInfo, *fileHandle, "tecFileWriterClose")) return -1; int32_t ___3356 = 0; if (outputInfo->m_hasBeenFlushedToDisk) { ___3356 = flushDataToIntermediateFiles(outputInfo, 0, NULL, "tecFileWriterClose"); if (___3356 == 0) ___3356 = convertIntermediateFilesToSZLFile(outputInfo, outputInfo->___2459, true, outputInfo->___2459, "tecFileWriterClose");
if (___3356 != 0) ++outputInfo->m_numErrs; } else { ___3356 = writeAllZonesToSZLFile(outputInfo, "tecFileWriterClose"); } if (outputInfo->m_debugLevel) { ___3183("File %s closed.\n", outputInfo->___2459.c_str()); if (outputInfo->m_numErrs) { ___3182("********************************************\n"); ___3183("      %d Errors occurred on this file\n", outputInfo->m_numErrs); ___3182("********************************************\n"); } } delete outputInfo; *fileHandle = NULL; return ___3356; } int32_t  ___4002(int32_t  ___1395) { REQUIRE(0 <= ___1395 && ___1395 < ___2378); return outputInfos[___1395]->m_tecioData.___2844(); } int32_t  ___4001(int32_t  ___1395) { REQUIRE(0 <= ___1395 && ___1395 < ___2378); return outputInfos[___1395]->m_tecioData.___2841(); } namespace { int checkFile( int32_t     ___1395, char const* routineName) { if ((___1395 < 0) || (___1395 >= ___2378)) { ___3185("%s: Attempt to use invalid file %d file must be between 1 and %d inclusive.\n", routineName, ___1395+1, ___2378); return -1; } if (outputInfos.empty() || !outputInfos[___1395]) { ___3184("Error in %s: Attempt to use file %d that hasn't been initialized with TECINI.\n", routineName, ___1395+1); return -1; } return 0; } } namespace { int checkData( int32_t     ___1395, char const* routineName) { try { bool checkConnectivity = (outputInfos[___1395]->m_fileType != 2); outputInfos[___1395]->m_tecioData.___4164(checkConnectivity); } catch (std::exception const& e) { ___3184("%s: Wrong number of data values in file %d:\n", routineName, ___1395+1); ___3183("%s\n", e.what()); ++outputInfos[___1395]->m_numErrs; return -1; } return 0; } } int32_t  ___3997( int32_t          fileNum, char const*      ___4175, char const*      ___4348, char const*      ___1392, char const*      ___3445, int32_t  const*  ___1405, int32_t  const*  ___939, int32_t  const*  ___2011) { outputInfos.resize(___2378); if (*___1405 == 2 && !___1810) { ___3182("TECINI: For SZL files, you must output a grid file (FileType = 1)\nprior to outputting a solution file (FileType = 2).\n"); return -1; } if ((size_t)fileNum < outputInfos.size() && outputInfos[fileNum]) { ___3183("TECINI: Attempting to initialize file %d twice before calling TECEND.\n", fileNum + 1); ++outputInfos[fileNum]->m_numErrs; return -1; } try { outputInfos[fileNum] = boost::make_shared<OutputInfo>( ___4175, ___4348, ___1392, ___3445, *___1405, *___939, (*___2011 ? FieldDataType_Double : FieldDataType_Float), ___1810.get()); if (*___1405 == 1) { ___1810 = outputInfos[fileNum]; } if (outputInfos[fileNum]->m_debugLevel) { ___3184("Dest    File #%d: %s\n", fileNum + 1, outputInfos[fileNum]->___2459.c_str()); ___3183("NumVars=%d\n", outputInfos[fileNum]->m_tecioData.___2841()); }
 #if defined TECIOMPI
outputInfos[fileNum]->m_comm = MPI_COMM_SELF; outputInfos[fileNum]->m_communicator.reset(new MPICommunicator(MPI_COMM_SELF)); outputInfos[fileNum]->___2394.reset(new MPINonBlockingCommunicationCollection(MPI_COMM_SELF)); outputInfos[fileNum]->m_localProcess = 0; outputInfos[fileNum]->m_mainProcess = 0;
 #endif
} catch(std::exception const& e) { ___3183("TECINI: %s\n", e.what()); return -1; } return 0; } int32_t  ___4012( int32_t         ___1395, char const*     ___4689, int32_t  const* ___4691, int32_t  const* ___1908, int32_t  const* ___2115, int32_t  const* ___2160, double const*   ___3639, int32_t  const* ___3784, int32_t  const*  , int32_t  const* ___2004, int32_t  const* ___2801, int32_t  const* ___1283, int32_t  const* ___4191, int32_t  const* ___2785, int32_t  const* ___4187, int32_t  const* ___2981, int32_t  const* ___4325, int32_t  const* ___3550, int32_t  const* ___3548) { if (checkFile(___1395, "TECZNE") < 0 || checkData(___1395, "TECZNE") < 0) return -1; if (*___2004 != 1) { ___3184("TECZNE: Point data is not currently allowed. " " Please use block format for file %lld, zone %lld.\n", lldfmt_t(___1395+1), lldfmt_t(outputInfos[___1395]->m_tecioData.___2844())); ++outputInfos[___1395]->m_numErrs; return -1; } try { if (outputInfos[___1395]->m_debugLevel) { ___3183("Writing Zone %d:\n", outputInfos[___1395]->m_tecioData.___2844() + 1); ___3183("      Title = %s\n", ___4689); ___3183("      Type  = %s\n", zoneTypeStrings[*___4691]); ___3183("      IMax  = %d\n", *___1908); ___3183("      JMax  = %d\n", *___2115); ___3183("      KMax  = %d\n", *___2160); if (___3550) { std::ostringstream ___2890; for (int i = 0; i < outputInfos[___1395]->m_tecioData.___2841(); ++i) { if (i > 0) ___2890 <<  ","; ___2890 << ___3550[i]; } ___3183("      DupList = %s\n", ___2890.str().c_str()); } } outputInfos[___1395]->m_tecioData.___19( ___4689, *___4691, *___1908, *___2115, *___2160, *___3639, *___3784, 0, *___2801, *___1283, ___4191 ? *___4191 : 0, ___2785 ? *___2785 : 0, ___4187 ? *___4187 : 0, NULL, ___2981, ___4325, ___3550, *___3548); outputInfos[___1395]->m_numValuesWritten = 0; } catch (std::exception const& e) { ___3183("TECZNE: %s\n", e.what()); ++outputInfos[___1395]->m_numErrs; return -1; } return 0; } int32_t  ___3992( int32_t         ___1395, int32_t  const* N, void const*     ___1350, int32_t  const* ___2012) { if (checkFile(___1395, "TECDAT") < 0) return -1; try { outputInfos[___1395]->m_tecioData.___429((___2225)*N, ___1350, (*___2012 != 0)); if (outputInfos[___1395]->m_debugLevel && (*N > 1)) ___3184("Writing %d values to file %d.\n", *N, ___1395 + 1); if (outputInfos[___1395]->m_debugLevel > 1) { double* dPtr = (double*)___1350; float* fPtr = (float*)___1350; for(int32_t i = 0; i < *N; ++i) { double ___4296 = (*___2012 ? dPtr[i] : fPtr[i]); ___3184("%" PRIu64 " %G\n", ++outputInfos[___1395]->m_numValuesWritten, ___4296); } } } catch (std::exception const& e) { ___3183("TECDAT: %s\n", e.what());
++outputInfos[___1395]->m_numErrs; return -1; } return 0; } int32_t  ___3999( int32_t         ___1395, int32_t  const* ___2687) { if (checkFile(___1395, "TECNOD") < 0) return -1; ___4634 curZone = outputInfos[___1395]->m_tecioData.___2844(); Zone_s* zonePtr = outputInfos[___1395]->m_tecioData.zonePtr(curZone); if (!zonePtr->m_partitionMap.empty()) { zonePtr = zonePtr->m_partitionMap.rbegin()->second.get(); } else if (!zonePtr->m_partitionOwners.empty()) { ___3182("TECNOD: Must call TECFEPTN to create a partition before calling TECDAT or TECNOD"); return -1; } int32_t  N = (int32_t )(zonePtr->___2495->___2390 * zonePtr->___2495->___2498); return ___4000(___1395, &N, ___2687); } int32_t  ___4000( int32_t         ___1395, int32_t  const* N, int32_t  const* ___2687) { if (checkFile(___1395, "TECNODE") < 0) return -1; try { outputInfos[___1395]->m_tecioData.___431((___2225)*N, ___2687); if (outputInfos[___1395]->m_debugLevel && (*N > 1)) ___3184("Writing %d nodes to file %d.\n", *N, ___1395 + 1); } catch (std::exception const& e) { ___3183("TECNODE: %s\n", e.what()); ++outputInfos[___1395]->m_numErrs; return -1; } return 0; } int32_t TECIOSZL_FLUSH( int32_t        fileNum, int32_t const* numZonesToRetain, int32_t const* zonesToRetain) { if (checkFile(fileNum, "TECFLUSH") != 0 || checkData(fileNum, "TECFLUSH") != 0) return -1; return flushDataToIntermediateFiles(outputInfos[fileNum].get(), *numZonesToRetain, zonesToRetain, "TECFLUSH"); } int32_t  ___3993(int32_t  ___1395) { if (checkFile(___1395, "TECEND") != 0 || checkData(___1395, "TECEND") != 0) return -1; int32_t ___3356 = 0; if (outputInfos[___1395]->m_hasBeenFlushedToDisk) { ___3356 = flushDataToIntermediateFiles(outputInfos[___1395].get(), 0, NULL, "TECEND"); if (___3356 == 0) ___3356 = convertIntermediateFilesToSZLFile(outputInfos[___1395].get(), outputInfos[___1395]->___2459, true, outputInfos[___1395]->___2459, "TECEND"); } else { ___3356 = writeAllZonesToSZLFile(outputInfos[___1395].get(), "TECEND"); } if (!outputInfos.empty() && outputInfos[___1395]->m_debugLevel) { ___3183("File %d closed.\n", ___1395 + 1); if (outputInfos[___1395]->m_numErrs) { ___3182("********************************************\n"); ___3183("      %d Errors occurred on this file\n", outputInfos[___1395]->m_numErrs); ___3182("********************************************\n"); } } outputInfos[___1395].reset(); return ___3356; } int32_t  ___3998( int32_t     ___1395, char const* S) { if (checkFile(___1395, "TECLAB") < 0) return -1; return tecCustomLabelsAddSet_SZL(outputInfos[___1395].get(), S); } int32_t  ___4009( int32_t     ___1395, char const*  ) { if (checkFile(___1395, "TECUSR") < 0) return -1; ___3182("TECUSR: User records not currently supported for subzone-load-on-demand files.\n"); ++outputInfos[___1395]->m_numErrs; return 0; } int32_t  ___3996( int32_t         ___1395, double const*   ___4574, double const*   ___4591, double const*   ___4714, int32_t  const* ___3158, int32_t  const* ___227,
int32_t  const* ___4598, int32_t  const* Color, int32_t  const* ___1410, int32_t  const* ___2021, int32_t  const* ___1650, int32_t  const* ___2262, double const*   ___2985, double const*   ___2288, int32_t  const* ___2792, int32_t  const* ___188, int32_t  const* ___176, double const*   ___187, double const*   ___171, int32_t  const* ___3441, int32_t  const* ___494, int32_t  const* ___2834, int32_t  const* ___2836, float const*    ___4568, float const*    ___4586, float const*    ___4595, char const*     mfc) { if (checkFile(___1395, "TECGEO") < 0) return -1; if (outputInfos[___1395]->m_debugLevel) ___3182("\nInserting Geometry\n"); try { ___2225 const maxLocalBuffLen = 1024; ___2225 localNumSegPts[maxLocalBuffLen]; ___2225 *localNumSegPtsRef = *___2834 < maxLocalBuffLen ? localNumSegPts : new ___2225[*___2834]; for (int32_t sIndex = 0; sIndex < *___2834; ++sIndex) localNumSegPtsRef[sIndex] = ___2836[sIndex]; ___372 const ___2002 = (*___227 == 0 ? ___1303 : ___4224); outputInfos[___1395]->m_tecioData.___9(*___4574, *___4591, *___4714, (CoordSys_e)(*___3158), ___2002, *___4598, (___514)*Color, (___514)*___1410, (___372)*___2021, (GeomForm_e)(*___1650), (LinePattern_e)(*___2262), *___2985, *___2288, (uint16_t)(*___2792), (ArrowheadStyle_e)(*___188), (ArrowheadAttachment_e)(*___176), *___187, *___171, (Scope_e)(*___3441), (Clipping_e)(*___494), *___2834, localNumSegPtsRef, ___4568, ___4586, ___4595, mfc); if (localNumSegPtsRef != localNumSegPts) delete [] localNumSegPtsRef; } catch(...) { ___3182("TECGEO: Out of memory or unknown error\n"); ++outputInfos[___1395]->m_numErrs; return 1; } return 0; } int32_t  ___4008( int32_t         ___1395, double const*   ___4573, double const*   ___4590, double const*   ___4712, int32_t  const* ___3158, int32_t  const* ___227, int32_t  const* ___4598, int32_t  const* ___353, int32_t  const* ___1451, double const*   ___1449, int32_t  const* ___411, double const*   ___409, double const*   ___407, int32_t  const* ___403, int32_t  const* ___405, double const*   ___57, int32_t  const* ___39, double const*   ___2286, int32_t  const* ___4079, int32_t  const* ___3441, int32_t  const* ___494, char const*     ___3811, char const*     mfc) { if (checkFile(___1395, "TECTXT") < 0) return -1; if (outputInfos[___1395]->m_debugLevel) ___3183("\nInserting Text: %s\n", ___3811); try { ___372 const ___2002 = (*___227 == 0 ? ___1303 : ___4224); outputInfos[___1395]->m_tecioData.___16(*___4573, *___4590, *___4712, (CoordSys_e)*___3158, ___2002, *___4598, (Font_e)*___353, (Units_e)*___1451, *___1449, (TextBox_e)*___411, *___409, *___407, (___514)*___403, (___514)*___405, *___57, (TextAnchor_e)*___39, *___2286, (___514)*___4079, (Scope_e)*___3441,
(Clipping_e)*___494, ___3811, mfc); } catch(...) { ___3182("TECTXT: Out of memory or unknown error\n"); ++outputInfos[___1395]->m_numErrs; return 1; } return 0; } void ___3995( int32_t         ___1395, int32_t  const*   ) { if (checkFile(___1395, "TECFOREIGN") < 0) return; ___3182("TECFOREIGN: Foreign byte order not currently supported for subzone-load-on-demand files.\n"); ++outputInfos[___1395]->m_numErrs; } int32_t  ___3991( int32_t     ___1395, char const* ___2684, char const* ___4313) { if (checkFile(___1395, "TECAUXSTR") < 0) return -1; if (outputInfos[___1395]->m_debugLevel) ___3184("\nInserting data set aux data: '%s' = '%s'\n", ___2684, ___4313); if (!checkAuxNameAndValue(outputInfos[___1395].get(), ___2684, ___4313, "TECAUXSTR")) return -1; outputInfos[___1395]->m_tecioData.___8(___2684, ___4313); return 0; } int32_t  ___4011( int32_t     ___1395, char const* ___2684, char const* ___4313) { if (checkFile(___1395, "TECZAUXSTR") < 0) return -1; if (outputInfos[___1395]->m_tecioData.___2844() == 0) { ___3182("TECZAUXSTR: Must call TECZNE prior to TECZAUXSTR\n"); ++outputInfos[___1395]->m_numErrs; return -1; } if (outputInfos[___1395]->m_debugLevel) ___3184("\nInserting zone aux data: '%s' = '%s'\n", ___2684, ___4313); if (!checkAuxNameAndValue(outputInfos[___1395].get(), ___2684, ___4313, "TECZAUXSTR")) return -1; int32_t ___2844 = outputInfos[___1395]->m_tecioData.___2844(); outputInfos[___1395]->m_tecioData.___20(___2844, ___2684, ___4313); return 0; } int32_t  ___4010( int32_t         ___1395, int32_t  const* ___4335, char const*     ___2684, char const*     ___4313) { if (checkFile(___1395, "TECVAUXSTR") < 0) return -1; if (outputInfos[___1395]->m_debugLevel) ___3184("\nInserting variable aux data: '%s' = '%s'\n", ___2684, ___4313); if (!checkAuxNameAndValue(outputInfos[___1395].get(), ___2684, ___4313, "TECVAUXSTR")) return -1; outputInfos[___1395]->m_tecioData.___18(*___4335, ___2684, ___4313); return 0; } int32_t  ___3994( int32_t         ___1395, int32_t  const* ___1256) { if (checkFile(___1395, "TECFACE") < 0) return -1; if (outputInfos[___1395]->m_debugLevel) ___3182("\nInserting face neighbor data\n"); Zone_s* zonePtr = outputInfos[___1395]->m_tecioData.zonePtr(outputInfos[___1395]->m_tecioData.___2844()); try { outputInfos[___1395]->m_tecioData.___430(zonePtr, ___1256); } catch (std::exception const& e) { ___3183("TECFACE: %s\n", e.what()); ++outputInfos[___1395]->m_numErrs; return -1; } return 0; } int32_t  ___4006(int32_t  ___1395) { ___4276(___1395); return 0; } int32_t  ___4007(int32_t  ___1395) { ___4276(___1395); return 0; } int32_t  ___4003( int32_t         ___1395, int32_t  const* ___1292, int32_t  const* ___1295, int32_t  const* ___1257, int32_t  const* ___1301, int32_t  const* ___1251, int32_t  const* ___1252, int32_t  const* ___1254) { ___4276(___1292);
___4276(___1295); ___4276(___1257); ___4276(___1301); ___4276(___1251); ___4276(___1252); ___4276(___1254); if (checkFile(___1395, "TECPOLY") < 0) return -1; ___3182("TECPOLY: Polyhedral zones not currently supported for subzone-load-on-demand files.\n"); ++outputInfos[___1395]->m_numErrs; return 0; } int32_t  ___4005( int32_t         ___1395, int32_t  const* ___2804, int32_t  const* ___1292, int32_t  const* ___1295, int32_t  const* ___1257, int32_t  const* ___1301) { ___4276(___2804); ___4276(___1292); ___4276(___1295); ___4276(___1257); ___4276(___1301); if (checkFile(___1395, "TECPOLYFACE") < 0) return -1; ___3182("TECPOLYFACE: Polyhedral zones not currently supported for subzone-load-on-demand files.\n"); ++outputInfos[___1395]->m_numErrs; return 0; } int32_t  ___4004( int32_t         ___1395, int32_t  const* ___2776, int32_t  const* ___1251, int32_t  const* ___1252, int32_t  const* ___1254) { ___4276(___2776); ___4276(___1251); ___4276(___1252); ___4276(___1254); if (checkFile(___1395, "TECPOLYBCONN") < 0) return -1; ___476(TecplotSDKBinaryFileVersion == 191); ___3182("TECPOLYBCONN: Polyhedral zones not currently supported for subzone-load-on-demand files.\n"); ++outputInfos[___1395]->m_numErrs; return 0; }
 #if defined TECIOMPI
int32_t  TECIOSZL_MPIINIT( int32_t *       fileNum, void*           communicator, int32_t  const* mainrank) { BOOST_STATIC_ASSERT(sizeof(int) == 4); INVARIANT(mpiSizeof(MPI_INT) == 4); MPI_Comm comm;
 #if defined OPEN_MPI
MPI_Fint fComm = *(static_cast<MPI_Fint*>(communicator)); comm = MPI_Comm_f2c(fComm); if (!comm)
 #endif
comm = *(static_cast<MPI_Comm*>(communicator)); return szlMPIInit(outputInfos[*fileNum].get(), comm, *mainrank); } int32_t  TECIOSZL_ZNEMAP( int32_t         fileNum, int32_t  const* npartitions, int32_t  const* ptnworkers) { if (checkFile(fileNum, "TECZNEMAP") < 0) return -1; OutputInfo* outputInfo = outputInfos[fileNum].get(); return storeZonePartitionInfo(outputInfo, *npartitions, ptnworkers, "TECZNEMAP"); }
 #endif
int32_t  TECIOSZL_FEPTN( int32_t         fileNum, int32_t  const* ___2975, int32_t  const* numnodes, int32_t  const* numcells, int32_t  const* ngnodes, int32_t  const* gnodes, int32_t  const* gnpartitions, int32_t  const* gnpnodes, int32_t  const* ngcells, int32_t  const* gcells) { if (checkFile(fileNum, "TECFEPTN")) return -1; if (outputInfos[fileNum]->m_tecioData.___2844() == 0) { ___3182("TECFEPTN: Must call TECZNE prior to calling TECFEPTN.\n"); ++outputInfos[fileNum]->m_numErrs; return -1; } Zone_s* zonePtr = outputInfos[fileNum]->m_tecioData.zonePtr(outputInfos[fileNum]->m_tecioData.___2844()); if (!___3892(zonePtr->___2682)) { ___3182("TECFEPTN: Called for the wrong zone type; can be called only for 3D FE zones.\n"); ++outputInfos[fileNum]->m_numErrs; return -1; } if (!___2975 || *___2975 < 1) { ___3182("TECFEPTN: Invalid Partition input parameter.\n"); ++outputInfos[fileNum]->m_numErrs; return -1; } if (!numnodes || *numnodes < 1) { ___3182("TECFEPTN: Invalid NumNodes input parameter.\n"); ++outputInfos[fileNum]->m_numErrs; return -1; } if (!numcells || *numcells < 1) { ___3182("TECFEPTN: Invalid NumCells input parameter.\n"); ++outputInfos[fileNum]->m_numErrs; return -1; } if (!ngnodes || *ngnodes < 0) { ___3182("TECFEPTN: Invalid NGNodes input parameter.\n"); ++outputInfos[fileNum]->m_numErrs; return -1; } if (*ngnodes > 0) { if (!gnodes) { ___3182("TECFEPTN: Invalid GNodes input parameter.\n"); ++outputInfos[fileNum]->m_numErrs; return -1; } else if (!gnpartitions) { ___3182("TECFEPTN: Invalid GNPartitions input parameter.\n"); ++outputInfos[fileNum]->m_numErrs; return -1; } else if (!gnpnodes) { ___3182("TECFEPTN: Invalid GNPNodes input parameter.\n"); ++outputInfos[fileNum]->m_numErrs; return -1; } } if (!ngcells || *ngcells < 0) { ___3182("TECFEPTN: Invalid NGCells input parameter.\n"); ++outputInfos[fileNum]->m_numErrs; return -1; } if (*ngcells > 0 && !gcells) { ___3182("TECFEPTN: Invalid GCells input parameter.\n"); ++outputInfos[fileNum]->m_numErrs; return -1; } try { int32_t partitionZone = outputInfos[fileNum]->m_tecioData.___2844(); ___476(partitionZone > 0); zonePtr = outputInfos[fileNum]->m_tecioData.zonePtr(partitionZone);
 #if defined TECIOMPI
if (zonePtr->m_partitionOwners.empty()) { throw std::logic_error("Must call TECZNEMAP prior to calling TECFEPTN"); } else if (static_cast<size_t>(*___2975) > zonePtr->m_partitionOwners.size()) { std::ostringstream ___2890; ___2890 << "Invalid partition number passed to TECFEPTN: " << ___2975; throw std::logic_error(___2890.str().c_str()); }
 #else
___4276(___2975);
 #endif 
if (!zonePtr->m_partitionMap.empty() && checkData(fileNum, "TECFEPTN") < 0) return -1; outputInfos[fileNum]->m_tecioData.addFEZonePartition( partitionZone, *___2975, *numnodes, *numcells, std::vector<int64_t>(gnodes, gnodes + *ngnodes), std::vector<int32_t>(gnpartitions, gnpartitions + *ngnodes), std::vector<int64_t>(gnpnodes, gnpnodes + *ngnodes), std::vector<int64_t>(gcells, gcells + *ngcells)); } catch(std::exception const& e) { ___3183("TEFECPTN: %s\n", e.what()); ++outputInfos[fileNum]->m_numErrs; return -1; } return 0; } namespace { bool checkParameter(int32_t  const* parameter, char const* parameterName, int32_t  minValue, int32_t  maxValue) { if (!parameter || *parameter < minValue || *parameter > maxValue) { ___3183("TECIJKPTN: Invalid %s input parameter.\n", parameterName); return false; } else { return true; } } } int32_t  TECIOSZL_IJKPTN( int32_t         fileNum, int32_t  const* ___2975, int32_t  const* imin, int32_t  const* jmin, int32_t  const* kmin, int32_t  const* imax, int32_t  const* jmax, int32_t  const* kmax) { if (checkFile(fileNum, "TECIJKPTN")) return -1; if (outputInfos[fileNum]->m_tecioData.___2844() == 0) { ___3182("TECIJKPTN: Must call TECZNE prior to calling TECIJKPTN.\n"); ++outputInfos[fileNum]->m_numErrs; return 1; } Zone_s* zonePtr = outputInfos[fileNum]->m_tecioData.zonePtr(outputInfos[fileNum]->m_tecioData.___2844()); if (!supportedOrderedVolumeZoneType(zonePtr->___2682, zonePtr->___2680)) { ___3182("TECIJKPTN: Called for the wrong zone type; can be called only for 3D FE zones.\n"); ++outputInfos[fileNum]->m_numErrs; return 1; } if (!___2975 || *___2975 < 1) { ___3182("TECIJKPTN: Invalid Partition input parameter.\n"); ++outputInfos[fileNum]->m_numErrs; return -1; } if (!checkParameter(imin, "imin", 1,     static_cast<int32_t>(zonePtr->___2680.i()))) return -1; if (!checkParameter(jmin, "jmin", 1,     static_cast<int32_t>(zonePtr->___2680.___2103()))) return -1; if (!checkParameter(kmin, "kmin", 1,     static_cast<int32_t>(zonePtr->___2680.___2132()))) return -1; if (!checkParameter(imax, "imax", *imin, static_cast<int32_t>(zonePtr->___2680.i()))) return -1; if (!checkParameter(jmax, "jmax", *jmin, static_cast<int32_t>(zonePtr->___2680.___2103()))) return -1; if (!checkParameter(kmax, "kmax", *kmin, static_cast<int32_t>(zonePtr->___2680.___2132()))) return -1; try { int32_t partitionZone = outputInfos[fileNum]->m_tecioData.___2844(); ___476(partitionZone > 0); zonePtr = outputInfos[fileNum]->m_tecioData.zonePtr(partitionZone);
 #if defined TECIOMPI
if (zonePtr->m_partitionOwners.empty()) { throw std::logic_error("Must call TECZNEMAP prior to calling TECIJKPTN"); } else if (static_cast<size_t>(*___2975) > zonePtr->m_partitionOwners.size()) { std::ostringstream ___2890; ___2890 << "Invalid partition number passed to TECIJKPTN: " << ___2975; throw std::logic_error(___2890.str().c_str()); }
 #else
___4276(___2975);
 #endif 
if (!zonePtr->m_partitionMap.empty() && checkData(fileNum, "TECIJKPTN") < 0) return -1; outputInfos[fileNum]->m_tecioData.addIJKZonePartition( partitionZone, *___2975, *imin, *jmin, *kmin, *imax, *jmax, *kmax); } catch (std::exception const& e) { ___3183("TECIJKPTN: %s\n", e.what()); ++outputInfos[fileNum]->m_numErrs; return -1; } return 0; } int32_t tecioszl_convertrawdata(char const* ___1392) {
 #if defined TECIOMPI
MPIFileReader inputFile(___1392, MPI_COMM_WORLD);
 #else
FileStreamReader inputFile(___1392);
 #endif
if (!inputFile.open()) return 1; ___476(inputFile.___2039()); char asciiFileIndicator[3]; bool readASCII = false; inputFile.fread(asciiFileIndicator, 1, 3); if (asciiFileIndicator[0] == 'T') readASCII = true; int ___2674 = 0; int numRanks = 1;
 #if defined TECIOMPI
MPI_Comm_rank(MPI_COMM_WORLD, &___2674); MPI_Comm_size(MPI_COMM_WORLD, &numRanks);
 #endif
___1391 requiredNumRanks; readScalar(inputFile, requiredNumRanks, readASCII); if (static_cast<___1391>(numRanks) != requiredNumRanks) { std::ostringstream ___2890; ___2890 << "Converting file " << inputFile.___1392() << " requires " << requiredNumRanks << " MPI ranks."; if (___2674 == 0) std::cerr << ___2890.str() << std::endl; throw std::runtime_error(___2890.str()); } ___1391 sizeOfFileLoc = readASCII ? 2 + ___199<___1391, false>::size : sizeof(___1391); ___1391 fileLocLoc = 3 + (___2674 + 1) * sizeOfFileLoc; inputFile.___3457(fileLocLoc); ___1391 fileLoc; readScalar(inputFile, fileLoc, readASCII); inputFile.___3457(fileLoc); ___3968 tecioData(inputFile, readASCII); ___4014 ___4013(tecioData); bool const ___4478 =
 #if defined WRITEASCII
true;
 #else
false;
 #endif
___1386 ___1385( ___4478, ___843, DEFAULT_SUBZONE_MAX_IJK_DIM, DEFAULT_SUBZONE_MAX_FE_SIZE); ___1385.setFileVersion(SZPLT_CUR_WRITE_VERSION); ___1385.setCodeRevision(1); DataWriteStatistics ___933; boost::scoped_ptr<FileWriterInterface> szpltFile; boost::shared_ptr<DataSetWriter> dataSetWriter; std::string outputFileName(___1392); size_t suffixLocation = outputFileName.rfind(".szplt"); if (suffixLocation == std::string::npos) outputFileName += ".szplt"; else outputFileName.erase(suffixLocation + 6);
 #if defined TECIOMPI
szpltFile.reset(new MPIFileWriter(outputFileName.c_str(), MPI_COMM_WORLD)); dataSetWriter = boost::make_shared<DataSetWriterMPI>( &___4013, ___3499(0), ___3499(0), ___1385.___1755(), ___1385.___1754(), static_cast<MPI_Comm>(MPI_COMM_WORLD), 0, ___2674);
 #else
szpltFile.reset(new FileStreamWriter(outputFileName.c_str())); dataSetWriter = boost::make_shared<DataSetWriter>( &___4013, ___3499(0), ___3499(0), ___1385.___1755(), ___1385.___1754());
 #endif
if (!szpltFile->open(false)) { std::cerr << "Unable to open file " << outputFileName << " for writing" << std::endl; return -1; } else { szpltFile->___3492(___1385.___2000()); szpltFile->setDataFileType(___1385.___842());
 #if defined TECIOMPI
if (___2674 != 0) { if (___4013.___894()) { ___1390 szpltZoneHeaderFileLocs; if (!szpltZoneHeaderFileLocs.alloc(___4013.___889()) || !dataSetWriter->writeDataSet(*szpltFile, szpltZoneHeaderFileLocs)) { std::cerr << "Error writing file" << std::endl; return -1; } } } else {
 #endif
if (!___1240( ___4013, *szpltFile, ___1385, includeRevisionNumber(), *dataSetWriter, ___3499(0), ___3499(0), ___933)) { std::cerr << "Error writing file" << std::endl; return -1; }
 #if defined TECIOMPI
}
 #endif
} szpltFile->close(true); return 0; } namespace { template <typename T> bool allocVector(std::vector<T>& vec, size_t count, T ___4312) { try { vec.assign(count, ___4312); return true; } catch (std::bad_alloc const&) { return false; } } struct TecioSzlDataReaderCache { FileStreamReader szpltFile; ___1386  ___1385; ___4350       ___2841; ___4634      ___2844; std::string      dataSetTitle; ___4705  ___4704; ___1390     ___4627; ___2238<ZoneMetadata> zoneMetadata; std::vector<std::pair<std::string, std::string> > dataSetAuxData; std::vector<std::vector<std::pair<std::string, std::string> > > varAuxData; std::vector<std::vector<std::pair<std::string, std::string> > > zoneAuxData; CustomLabelsArray customLabelsArray; GeomArray geomArray; TextArray textArray; ___2238<uint8_t> zoneHeaderIsRead; ___2238<___2238<char> > zonePartitionHeaderIsRead; TecioSzlDataReaderCache(char const* ___1392) : szpltFile(___1392) {} bool allocateArrays() { if (___2841 > 0 && ___2844 > 0) return ___4627.alloc(___2844) && zoneMetadata.alloc(___2844) && zoneHeaderIsRead.alloc((uint64_t)___2844, (uint8_t)0) && zonePartitionHeaderIsRead.alloc((uint64_t)___2844); return true; } }; } int32_t tecioSZL_CustomLabelsGetNumSets(void* fileHandle, int32_t* numSets) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(VALID_REF(numSets)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *numSets = static_cast<int32_t>(szlDataReaderCache->customLabelsArray.size()); return 0; } namespace { bool duplicateString(char const* source, char** target) { REQUIRE(VALID_REF(source)); REQUIRE(VALID_REF(target) && *target == NULL); try { *target = new char[strlen(source) + 1]; strcpy(*target, source); return true; } catch (std::bad_alloc const&) { std::cerr << "Error: Out of memory while duplicating string." << std::endl; return false; } } } int32_t tecioSZL_CustomLabelsGetSet(void* fileHandle, int32_t ___4451, char** labelSet) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4451 && ___4451 <= static_cast<int32_t>(szlDataReaderCache->customLabelsArray.size())); REQUIRE(VALID_REF(labelSet) && *labelSet == NULL); std::ostringstream ___2890; CustomLabelSet const& customLabelSet = szlDataReaderCache->customLabelsArray[___4451 - 1]; for (uint32_t i = 0; i < customLabelSet.m_numLabels - 1; ++i) ___2890 <<'"' << customLabelSet.m_labels[i] << "\", "; ___2890 << '"' << customLabelSet.m_labels[customLabelSet.m_numLabels - 1] << '"'; if (!duplicateString(___2890.str().c_str(), labelSet)) return -1; return 0; } namespace { int32_t duplicateAuxDataItem(std::pair<std::string, std::string> const& auxData, char** ___2683, char** ___4312) { REQUIRE(VALID_REF(___2683) && *___2683 == NULL); REQUIRE(VALID_REF(___4312) && *___4312 == NULL);
int32_t ___3356 = 0; if (!duplicateString(auxData.first.c_str(), ___2683)) { ___3356 = -1; } else if (!duplicateString(auxData.second.c_str(), ___4312)) { delete[] *___2683; *___2683 = NULL; ___3356 = -1; } ENSURE(___3356 == 0 || ___3356 == -1); ENSURE(EQUIVALENCE(___3356 == 0, VALID_REF(*___2683))); ENSURE(EQUIVALENCE(___3356 == 0, VALID_REF(*___4312))); return ___3356; } } int32_t tecioSZL_DataSetAuxDataGetItem(void* fileHandle, int32_t whichItem, char** ___2683, char** ___4312) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < whichItem && whichItem <= static_cast<int32_t>(szlDataReaderCache->dataSetAuxData.size())); REQUIRE(VALID_REF(___2683) && *___2683 == NULL); REQUIRE(VALID_REF(___4312) && *___4312 == NULL); return duplicateAuxDataItem(szlDataReaderCache->dataSetAuxData[whichItem - 1], ___2683, ___4312); } int32_t tecioSZL_DataSetAuxDataGetNumItems(void* fileHandle, int32_t* ___2810) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(VALID_REF(___2810)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *___2810 = static_cast<int32_t>(szlDataReaderCache->dataSetAuxData.size()); return 0; } int32_t tecioSZL_DataSetGetNumVars(void* fileHandle, int32_t* ___2841) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(VALID_REF(___2841)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *___2841 = static_cast<int32_t>(szlDataReaderCache->___2841); return 0; } int32_t tecioSZL_DataSetGetNumZones(void* fileHandle, int32_t* ___2844) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(VALID_REF(___2844)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *___2844 = static_cast<int32_t>(szlDataReaderCache->___2844); return 0; } int32_t tecioSZL_DataSetGetTitle(void* fileHandle, char** ___4175) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(VALID_REF(___4175) && *___4175 == NULL); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); if (!duplicateString(szlDataReaderCache->dataSetTitle.c_str(), ___4175)) return -1; return 0; } int32_t tecioSZL_FileGetType(void* fileHandle, int32_t* ___1405) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(VALID_REF(___1405)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *___1405 = static_cast<int32_t>(szlDataReaderCache->___1385.___842()); return 0; } int32_t tecioSZL_FileReaderClose(void** fileHandle) { TecioSzlDataReaderCache* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache*>(*fileHandle); int32_t returnCode = 0; if (!szlDataReaderCache->szpltFile.close(true)) returnCode = -1; delete szlDataReaderCache; *fileHandle = NULL; return returnCode; } namespace { bool readAndCategorizeAuxData(TecioSzlDataReaderCache* szlDataReaderCache, ___3943 ___3942)
{ REQUIRE(VALID_REF(szlDataReaderCache)); uint32_t auxDataCount = 0; AuxDataArray auxDataArray; szlDataReaderCache->varAuxData.resize(szlDataReaderCache->___2841); szlDataReaderCache->zoneAuxData.resize(szlDataReaderCache->___2844); bool ___3356 = (readAuxDataCount(szlDataReaderCache->szpltFile, ___3942, auxDataCount) == ___4224); if (auxDataCount > 0) { ___3356 = ___3356 && (auxDataArray.alloc(static_cast<uint64_t>(auxDataCount)) == ___4224) && (readAuxData(szlDataReaderCache->szpltFile, ___3942, 0, 0, 0, auxDataArray) == ___4224); } for (uint32_t i = 0; i < auxDataCount; ++i) { switch (auxDataArray[i].m_location) { case ___253: szlDataReaderCache->dataSetAuxData.push_back(std::make_pair(auxDataArray[i].___2493, auxDataArray[i].___2665)); break; case ___258: szlDataReaderCache->varAuxData[auxDataArray[i].m_entity - 1].push_back(std::make_pair(auxDataArray[i].___2493, auxDataArray[i].___2665)); break; case ___259: szlDataReaderCache->zoneAuxData[auxDataArray[i].m_entity - 1].push_back(std::make_pair(auxDataArray[i].___2493, auxDataArray[i].___2665)); break; default: ___476(___1303); break; } } return ___3356; } bool readAndStoreCustomLabels(TecioSzlDataReaderCache* szlDataReaderCache, ___3943 ___3942) { REQUIRE(VALID_REF(szlDataReaderCache)); uint32_t customLabelsCount = 0; bool ___3356 = (readCustomLabelsCount(szlDataReaderCache->szpltFile, ___3942, customLabelsCount) == ___4224); if (customLabelsCount > 0) { uint32_t ___2863 = 0; ___3356 = ___3356 && (szlDataReaderCache->customLabelsArray.alloc(static_cast<uint64_t>(customLabelsCount)) == ___4224) && readCustomLabels(szlDataReaderCache->szpltFile, ___3942, ___2863, szlDataReaderCache->customLabelsArray); } return ___3356; } bool readAndStoreGeoms(TecioSzlDataReaderCache* szlDataReaderCache, ___3943 ___3942) { REQUIRE(VALID_REF(szlDataReaderCache)); uint32_t geomCount = 0; bool ___3356 = (readGeometriesCount(szlDataReaderCache->szpltFile, ___3942, geomCount) == ___4224); if (geomCount > 0) { uint32_t ___2863 = 0; ___3356 = ___3356 && (szlDataReaderCache->geomArray.alloc(static_cast<uint64_t>(geomCount)) == ___4224) && readGeometries(szlDataReaderCache->szpltFile, ___3942, ___2863, szlDataReaderCache->geomArray); } return ___3356; } bool readAndStoreTexts(TecioSzlDataReaderCache* szlDataReaderCache, ___3943 ___3942) { REQUIRE(VALID_REF(szlDataReaderCache)); uint32_t textCount = 0; bool ___3356 = (readTextsCount(szlDataReaderCache->szpltFile, ___3942, textCount) == ___4224); if (textCount > 0) { uint32_t ___2863 = 0; ___3356 = ___3356 && (szlDataReaderCache->textArray.alloc(static_cast<uint64_t>(textCount)) == ___4224) && readTexts(szlDataReaderCache->szpltFile, ___3942, ___2863, szlDataReaderCache->textArray); } return ___3356; } } TecioSZLFileOpenResult_e tecioSZL_FileReaderOpen(char const* ___1392, void** fileHandle) { REQUIRE(VALID_REF(___1392) && strlen(___1392) > 0); REQUIRE(VALID_REF(fileHandle) && *fileHandle == NULL); TecioSZLFileOpenResult_e returnCode = TecioSZLFileOpenResult_OK;
TecioSzlDataReaderCache* szlDataReaderCache = NULL; try { szlDataReaderCache = new TecioSzlDataReaderCache(___1392); if (!szlDataReaderCache->szpltFile.open()) { returnCode = TecioSZLFileOpenResult_ErrorOpeningFile; } else { uint64_t byteOrderIndicator; uint64_t dataSetHeaderLocation; ___3943 ___3942; if (!readDataFileHeader(szlDataReaderCache->szpltFile, szlDataReaderCache->___1385, byteOrderIndicator, dataSetHeaderLocation) || !szlDataReaderCache->szpltFile.___3457(dataSetHeaderLocation) || !readDataSetHeaderTags(szlDataReaderCache->szpltFile, szlDataReaderCache->___1385, ___3942) || !applyDataSetHeaderScalarTagValues(___3942, szlDataReaderCache->___2841, szlDataReaderCache->___2844) || !szlDataReaderCache->allocateArrays() || !readDataSetHeader(szlDataReaderCache->szpltFile, ___3942, szlDataReaderCache->dataSetTitle, szlDataReaderCache->___4704, szlDataReaderCache->___4627) || !readAndCategorizeAuxData(szlDataReaderCache, ___3942) || !readAndStoreCustomLabels(szlDataReaderCache, ___3942) || !readAndStoreGeoms(szlDataReaderCache, ___3942) || !readAndStoreTexts(szlDataReaderCache, ___3942)) { returnCode = TecioSZLFileOpenResult_BadFormat; } else { for (___4634 zone = 0; zone < szlDataReaderCache->___2844; ++zone) storeZoneMetadata(szlDataReaderCache->___4704, zone, 0, szlDataReaderCache->zoneMetadata[zone]); } } } catch (std::bad_alloc const&) { returnCode = TecioSZLFileOpenResult_OutOfMemory; } if (returnCode == 0) *fileHandle = reinterpret_cast<void*>(szlDataReaderCache); else delete szlDataReaderCache; ENSURE(VALID_ENUM(returnCode, TecioSZLFileOpenResult_e)); ENSURE(EQUIVALENCE(returnCode == TecioSZLFileOpenResult_OK, VALID_REF(*fileHandle))); return returnCode; } int32_t tecioSZL_GeomArrowheadGetAngle(void* fileHandle, int32_t ___1553, double* ___56) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(___56)); *___56 = szlDataReaderCache->geomArray[___1553 - 1].___2338; return 0; } int32_t tecioSZL_GeomArrowheadGetAttach(void* fileHandle, int32_t ___1553, int32_t* attachment) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(attachment)); *attachment = szlDataReaderCache->geomArray[___1553 - 1].___2339; return 0; } int32_t tecioSZL_GeomArrowheadGetSize(void* fileHandle, int32_t ___1553, double* arrowheadSize) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(arrowheadSize));
*arrowheadSize = szlDataReaderCache->geomArray[___1553 - 1].___2340; return 0; } int32_t tecioSZL_GeomArrowheadGetStyle(void* fileHandle, int32_t ___1553, int32_t* arrowheadStyle) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(arrowheadStyle)); *arrowheadStyle = szlDataReaderCache->geomArray[___1553 - 1].___2341; return 0; } int32_t tecioSZL_GeomCircleGetRadius(void* fileHandle, int32_t ___1553, double* radius) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(radius)); *radius = szlDataReaderCache->geomArray[___1553 - 1].___2462[0][0].x(); return 0; } int32_t tecioSZL_GeomEllipseGetNumPoints(void* fileHandle, int32_t ___1553, int32_t* numEllipsePoints) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(numEllipsePoints)); *numEllipsePoints = static_cast<int32_t>(szlDataReaderCache->geomArray[___1553 - 1].___2500); return 0; } int32_t tecioSZL_GeomEllipseGetSize(void* fileHandle, int32_t ___1553, double* horizontalAxis, double* verticalAxis) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(horizontalAxis)); REQUIRE(VALID_REF(verticalAxis)); *horizontalAxis = szlDataReaderCache->geomArray[___1553 - 1].___2462[0][0].x(); *verticalAxis = szlDataReaderCache->geomArray[___1553 - 1].___2462[0][0].___4581(); return 0; } int32_t tecioSZL_GeomGetAnchorPos(void* fileHandle, int32_t ___1553, double* x, double* ___4581, double* z) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(x)); REQUIRE(VALID_REF(___4581)); REQUIRE(VALID_REF(z)); *x = szlDataReaderCache->geomArray[___1553 - 1].___2615[0]; *___4581 = szlDataReaderCache->geomArray[___1553 - 1].___2615[1]; *z = szlDataReaderCache->geomArray[___1553 - 1].___2615[2]; return 0; } int32_t tecioSZL_GeomGetClipping(void* fileHandle, int32_t ___1553, int32_t* ___493) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(___493));
*___493 = szlDataReaderCache->geomArray[___1553 - 1].___2392; return 0; } int32_t tecioSZL_GeomGetColor(void* fileHandle, int32_t ___1553, int32_t* color) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(color)); *color = szlDataReaderCache->geomArray[___1553 - 1].___2393; return 0; } int32_t tecioSZL_GeomGetCoordMode(void* fileHandle, int32_t ___1553, int32_t* coordMode) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(coordMode)); *coordMode = szlDataReaderCache->geomArray[___1553 - 1].___2614; return 0; } int32_t tecioSZL_GeomGetFillColor(void* fileHandle, int32_t ___1553, int32_t* ___1409) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(___1409)); *___1409 = szlDataReaderCache->geomArray[___1553 - 1].___2460; return 0; } int32_t tecioSZL_GeomGetLinePattern(void* fileHandle, int32_t ___1553, int32_t* ___2261) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(___2261)); *___2261 = szlDataReaderCache->geomArray[___1553 - 1].___2487; return 0; } int32_t tecioSZL_GeomGetLineThickness(void* fileHandle, int32_t ___1553, double* ___2287) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(___2287)); *___2287 = szlDataReaderCache->geomArray[___1553 - 1].___2488; return 0; } int32_t tecioSZL_GeomGetMacroFunctionCmd(void* fileHandle, int32_t ___1553, char** macroFunctionCmd) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(macroFunctionCmd) && *macroFunctionCmd == NULL); if (!duplicateString(szlDataReaderCache->geomArray[___1553 - 1].___2489.c_str(), macroFunctionCmd)) return -1; return 0; } int32_t tecioSZL_GeomGetNumGeoms(void* fileHandle, int32_t* numGeoms) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(VALID_REF(numGeoms)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle);
*numGeoms = static_cast<int32_t>(szlDataReaderCache->geomArray.size()); return 0; } int32_t tecioSZL_GeomGetPatternLength(void* fileHandle, int32_t ___1553, double* ___2984) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(___2984)); *___2984 = szlDataReaderCache->geomArray[___1553 - 1].___2613; return 0; } int32_t tecioSZL_GeomGetScope(void* fileHandle, int32_t ___1553, int32_t* ___3440) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(___3440)); *___3440 = szlDataReaderCache->geomArray[___1553 - 1].___2617; return 0; } int32_t tecioSZL_GeomGetType(void* fileHandle, int32_t ___1553, int32_t* type) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(type)); *type = szlDataReaderCache->geomArray[___1553 - 1].___2464; return 0; } int32_t tecioSZL_GeomGetZone(void* fileHandle, int32_t ___1553, int32_t* zone) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(zone)); *zone = szlDataReaderCache->geomArray[___1553 - 1].___2675; return 0; } int32_t tecioSZL_GeomIsAttached(void* fileHandle, int32_t ___1553, int32_t* ___2002) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(___2002)); *___2002 = szlDataReaderCache->geomArray[___1553 - 1].___2482; return 0; } int32_t tecioSZL_GeomIsFilled(void* fileHandle, int32_t ___1553, int32_t* ___2020) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(___2020)); *___2020 = szlDataReaderCache->geomArray[___1553 - 1].___2484; return 0; } int32_t tecioSZL_GeomLineGetPoint(void* fileHandle, int32_t ___1553, int32_t segment, int32_t index, double* x, double* ___4581, double* z) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(0 < segment && segment <= static_cast<int32_t>(szlDataReaderCache->geomArray[___1553 - 1].___2462.size()));
REQUIRE(0 < index && index <= static_cast<int32_t>(szlDataReaderCache->geomArray[___1553 - 1].___2462[segment - 1].size())); REQUIRE(VALID_REF(x)); REQUIRE(VALID_REF(___4581)); REQUIRE(VALID_REF(z)); *x = static_cast<int32_t>(szlDataReaderCache->geomArray[___1553 - 1].___2462[segment - 1][index - 1].x()); *___4581 = static_cast<int32_t>(szlDataReaderCache->geomArray[___1553 - 1].___2462[segment - 1][index - 1].___4581()); *z = static_cast<int32_t>(szlDataReaderCache->geomArray[___1553 - 1].___2462[segment - 1][index - 1].z()); return 0; } int32_t tecioSZL_GeomLineGetSegmentCount(void* fileHandle, int32_t ___1553, int32_t* segmentCount) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(segmentCount)); *segmentCount = static_cast<int32_t>(szlDataReaderCache->geomArray[___1553 - 1].___2462.size()); return 0; } int32_t tecioSZL_GeomLineSegmentGetPointCount(void* fileHandle, int32_t ___1553, int32_t segment, int32_t* pointCount) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(0 < segment && segment <= static_cast<int32_t>(szlDataReaderCache->geomArray[___1553 - 1].___2462.size())); REQUIRE(VALID_REF(pointCount)); *pointCount = static_cast<int32_t>(szlDataReaderCache->geomArray[___1553 - 1].___2462[segment - 1].size()); return 0; } int32_t tecioSZL_GeomRectangleGetSize(void* fileHandle, int32_t ___1553, double* ___4456, double* ___1824) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(VALID_REF(___4456)); REQUIRE(VALID_REF(___1824)); *___4456 = szlDataReaderCache->geomArray[___1553 - 1].___2462[0][0].x(); *___1824 = szlDataReaderCache->geomArray[___1553 - 1].___2462[0][0].___4581(); return 0; } int32_t tecioSZL_GeomSquareGetSize(void* fileHandle, int32_t ___1553, double* size) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___1553 && ___1553 <= static_cast<int32_t>(szlDataReaderCache->geomArray.size())); REQUIRE(szlDataReaderCache->geomArray[___1553 - 1].___2464 == GeomType_Square); REQUIRE(VALID_REF(size)); *size = szlDataReaderCache->geomArray[___1553 - 1].___2462[0][0].x(); return 0; } int32_t tecioSZL_TextBoxGetColor(void* fileHandle, int32_t ___4040, int32_t* ___402) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(___402));
*___402 = szlDataReaderCache->textArray[___4040 - 1].___2626; return 0; } int32_t tecioSZL_TextBoxGetFillColor(void* fileHandle, int32_t ___4040, int32_t* ___404) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(___404)); *___404 = szlDataReaderCache->textArray[___4040 - 1].___2627; return 0; } int32_t tecioSZL_TextBoxGetLineThickness(void* fileHandle, int32_t ___4040, double* ___406) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(___406)); *___406 = szlDataReaderCache->textArray[___4040 - 1].___2628; return 0; } int32_t tecioSZL_TextBoxGetMargin(void* fileHandle, int32_t ___4040, double* ___408) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(___408)); *___408 = szlDataReaderCache->textArray[___4040 - 1].___2629; return 0; } int32_t tecioSZL_TextBoxGetType(void* fileHandle, int32_t ___4040, int32_t* ___410) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(___410)); *___410 = szlDataReaderCache->textArray[___4040 - 1].___2630; return 0; } int32_t tecioSZL_TextGetAnchor(void* fileHandle, int32_t ___4040, int32_t* ___38) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(___38)); *___38 = szlDataReaderCache->textArray[___4040 - 1].___2623; return 0; } int32_t tecioSZL_TextGetAnchorPos(void* fileHandle, int32_t ___4040, double* x, double* ___4581, double* z) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(x)); REQUIRE(VALID_REF(___4581)); REQUIRE(VALID_REF(z)); *x = szlDataReaderCache->textArray[___4040 - 1].___2624[0]; *___4581 = szlDataReaderCache->textArray[___4040 - 1].___2624[1]; *z = szlDataReaderCache->textArray[___4040 - 1].___2624[2]; return 0; } int32_t tecioSZL_TextGetAngle(void* fileHandle, int32_t ___4040, double* ___56) { REQUIRE(VALID_REF(fileHandle));
TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(___56)); *___56 = szlDataReaderCache->textArray[___4040 - 1].___2625; return 0; } int32_t tecioSZL_TextGetClipping(void* fileHandle, int32_t ___4040, int32_t* ___493) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(___493)); *___493 = szlDataReaderCache->textArray[___4040 - 1].___2631; return 0; } int32_t tecioSZL_TextGetColor(void* fileHandle, int32_t ___4040, int32_t* color) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(color)); *color = szlDataReaderCache->textArray[___4040 - 1].___2632; return 0; } int32_t tecioSZL_TextGetCoordMode(void* fileHandle, int32_t ___4040, int32_t* coordMode) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(coordMode)); *coordMode = szlDataReaderCache->textArray[___4040 - 1].___2637; return 0; } int32_t tecioSZL_TextGetHeight(void* fileHandle, int32_t ___4040, double* ___1824) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(___1824)); *___1824 = szlDataReaderCache->textArray[___4040 - 1].___2633; return 0; } int32_t tecioSZL_TextGetLineSpacing(void* fileHandle, int32_t ___4040, double* ___2285) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(___2285)); *___2285 = szlDataReaderCache->textArray[___4040 - 1].___2635; return 0; } int32_t tecioSZL_TextGetMacroFunctionCmd(void* fileHandle, int32_t ___4040, char** macroFunctionCmd) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(macroFunctionCmd) && *macroFunctionCmd == NULL); if (duplicateString(szlDataReaderCache->textArray[___4040 - 1].___2636.c_str(), macroFunctionCmd)) return 0; return -1; } int32_t tecioSZL_TextGetScope(void* fileHandle, int32_t ___4040, int32_t* ___3440)
{ REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(___3440)); *___3440 = static_cast<int32_t>(szlDataReaderCache->textArray[___4040 - 1].___2639); return 0; } int32_t tecioSZL_TextGetNumTexts(void* fileHandle, int32_t* numTexts) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(VALID_REF(numTexts)); *numTexts = static_cast<int32_t>(szlDataReaderCache->textArray.size()); return 0; } int32_t tecioSZL_TextGetSizeUnits(void* fileHandle, int32_t ___4040, int32_t* sizeUnits) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(sizeUnits)); *sizeUnits = szlDataReaderCache->textArray[___4040 - 1].___2640; return 0; } int32_t tecioSZL_TextGetString(void* fileHandle, int32_t ___4040, char** str) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(str) && *str == NULL); if (duplicateString(szlDataReaderCache->textArray[___4040 - 1].___2641.c_str(), str)) return 0; return 1; } int32_t tecioSZL_TextGetTypeface(void* fileHandle, int32_t ___4040, char** typeface) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(typeface) && *typeface == NULL); if (duplicateString(szlDataReaderCache->textArray[___4040 - 1].___2642.c_str(), typeface)) return 0; return 1; } int32_t tecioSZL_TextGetZone(void* fileHandle, int32_t ___4040, int32_t* zone) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(zone)); *zone = static_cast<int32_t>(szlDataReaderCache->textArray[___4040 - 1].___2645); return 0; } int32_t tecioSZL_TextIsAttached(void* fileHandle, int32_t ___4040, int32_t* ___2002) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(___2002)); *___2002 = (szlDataReaderCache->textArray[___4040 - 1].___2634 == ___4224 ? 1 : 0); return 0; } int32_t tecioSZL_TextIsBold(void* fileHandle, int32_t ___4040, int32_t* isBold)
{ REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(isBold)); *isBold = (szlDataReaderCache->textArray[___4040 - 1].___2643 == ___4224 ? 1 : 0); return 0; } int32_t tecioSZL_TextIsItalic(void* fileHandle, int32_t ___4040, int32_t* isItalic) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4040 && ___4040 <= static_cast<int32_t>(szlDataReaderCache->textArray.size())); REQUIRE(VALID_REF(isItalic)); *isItalic = (szlDataReaderCache->textArray[___4040 - 1].___2644 == ___4224 ? 1 : 0); return 0; } int32_t tecioSZL_VarAuxDataGetItem(void* fileHandle, int32_t ___4334, int32_t whichItem, char** ___2683, char** ___4312) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4334 && ___4334 <= szlDataReaderCache->___2841); REQUIRE(0 < whichItem && whichItem <= static_cast<int32_t>(szlDataReaderCache->varAuxData[___4334 - 1].size())); REQUIRE(VALID_REF(___2683) && *___2683 == NULL); REQUIRE(VALID_REF(___4312) && *___4312 == NULL); return duplicateAuxDataItem(szlDataReaderCache->varAuxData[___4334 - 1][whichItem - 1], ___2683, ___4312); } int32_t tecioSZL_VarAuxDataGetNumItems(void* fileHandle, int32_t ___4334, int32_t* ___2810) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4334 && ___4334 <= szlDataReaderCache->___2841); REQUIRE(VALID_REF(___2810)); *___2810 = static_cast<int32_t>(szlDataReaderCache->varAuxData[___4334 - 1].size()); return 0; } int32_t tecioSZL_VarGetName(void* fileHandle, int32_t ___4334, char** ___2683) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < ___4334 && ___4334 <= szlDataReaderCache->___2841); REQUIRE(VALID_REF(___2683) && *___2683 == NULL); return (duplicateString(szlDataReaderCache->___4704.m_varNames[___4334 - 1].c_str(), ___2683) ? 0 : -1); } int32_t tecioSZL_VarIsEnabled(void*  , int32_t /*___4334*/, int32_t* isEnabled) { *isEnabled = 1; return 0; } int32_t tecioSZL_ZoneAuxDataGetItem(void* fileHandle, int32_t zone, int32_t whichItem, char** ___2683, char** ___4312) { REQUIRE(VALID_REF(fileHandle)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); REQUIRE(0 < zone && zone <= szlDataReaderCache->___2844); REQUIRE(0 < whichItem && whichItem <= static_cast<int32_t>(szlDataReaderCache->zoneAuxData[zone - 1].size())); REQUIRE(VALID_REF(___2683) && *___2683 == NULL); REQUIRE(VALID_REF(___4312) && *___4312 == NULL); return duplicateAuxDataItem(szlDataReaderCache->zoneAuxData[zone - 1][whichItem - 1], ___2683, ___4312);
} int32_t tecioSZL_ZoneAuxDataGetNumItems(void* fileHandle, int32_t zone, int32_t* ___2810) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(___2810)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *___2810 = static_cast<int32_t>(szlDataReaderCache->zoneAuxData[zone - 1].size()); return 0; } int32_t tecioSZL_ZoneConnectivityGetSharedZone(void* fileHandle, int32_t zone, int32_t* sharedZone) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(sharedZone)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *sharedZone = static_cast<int32_t>(szlDataReaderCache->___4704.m_zoneShareConnectivityWithZone[zone - 1] + 1); return 0; } namespace { bool readZoneHeaderIfNecessary(TecioSzlDataReaderCache* szlDataReaderCache, int32_t zone) { REQUIRE(VALID_REF(szlDataReaderCache)); REQUIRE(zone >= 0); bool ___3356 = true; if (!szlDataReaderCache->zoneHeaderIsRead[zone]) { ___3943 ___3942; if (!szlDataReaderCache->szpltFile.___3457(szlDataReaderCache->___4627[zone]) || !readZoneHeaders(szlDataReaderCache->szpltFile, szlDataReaderCache->___1385, 0  , zone, 0  , szlDataReaderCache->___2841, szlDataReaderCache->___4704.m_vzMinMaxes, szlDataReaderCache->___4704.m_vzFieldDataTypes, szlDataReaderCache->zoneMetadata[zone])) { std::cerr << "File seek/read error while reading zone header." << std::endl; ___3356 = false; } else { szlDataReaderCache->zoneHeaderIsRead[zone] = 1; if (szlDataReaderCache->zoneMetadata[zone].isSZL()) ___3356 = szlDataReaderCache->zonePartitionHeaderIsRead[zone].alloc((uint64_t)szlDataReaderCache->zoneMetadata[zone].getNumPartitions(), (uint8_t)0); if (!___3356) std::cerr << "Out of memory while reading zone header." << std::endl; } } return ___3356; } bool readZonePartitionHeaderIfNecessary(TecioSzlDataReaderCache* szlDataReaderCache, int32_t zone, ___2088::___2978 ___2975) { REQUIRE(VALID_REF(szlDataReaderCache)); REQUIRE(zone >= 0); bool ___3356 = readZoneHeaderIfNecessary(szlDataReaderCache, zone); if (___3356 && szlDataReaderCache->zoneMetadata[zone].getNumPartitions() > 1 && !szlDataReaderCache->zonePartitionHeaderIsRead[zone][___2975]) { ZoneMetadata& zoneMetadata = szlDataReaderCache->zoneMetadata[zone]; if (!szlDataReaderCache->szpltFile.___3457(zoneMetadata.m_ptnHeaderFileLocs[___2975]) || !readPartitionHeader(szlDataReaderCache->szpltFile, szlDataReaderCache->___1385, szlDataReaderCache->___2841, 0, zone, ___2975, zoneMetadata, szlDataReaderCache->___4704.m_vzFieldDataTypes, zoneMetadata.m_ptnMetadata[___2975])) { std::cerr << "File seek/read error while reading partition header." << std::endl; ___3356 = false; } else { szlDataReaderCache->zonePartitionHeaderIsRead[zone][___2975] = 1; } } return ___3356; } int32_t incrementIndex(uint64_t& currentIndex, uint64_t numValues) { if (currentIndex < numValues - 1)
{ ++currentIndex; return 0; } else { std::cerr << "Wrong number of face neighbor values detected." << std::endl; return -1; } } } int32_t tecioSZL_ZoneFaceNbrGetConnections(void* fileHandle, int32_t zone, int32_t* connections) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(connections)); TecioSzlDataReaderCache* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache*>(fileHandle); int32_t ___3356 = readZoneHeaderIfNecessary(szlDataReaderCache, zone - 1) ? 0 : -1; if (___3356 == 0 && szlDataReaderCache->zoneMetadata[zone - 1].m_classicZoneFileLocations.___2661 != ___330) { uint64_t tempNumValues; ___1963 ___4297; if (!szlDataReaderCache->szpltFile.___3457(szlDataReaderCache->zoneMetadata[zone - 1].m_classicZoneFileLocations.___2661) || !readFaceNeighbors(szlDataReaderCache->szpltFile, zone - 1, tempNumValues, ___4297)) { std::cerr << "File seek/read error while reading face neighbors." << std::endl; ___3356 = -1; } else { FaceNeighborMode_e const ___2502 = szlDataReaderCache->zoneMetadata[zone - 1].getFaceNeighborMode(); bool const isOneToMany = (___2502 == ___1287 || ___2502 == ___1284); bool const isGlobal = (___2502 == ___1285 || ___2502 == ___1284); uint64_t currentIndex = 0; while (___3356 == 0 && currentIndex < tempNumValues) { int32_t numNeighbors = 1; connections[currentIndex] = ___4297[currentIndex] + 1; ___3356 = incrementIndex(currentIndex, tempNumValues); if (___3356 == 0) { connections[currentIndex] = ___4297[currentIndex] + 1; ___3356 = incrementIndex(currentIndex, tempNumValues); } if (___3356 == 0 && isOneToMany) { connections[currentIndex] = ___4297[currentIndex]; ___3356 = incrementIndex(currentIndex, tempNumValues); if (___3356 == 0) { numNeighbors = ___4297[currentIndex]; connections[currentIndex] = numNeighbors; ___3356 = incrementIndex(currentIndex, tempNumValues); } } for (int32_t i = 0; ___3356 == 0 && i < numNeighbors; ++i) { if (isGlobal) { connections[currentIndex] = ___4297[currentIndex] + 1; ___3356 = incrementIndex(currentIndex, tempNumValues); } if (___3356 == 0) { connections[currentIndex] = ___4297[currentIndex] + 1; if (i == numNeighbors - 1) ++currentIndex; else ___3356 = incrementIndex(currentIndex, tempNumValues); } } } } } return ___3356; } int32_t tecioSZL_ZoneFaceNbrGetConnections64(void* fileHandle, int32_t zone, int64_t* connections) { ___4276(fileHandle); ___4276(zone); ___4276(connections); ___476(!"Not implemented."); return 1; } int32_t tecioSZL_ZoneFaceNbrGetMode(void* fileHandle, int32_t zone, int32_t* ___2502) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(___2502)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *___2502 = static_cast<int32_t>(szlDataReaderCache->zoneMetadata[zone - 1].getFaceNeighborMode()); return 0; } namespace { template <typename T> bool countFaceConnections(int64_t numFaceValues, ___2238<T> const& faceValues, int32_t ___2502, int64_t* numConnections)
{ REQUIRE(numFaceValues >= 0); REQUIRE(VALID_REF(numConnections)); int64_t index = 0; T nz; while (index < numFaceValues) { ++(*numConnections); switch (___2502) { case 0: index += 3; break; case 1: nz = faceValues[index + 3]; if (nz <= 0) { std::cerr << "tecZoneFaceNbrGetNumConnections: Face neighbors in file are invalid (Invalid # face neighbors for connection " << *numConnections << ")." << std::endl; *numConnections = 0; return false; } index += (nz + 4); break; case 2: index += 4; break; case 3: nz = faceValues[index + 3]; if (nz <= 0) { std::cerr << "tecZoneFaceNbrGetNumConnections: Face neighbors in file are invalid (Invalid # face neighbors for connection " << *numConnections << ")." << std::endl; *numConnections = 0; return false; } index += (2 * nz + 4); break; default: std::cerr << "tecZoneFaceNbrGetNumConnections: Face neighbors in file are invalid (invalid face neighbor mode)." << std::endl; return false; } if (index > numFaceValues) { std::cerr << "tecZoneFaceNbrGetNumConnections: Face neighbors in file are invalid (Array bound violation while parsing face neighbors)." << std::endl; return false; } } return true; } } int32_t tecioSZL_ZoneFaceNbrGetNumConnections(void* fileHandle, int32_t zone, int64_t* numConnections) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(numConnections)); TecioSzlDataReaderCache* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache*>(fileHandle); *numConnections = 0; bool ___3356 = readZoneHeaderIfNecessary(szlDataReaderCache, zone - 1); if (___3356 && szlDataReaderCache->zoneMetadata[zone - 1].getZoneType() != ___4694 && szlDataReaderCache->zoneMetadata[zone - 1].m_classicZoneFileLocations.___2661 != ___330) { int32_t are64Bit; int32_t ___2502 = 0; ___3356 = (tecioSZL_ZoneFaceNbrsAre64Bit(fileHandle, zone, &are64Bit) == 0) && (tecioSZL_ZoneFaceNbrGetMode(fileHandle, zone, &___2502) == 0); if (___3356) { if (are64Bit) { ___3356 = false; } else { uint64_t numValues; ___2238<int32_t> ___4297; if (!szlDataReaderCache->szpltFile.___3457(szlDataReaderCache->zoneMetadata[zone - 1].m_classicZoneFileLocations.___2661) || !readFaceNeighbors(szlDataReaderCache->szpltFile, zone - 1, numValues, ___4297)) { std::cerr << "File seek/read error while reading face neighbors." << std::endl; return 0; } else { ___3356 = countFaceConnections(numValues, ___4297, ___2502, numConnections); } } } } ENSURE(IMPLICATION(___3356, *numConnections >= 0)); return ___3356 ? 0 : -1; } int32_t tecioSZL_ZoneFaceNbrGetNumValues(void* fileHandle, int32_t zone, int64_t* numValues) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(numValues)); TecioSzlDataReaderCache* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache*>(fileHandle); *numValues = 0; uint64_t tempNumValues; ___1963 ___4297; bool ___3356 = readZoneHeaderIfNecessary(szlDataReaderCache, zone - 1); if (___3356 && szlDataReaderCache->zoneMetadata[zone - 1].getZoneType() != ___4694 &&
szlDataReaderCache->zoneMetadata[zone - 1].m_classicZoneFileLocations.___2661 != ___330) { if (!szlDataReaderCache->szpltFile.___3457(szlDataReaderCache->zoneMetadata[zone - 1].m_classicZoneFileLocations.___2661) || !readFaceNeighbors(szlDataReaderCache->szpltFile, zone - 1, tempNumValues, ___4297)) { std::cerr << "File seek/read error while reading face neighbors." << std::endl; ___3356 = false; } else { ___476(tempNumValues < static_cast<uint64_t>(std::numeric_limits<int64_t>::max())); *numValues = static_cast<int64_t>(tempNumValues); } } ENSURE(IMPLICATION(___3356, *numValues >= 0)); return ___3356 ? 0 : -1; } int32_t tecioSZL_ZoneFaceNbrsAre64Bit(void* fileHandle, int32_t zone, int32_t* are64Bit) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(are64Bit)); ___4276(fileHandle); ___4276(zone); *are64Bit = 0; return 0; } int32_t tecioSZL_ZoneGetIJK(void* fileHandle, int32_t zone, int64_t* iMax, int64_t* jMax, int64_t* kMax) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(iMax)); REQUIRE(VALID_REF(jMax)); REQUIRE(VALID_REF(kMax)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); ___1842 ___1841 = szlDataReaderCache->zoneMetadata[zone - 1].getZoneIJK(); *iMax = static_cast<int64_t>(___1841.i()); *jMax = static_cast<int64_t>(___1841.___2103()); *kMax = static_cast<int64_t>(___1841.___2132()); return 0; } int32_t tecioSZL_ZoneGetParentZone(void* fileHandle, int32_t zone, int32_t* ___2972) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(___2972)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *___2972 = static_cast<int32_t>(szlDataReaderCache->zoneMetadata[zone - 1].getParentZone() + 1); return 0; } int32_t tecioSZL_ZoneGetSolutionTime(void* fileHandle, int32_t zone, double* ___3638) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(___3638)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *___3638 = szlDataReaderCache->zoneMetadata[zone - 1].getSolutionTime(); return 0; } int32_t tecioSZL_ZoneGetStrandID(void* fileHandle, int32_t zone, int32_t* ___3783) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(___3783)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *___3783 = static_cast<int32_t>(szlDataReaderCache->zoneMetadata[zone - 1].getStrandID()); return 0; } int32_t tecioSZL_ZoneGetTitle(void* fileHandle, int32_t zone, char** ___4175) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(___4175)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); if (!duplicateString(szlDataReaderCache->zoneMetadata[zone - 1].getName().c_str(), ___4175)) return -1; return 0; } int32_t tecioSZL_ZoneGetType(void* fileHandle, int32_t zone, int32_t* type)
{ REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(VALID_REF(type)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); boost::unordered_map<ZoneType_e, int32_t> tecioZoneTypes = boost::assign::map_list_of<ZoneType_e, int32_t> (___4702, 0) (___4700, 2) (___4698, 3) (___4699, 4) (___4693, 5) (___4694, 1) (___4696, 6) (___4697, 7); *type = tecioZoneTypes[szlDataReaderCache->zoneMetadata[zone - 1].getZoneType()]; return 0; } int32_t tecioSZL_ZoneIsEnabled(void* fileHandle, int32_t zone, int32_t* isEnabled) { ___4276(fileHandle); ___4276(zone); *isEnabled = 1; return 0; } namespace { uint64_t getNumValuesInSubzone(TecioSzlDataReaderCache const* szlDataReaderCache, ValueLocation_e ___4324, int32_t zone, ___2088::___2978 ___2975, ___2088::SubzoneOffset_t ___3878) { REQUIRE(VALID_REF(szlDataReaderCache)); REQUIRE(VALID_ENUM(___4324, ValueLocation_e)); REQUIRE(zone >= 0); uint64_t ___3356; if (szlDataReaderCache->zoneMetadata[zone].getZoneType() == ___4702) { if (___4324 == ___4328) ___3356 = szlDataReaderCache->zoneMetadata[zone].m_ijkZoneInfos[___2975].getNumNodesInNsz(___3878); else ___3356 = szlDataReaderCache->zoneMetadata[zone].m_ijkZoneInfos[___2975].getNumCellsInCsz(___3878); } else { uint64_t const valuesPerSubzone = static_cast<uint64_t>(szlDataReaderCache->___1385.___1754()); uint64_t numSubzones; uint64_t numValues; if (___4324 == ___4328) { numSubzones = static_cast<uint64_t>(szlDataReaderCache->zoneMetadata[zone].getNumNszsInPartition(___2975)); numValues = static_cast<uint64_t>(szlDataReaderCache->zoneMetadata[zone].m_ptnNumNodes[___2975]); } else { numSubzones = static_cast<uint64_t>(szlDataReaderCache->zoneMetadata[zone].getNumCszsInPartition(___2975)); numValues = static_cast<uint64_t>(szlDataReaderCache->zoneMetadata[zone].m_ptnNumCells[___2975]); } if (___3878 < numSubzones - 1) ___3356 = valuesPerSubzone; else ___3356 = numValues - (numSubzones - 1) * valuesPerSubzone; } return ___3356; } void getPartitionSubzoneAndOffset( TecioSzlDataReaderCache const* szlDataReaderCache, ValueLocation_e ___4324, int32_t zone, int64_t index, ___2088::___2978& ___2975, ___2088::SubzoneOffset_t& ___3878, uint64_t& itemOffset) { REQUIRE(VALID_REF(szlDataReaderCache)); REQUIRE(VALID_ENUM(___4324, ValueLocation_e)); REQUIRE(zone >= 0); ZoneMetadata const& zoneMetadata = szlDataReaderCache->zoneMetadata[zone]; for (___2975 = 0; ___2975 < zoneMetadata.getNumPartitions(); ++___2975) { if (___4324 == ___4328) { if (index < zoneMetadata.m_ptnFirstNode[___2975] + zoneMetadata.m_ptnNumNodes[___2975]) break; } else { if (index < zoneMetadata.m_ptnFirstCell[___2975] + zoneMetadata.m_ptnNumCells[___2975]) break; } } ___476(___2975 < zoneMetadata.getNumPartitions());
___2088::SubzoneOffset_t numSubzones; if (___4324 == ___4328) { itemOffset = static_cast<uint64_t>(index - zoneMetadata.m_ptnFirstNode[___2975]); numSubzones = zoneMetadata.m_ptnNumNszs[___2975]; } else { itemOffset = static_cast<uint64_t>(index - zoneMetadata.m_ptnFirstCell[___2975]); numSubzones = zoneMetadata.m_ptnNumCszs[___2975]; } ___476(numSubzones > 0); ___3878 = 0; while (___3878 < numSubzones) { uint64_t const valuesInSubzone = getNumValuesInSubzone(szlDataReaderCache, ___4324, zone, ___2975, ___3878); if (valuesInSubzone >= itemOffset) return; ++___3878; itemOffset -= valuesInSubzone; } ___476(___1303); } } int32_t tecioSZL_ZoneNodeMapGet(void* fileHandle, int32_t zone, int64_t startCell, int64_t ___2779, int32_t* ___2721) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(startCell > 0); REQUIRE(___2779 > 0); REQUIRE(VALID_REF(___2721)); TecioSzlDataReaderCache* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache*>(fileHandle); bool ___3356 = readZoneHeaderIfNecessary(szlDataReaderCache, zone - 1); ZoneType_e const ___4690 = szlDataReaderCache->zoneMetadata[zone - 1].getZoneType(); ___476(___4690 != ___4702); bool const ___2000 = (szlDataReaderCache->szpltFile.___2000() == ___4224); uint64_t const nodesPerCell = static_cast<uint64_t>(szlDataReaderCache->zoneMetadata[zone - 1].___1765()); if (___3356) { if (___4690 == ___4694 || ___4690 == ___4700 || ___4690 == ___4698) { uint64_t const sizeOfHeader = arraySizeInFile<int32_t, false  >(0, ___2000); uint64_t const bytesPerNumber = arrayValueSizeInFile<int32_t, false  >(___2000); uint64_t const fileLoc = szlDataReaderCache->zoneMetadata[zone - 1].m_classicZoneFileLocations.___2496 + ClassicFEZoneConnectivityWriter::nodeMapHeaderSizeInFile(___2000) + sizeOfHeader + (startCell - 1) * nodesPerCell * bytesPerNumber; uint64_t const valuesToRead = ___2779 * nodesPerCell; ___3356 = szlDataReaderCache->szpltFile.___3457(fileLoc) && readValues<int32_t, false, 0>(szlDataReaderCache->szpltFile, valuesToRead, ___2721, IODescription()); if (___3356) { for (uint64_t i = 0; i < ___2779 * nodesPerCell; ++i) ++___2721[i]; } } else { ___476(___4690 == ___4699 || ___4690 == ___4693); uint64_t const sizeOfHeader = SZLFEZoneWriter::cszConnectivityHeaderFileSize(___2000); uint64_t const valuesToRead = nodesPerCell * ___2779; uint64_t nodeMapIndex = 0; ZoneMetadata const& zoneMetadata = szlDataReaderCache->zoneMetadata[zone - 1]; ___2088::___2978 ___2975; ___2088::SubzoneOffset_t startingSubzone; uint64_t startingItemOffset; getPartitionSubzoneAndOffset(szlDataReaderCache, ___4326, zone - 1, startCell - 1, ___2975, startingSubzone, startingItemOffset); while (___3356 && nodeMapIndex < valuesToRead) { ___3356 = readZonePartitionHeaderIfNecessary(szlDataReaderCache, zone - 1, ___2975); PartitionMetadata const& partitionMetadata = zoneMetadata.m_ptnMetadata[___2975];
for (___2088::SubzoneOffset_t ___3878 = startingSubzone; ___3356 && nodeMapIndex < valuesToRead && ___3878 < zoneMetadata.getNumCszsInPartition(___2975); ++___3878) { CszConnectivity cszConnectivity; ___3356 = szlDataReaderCache->szpltFile.___3457(partitionMetadata.m_cszConnectivityFileLocs[___3878] + sizeOfHeader) && readCszConnectivity(szlDataReaderCache->szpltFile, szlDataReaderCache->___1385, zoneMetadata, ___2975, ___3878, cszConnectivity); for (CszConnectivity::EntryIndex_t entry = static_cast<CszConnectivity::EntryIndex_t>(nodesPerCell * startingItemOffset); ___3356 && nodeMapIndex < valuesToRead && entry < static_cast<CszConnectivity::EntryIndex_t>(cszConnectivity.getNumEntries()); ++entry) { ___2088 const nodeAddress = cszConnectivity.getNodeAddress(entry); int64_t nodeNumber = nodeAddress.itemOffset(); if (nodeAddress.___2975()) nodeNumber += zoneMetadata.m_ptnFirstNode[nodeAddress.___2975()]; if (nodeAddress.subzoneOffset()) nodeNumber += nodeAddress.subzoneOffset() * szlDataReaderCache->___1385.___1754(); ___2721[nodeMapIndex] = static_cast<int32_t>(nodeNumber + 1); ++nodeMapIndex; } startingItemOffset = 0; } ++___2975; } } } return (___3356 ? 0 : -1); } int32_t tecioSZL_ZoneNodeMapGet64(void* fileHandle, int32_t zone, int64_t startCell, int64_t ___2779, int64_t* ___2721) { ___4276(fileHandle); ___4276(zone); ___4276(startCell); ___4276(___2779); ___4276(___2721); ___476(!"Not implemented."); return 1; } int32_t tecioSZL_ZoneNodeMapIs64Bit(void* fileHandle, int32_t zone, int32_t* is64Bit) { ___4276(fileHandle); ___4276(zone); ___4276(is64Bit); ___476(!"Not implemented."); return 1; } namespace { int64_t skipCCGhostCells(___1842 const &cellIJKSize, ___1842 &cellIJKLocation) { int64_t numValuesToSkip = 0; if (cellIJKSize.i() > 1) { cellIJKLocation.setI(0); if (cellIJKLocation.___2103() < cellIJKSize.___2103() - 1) { cellIJKLocation.setJ(cellIJKLocation.___2103() + 1); numValuesToSkip = 1; } else { cellIJKLocation.setJ(0); cellIJKLocation.___3495(cellIJKLocation.___2132() + 1); if (cellIJKSize.___2103() > 1) { numValuesToSkip = cellIJKSize.i() + 2; } else { numValuesToSkip = 1; } } } else if (cellIJKSize.___2103() > 1) { cellIJKLocation.setJ(0); cellIJKLocation.___3495(cellIJKLocation.___2132() + 1); numValuesToSkip = 1; } return numValuesToSkip; } template <typename T> bool readSZLOrderedZoneVarValues(TecioSzlDataReaderCache* szlDataReaderCache, int32_t zone, int32_t ___4334, int64_t startIndex, int64_t numValues, T* values) { REQUIRE(VALID_REF(szlDataReaderCache)); REQUIRE(zone > 0); REQUIRE(___4334 > 0); REQUIRE(startIndex > 0); REQUIRE(numValues > 0); REQUIRE(VALID_REF(values)); bool ___2000 = (szlDataReaderCache->szpltFile.___2000() == ___4224); uint64_t const sizeOfEachSzHeader = arraySizeInFile<T, false   >(0, ___2000) + SZLOrderedZoneWriter::fieldDataSubzoneHeaderFileSize(___2000); uint64_t const bytesPerNumber = arrayValueSizeInFile<T, false  >(___2000); ZoneMetadata const& zoneMetadata = szlDataReaderCache->zoneMetadata[zone - 1]; ValueLocation_e const ___4324 = static_cast<ValueLocation_e>(szlDataReaderCache->___4704.m_vzValueLocations[___4334 - 1][zone - 1]);
___1842 ___4630 = zoneMetadata.getZoneIJK(); if (___4324 == ___4326) ___4630 = (___4630 - 1).maxOp(1); int64_t remainingValues = numValues; bool ___3356 = true; boost::scoped_array<T> subzoneValues(new T[szlDataReaderCache->___1385.___1755().blockSize()]); for (___2088::___2978 ___2975 = 0; ___3356 && remainingValues > 0 && ___2975 < zoneMetadata.getNumPartitions(); ++___2975) { int64_t partitionFirstIndex; int64_t partitionLastIndex; ___2088::SubzoneOffset_t numSubzones; if (___4324 == ___4326) { partitionFirstIndex = zoneMetadata.m_ptnFirstCell[___2975]; partitionLastIndex = partitionFirstIndex + zoneMetadata.m_ptnNumCells[___2975] - 1; numSubzones = zoneMetadata.getNumCszsInPartition(___2975); } else { partitionFirstIndex = zoneMetadata.m_ptnFirstNode[___2975]; partitionLastIndex = partitionFirstIndex + zoneMetadata.m_ptnNumNodes[___2975] - 1; numSubzones = zoneMetadata.getNumNszsInPartition(___2975); } if (partitionLastIndex < startIndex - 1 || partitionFirstIndex >= startIndex + numValues - 1) continue; ___3356 = readZonePartitionHeaderIfNecessary(szlDataReaderCache, zone - 1, ___2975); ___1842 partitionMinIJK(0, 0, 0); if (zoneMetadata.getNumPartitions() > 1) partitionMinIJK = zoneMetadata.m_ptnNodeMinIJKs[___2975]; uint64_t fileLoc = zoneMetadata.m_ptnMetadata[___2975].m_szDataStartFileLocs[___4334 - 1] + sizeOfEachSzHeader; for (___2088::SubzoneOffset_t ___3878 = 0; ___3356 && remainingValues > 0 && ___3878 < numSubzones; ++___3878) { ___1842 subzoneIJKStart; ___1842 subzoneIJKEnd; if (___4324 == ___4326) { subzoneIJKStart = zoneMetadata.m_ijkZoneInfos[___2975].___688(___3878) + partitionMinIJK; subzoneIJKEnd = zoneMetadata.m_ijkZoneInfos[___2975].___687(___3878) + partitionMinIJK; } else { subzoneIJKStart = zoneMetadata.m_ijkZoneInfos[___2975].___2759(___3878) + partitionMinIJK; subzoneIJKEnd = zoneMetadata.m_ijkZoneInfos[___2975].___2758(___3878) + partitionMinIJK; } ___1842 const subzoneIJKDim(subzoneIJKEnd - subzoneIJKStart + 1); int64_t const subzoneNumValues = subzoneIJKDim.blockSize(); int64_t const subzoneFirstIndex = ___4630.offsetAtIJK(subzoneIJKStart); int64_t const subzoneLastIndex = ___4630.offsetAtIJK(subzoneIJKEnd); if (subzoneLastIndex >= startIndex - 1 && subzoneFirstIndex < startIndex + numValues - 1) { if (szlDataReaderCache->szpltFile.___3457(fileLoc) && readValues<T, false, 0>(szlDataReaderCache->szpltFile, subzoneNumValues, subzoneValues.get(), IODescription())) { for (___2088::ItemOffset_t ___2083 = 0; ___2083 < subzoneNumValues; ++___2083) { int64_t const itemIndex = ___4630.offsetAtIJK(subzoneIJKStart + subzoneIJKDim.ijkAtOffset(___2083)); if (startIndex - 1 <= itemIndex && itemIndex < startIndex + numValues - 1) { values[itemIndex - startIndex + 1] = subzoneValues[___2083]; --remainingValues; } } } else { ___3356 = false; std::cerr << "Error reading value array." << std::endl; } } fileLoc += subzoneNumValues * bytesPerNumber + sizeOfEachSzHeader;
} } ENSURE(IMPLICATION(___3356, remainingValues == 0)); return ___3356; } template <typename T> bool readSZLFEZoneVarValues(TecioSzlDataReaderCache* szlDataReaderCache, int32_t zone, int32_t ___4334, int64_t startIndex, int64_t numValues, T* values) { REQUIRE(VALID_REF(szlDataReaderCache)); REQUIRE(zone > 0); REQUIRE(___4334 > 0); REQUIRE(startIndex > 0); REQUIRE(numValues > 0); REQUIRE(VALID_REF(values)); bool ___2000 = (szlDataReaderCache->szpltFile.___2000() == ___4224); uint64_t bytesPerNumber = arrayValueSizeInFile<T, false  >(___2000); ZoneMetadata const& zoneMetadata = szlDataReaderCache->zoneMetadata[zone - 1]; ValueLocation_e ___4324 = static_cast<ValueLocation_e>(szlDataReaderCache->___4704.m_vzValueLocations[___4334 - 1][zone - 1]); ___2088::___2978 ___2975; ___2088::SubzoneOffset_t startingSubzone; uint64_t itemOffset; getPartitionSubzoneAndOffset(szlDataReaderCache, ___4324, zone - 1, startIndex - 1, ___2975, startingSubzone, itemOffset); uint64_t destIndex = 0; uint64_t remainingValues = static_cast<uint64_t>(numValues); uint64_t valuesToSkip; if (___4324 == ___4328) valuesToSkip = startIndex - zoneMetadata.m_ptnFirstNode[___2975] - 1; else valuesToSkip = startIndex - zoneMetadata.m_ptnFirstCell[___2975] - 1; bool ___3356 = true; while (___3356 && remainingValues > 0) { ___3356 = readZonePartitionHeaderIfNecessary(szlDataReaderCache, zone - 1, ___2975); if (___3356) { if (___2000) { uint64_t const sizeOfEachSzHeader = arraySizeInFile<T, false  >(0, ___2000) + SZLFEZoneWriter::fieldDataSubzoneHeaderFileSize(___2000); uint64_t fileLoc = zoneMetadata.m_ptnMetadata[___2975].m_szDataStartFileLocs[___4334 - 1] + (startingSubzone + 1) * sizeOfEachSzHeader + valuesToSkip * bytesPerNumber; ___2088::SubzoneOffset_t const numSubzones = ___4324 == ___4328 ? zoneMetadata.getNumNszsInPartition(___2975) : zoneMetadata.getNumCszsInPartition(___2975); for (___2088::SubzoneOffset_t ___3878 = startingSubzone; ___3356 && remainingValues > 0 && ___3878 < numSubzones; ++___3878) { uint64_t const valuesInSubzone = getNumValuesInSubzone(szlDataReaderCache, ___4324, zone - 1, ___2975, ___3878); uint64_t const valuesToRead = std::min(remainingValues, valuesInSubzone - itemOffset); ___3356 = (szlDataReaderCache->szpltFile.___3457(fileLoc) == ___4224) && readValues<T, false, 0>(szlDataReaderCache->szpltFile, valuesToRead, &values[destIndex], IODescription()); destIndex += valuesToRead; remainingValues -= valuesToRead; fileLoc = szlDataReaderCache->szpltFile.fileLoc() + sizeOfEachSzHeader; itemOffset = 0; } } else { uint64_t fileLoc = zoneMetadata.m_ptnMetadata[___2975].m_szDataStartFileLocs[___4334 - 1] + valuesToSkip * bytesPerNumber; uint64_t valuesToRead; if (___4324 == ___4328) valuesToRead = std::min(remainingValues, zoneMetadata.m_ptnNumNodes[___2975] - valuesToSkip); else valuesToRead = std::min(remainingValues, zoneMetadata.m_ptnNumCells[___2975] - valuesToSkip);
___3356 = (szlDataReaderCache->szpltFile.___3457(fileLoc) == ___4224) && readValues<T, false, 0>(szlDataReaderCache->szpltFile, valuesToRead, &values[destIndex], IODescription()); destIndex += valuesToRead; remainingValues -= valuesToRead; } } ++___2975; valuesToSkip = 0; } return ___3356; } template <typename T> bool readClassicZoneVarValues(TecioSzlDataReaderCache* szlDataReaderCache, int32_t zone, int32_t ___4334, int64_t startIndex, bool ___3356, int64_t numValues, T* values) { REQUIRE(VALID_REF(szlDataReaderCache)); REQUIRE(zone > 0); REQUIRE(___4334 > 0); REQUIRE(startIndex > 0); REQUIRE(numValues > 0); REQUIRE(VALID_REF(values)); ZoneMetadata const& zoneMetadata = szlDataReaderCache->zoneMetadata[zone - 1]; ValueLocation_e ___4324 = static_cast<ValueLocation_e>(szlDataReaderCache->___4704.m_vzValueLocations[___4334 - 1][zone - 1]); bool ___2000 = (szlDataReaderCache->szpltFile.___2000() == ___4224); uint64_t bytesPerNumber = arrayValueSizeInFile<T, false  >(___2000); if (___4324 == ___4328 || zoneMetadata.getZoneType() != ___4702) { uint64_t const fileLoc = zoneMetadata.m_classicZoneFileLocations.___2671[___4334 - 1] + ClassicZoneVariableWriter::varHeaderSizeInFile(___2000) + arraySizeInFile<T, false  >(0 /* ___2795 */, ___2000) + (startIndex - 1) * bytesPerNumber; ___3356 = (szlDataReaderCache->szpltFile.___3457(fileLoc) == ___4224) && readValues<T, false, 0>(szlDataReaderCache->szpltFile, static_cast<uint64_t>(numValues), values, IODescription()); } else { ___1842 const nodeIJKSize = zoneMetadata.getZoneIJK(); ___1842 const cellIJKSize = (nodeIJKSize - 1).maxOp(1); ___1842 cellIJKLocation = cellIJKSize.ijkAtOffset(static_cast<___81>(startIndex - 1)); int64_t const adjustedStartingIndex = static_cast<int64_t>(nodeIJKSize.offsetAtIJK(cellIJKLocation)); uint64_t fileLoc = zoneMetadata.m_classicZoneFileLocations.___2671[___4334 - 1] + ClassicZoneVariableWriter::varHeaderSizeInFile(___2000) + arraySizeInFile<T, false  >(0 /* ___2795 */, ___2000) + adjustedStartingIndex * bytesPerNumber; uint64_t destIndex = 0; uint64_t remainingNumValues = static_cast<uint64_t>(numValues); while (___3356 && remainingNumValues > 0) { uint64_t valuesToRead; if (cellIJKSize.i() > 1) valuesToRead = std::min(remainingNumValues, static_cast<uint64_t>(cellIJKSize.i() - cellIJKLocation.i())); else if (cellIJKSize.___2103() > 1) valuesToRead = std::min(remainingNumValues, static_cast<uint64_t>(cellIJKSize.___2103() - cellIJKLocation.___2103())); else valuesToRead = std::min(remainingNumValues, static_cast<uint64_t>(cellIJKSize.___2132() - cellIJKLocation.___2132())); ___3356 = (szlDataReaderCache->szpltFile.___3457(fileLoc) == ___4224) && readValues<T, false, 0>(szlDataReaderCache->szpltFile, valuesToRead, &(values[destIndex]), IODescription()); remainingNumValues -= valuesToRead; destIndex += valuesToRead; uint64_t numValuesToSkip; numValuesToSkip = skipCCGhostCells(cellIJKSize, cellIJKLocation); ASSERT_ONLY(if (numValuesToSkip == 0) ___476(remainingNumValues == 0);)
fileLoc = szlDataReaderCache->szpltFile.fileLoc() + bytesPerNumber * numValuesToSkip; } } return ___3356; } template <typename T> bool readVarValues(TecioSzlDataReaderCache* szlDataReaderCache, int32_t zone, int32_t ___4334, int64_t startIndex, int64_t numValues, T* values) { REQUIRE(VALID_REF(szlDataReaderCache)); REQUIRE(zone > 0); REQUIRE(___4334 > 0); REQUIRE(startIndex > 0); REQUIRE(numValues > 0); REQUIRE(VALID_REF(values)); bool ___3356 = readZoneHeaderIfNecessary(szlDataReaderCache, zone - 1); if (___3356) { if (szlDataReaderCache->zoneMetadata[zone - 1].isSZL()) { if (szlDataReaderCache->zoneMetadata[zone - 1].getZoneType() == ___4702) ___3356 = readSZLOrderedZoneVarValues(szlDataReaderCache, zone, ___4334, startIndex, numValues, values); else ___3356 = readSZLFEZoneVarValues(szlDataReaderCache, zone, ___4334, startIndex, numValues, values); } else { ___3356 = readClassicZoneVarValues(szlDataReaderCache, zone, ___4334, startIndex, ___3356, numValues, values); } } return ___3356; } } int32_t tecioSZL_ZoneVarGetDoubleValues(void* fileHandle, int32_t zone, int32_t ___4334, int64_t startIndex, int64_t numValues, double* values) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4334 > 0); REQUIRE(startIndex > 0); REQUIRE(numValues > 0); REQUIRE(VALID_REF(values)); TecioSzlDataReaderCache* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache*>(fileHandle); if (!readVarValues(szlDataReaderCache, zone, ___4334, startIndex, numValues, values)) return -1; return 0; } int32_t tecioSZL_ZoneVarGetFloatValues(void* fileHandle, int32_t zone, int32_t ___4334, int64_t startIndex, int64_t numValues, float* values) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4334 > 0); REQUIRE(startIndex > 0); REQUIRE(numValues > 0); REQUIRE(VALID_REF(values)); TecioSzlDataReaderCache* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache*>(fileHandle); if (!readVarValues(szlDataReaderCache, zone, ___4334, startIndex, numValues, values)) return -1; return 0; } int32_t tecioSZL_ZoneVarGetInt16Values(void* fileHandle, int32_t zone, int32_t ___4334, int64_t startIndex, int64_t numValues, int16_t* values) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4334 > 0); REQUIRE(startIndex > 0); REQUIRE(numValues > 0); REQUIRE(VALID_REF(values)); TecioSzlDataReaderCache* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache*>(fileHandle); if (!readVarValues(szlDataReaderCache, zone, ___4334, startIndex, numValues, values)) return -1; return 0; } int32_t tecioSZL_ZoneVarGetInt32Values(void* fileHandle, int32_t zone, int32_t ___4334, int64_t startIndex, int64_t numValues, int32_t* values) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4334 > 0); REQUIRE(startIndex > 0); REQUIRE(numValues > 0); REQUIRE(VALID_REF(values)); TecioSzlDataReaderCache* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache*>(fileHandle); if (!readVarValues(szlDataReaderCache, zone, ___4334, startIndex, numValues, values)) return -1; return 0; } int32_t tecioSZL_ZoneVarGetSharedZone(void* fileHandle, int32_t zone, int32_t ___4334, int32_t* sharedZone)
{ REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4334 > 0); REQUIRE(VALID_REF(sharedZone)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *sharedZone = static_cast<int32_t>(szlDataReaderCache->___4704.m_vzShareVarWithZone[___4334 - 1][zone - 1] + 1); return 0; } int32_t tecioSZL_ZoneVarGetType(void* fileHandle, int32_t zone, int32_t ___4334, int32_t* type) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4334 > 0); REQUIRE(VALID_REF(type)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *type = static_cast<int32_t>(szlDataReaderCache->___4704.m_vzFieldDataTypes[___4334 - 1][zone - 1]); return 0; } int32_t tecioSZL_ZoneVarGetUInt8Values(void* fileHandle, int32_t zone, int32_t ___4334, int64_t startIndex, int64_t numValues, uint8_t* values) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4334 > 0); REQUIRE(startIndex > 0); REQUIRE(numValues > 0); REQUIRE(VALID_REF(values)); TecioSzlDataReaderCache* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache*>(fileHandle); if (!readVarValues(szlDataReaderCache, zone, ___4334, startIndex, numValues, values)) return -1; return 0; } int32_t tecioSZL_ZoneVarGetValueLocation(void* fileHandle, int32_t zone, int32_t ___4334, int32_t* location) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4334 > 0); REQUIRE(VALID_REF(location)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *location = static_cast<int32_t>(szlDataReaderCache->___4704.m_vzValueLocations[___4334 - 1][zone - 1]); return 0; } int32_t tecioSZL_ZoneVarIsPassive(void* fileHandle, int32_t zone, int32_t ___4334, int32_t* isPassive) { REQUIRE(VALID_REF(fileHandle)); REQUIRE(zone > 0); REQUIRE(___4334 > 0); REQUIRE(VALID_REF(isPassive)); TecioSzlDataReaderCache const* szlDataReaderCache = reinterpret_cast<TecioSzlDataReaderCache const*>(fileHandle); *isPassive = static_cast<int32_t>(szlDataReaderCache->___4704.m_vzIsPassive[___4334 - 1][zone - 1]); return 0; } }}
