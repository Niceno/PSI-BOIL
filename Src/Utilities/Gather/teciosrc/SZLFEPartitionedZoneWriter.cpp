#include "SZLFEPartitionedZoneWriter.h"
#include "ThirdPartyHeadersBegin.h"
#include <boost/assign.hpp>
#include <boost/make_shared.hpp>
#include <boost/ref.hpp>
#include <boost/scoped_ptr.hpp>
#include <new>
#include <set>
#include "ThirdPartyHeadersEnd.h"
#include "FEZoneInfo.h"
#include "FieldData.h"
#include "ItemSetIterator.h"
#include "SZLFEPartitionWriter.h"
#include "writeValueArray.h"
#include "ZoneInfoCache.h"
namespace tecplot { namespace ___3931 { SZLFEPartitionedZoneWriter::SZLFEPartitionedZoneWriter( ItemSetIterator&              varIter, ___4634                   zone, ___4634                   ___341, std::vector<___372> const& ___4562, ___372                     ___4497, ___37&                   ___36, ZoneInfoCache&                zoneInfoCache) : ___4707(varIter, zone, ___341, ___4562, ___4497, ___36) , m_headerWriter( varIter, zone, ___341, ___36, m_partitionFileNums, m_partitionHeaderFilePositions, m_partitionNumCells, m_partitionNumNodes, m_varPartitionMinMaxes) , ___2678(zoneInfoCache) , m_partitionTecUtil(___36, zone + 1) { REQUIRE(0 <= zone && ___36.___4636(zone + 1)); REQUIRE(VALID_BOOLEAN(___4497)); REQUIRE(___36.zoneIsPartitioned(zone + 1)); size_t const numVarsToWrite = static_cast<size_t>(m_varIter.___2810()); size_t const numPartitions = static_cast<size_t>(___36.zoneGetNumPartitions(zone + 1)); if (!m_partitionFileNums.alloc(numPartitions, 0) || !m_partitionHeaderFilePositions.alloc(numPartitions, ___330) || !m_partitionNumCells.alloc(numPartitions, 0) || !m_partitionNumNodes.alloc(numPartitions, 0) || !___3354(m_varPartitionMinMaxes, numVarsToWrite, numPartitions)) throw std::bad_alloc(); } SZLFEPartitionedZoneWriter::~SZLFEPartitionedZoneWriter() {} namespace { bool gatherConnectedCellInfoForNode( boost::unordered_set<___2088::SubzoneOffset_t>& cellSubzones, std::vector<___2477>&                                varMinMaxes, int64_t                                             ___2707, ___2722 const&                                      ___2721, PartitionTecUtilDecorator const&                    partitionTecUtil, std::vector<___1350> const&                       fieldDatas, ___1348 const&                                   zoneInfo, boost::unordered_set<int64_t> const&                ghostCellSet) { REQUIRE(cellSubzones.empty()); REQUIRE(varMinMaxes.size() == fieldDatas.size()); REQUIRE(0 < ___2707); REQUIRE(___2721.___2065()); REQUIRE(IMPLICATION(fieldDatas[0].___2065(), fieldDatas[0].___1784() == ___4328)); REQUIRE(IMPLICATION(fieldDatas.back().___2065(), fieldDatas.back().___1784() == ___4328)); bool foundConnectedNonGhostCell = false; ___2740 nodeToElemMap = partitionTecUtil.dataNodeToElemMapGetReadableRef(zoneInfo.getPartition() + 1); for(___463 elemIndex = 1; elemIndex <= partitionTecUtil.dataNodeToElemMapGetNumElems(nodeToElemMap, ___2707); ++elemIndex) { ___463 ___447 = partitionTecUtil.dataNodeToElemMapGetElem(nodeToElemMap, ___2707, elemIndex); if (ghostCellSet.find(___447) != ghostCellSet.end()) continue; foundConnectedNonGhostCell = true; ___2088 szCoordinate = zoneInfo.szCoordinateAtZoneCell(___447 - 1); cellSubzones.insert(szCoordinate.subzoneOffset()); for(int32_t ___679 = 1; ___679 <= ___2721.___1762(); ++___679) {
int64_t cornerNode = ___2721.___1761(___447, ___679); for(size_t i = 0; i < varMinMaxes.size(); ++i) { if (fieldDatas[i].___2065()) { double ___4296 = fieldDatas[i].___1778(cornerNode); varMinMaxes[i].include(___4296); } else { varMinMaxes[i].include(0.0); } } } } return foundConnectedNonGhostCell; } } void SZLFEPartitionedZoneWriter::gatherNeighborCellSubzoneInfo( NeighborCellSubzoneInfoMap& neighborCellSubzoneInfoMap, ___2088::___2978 ___2975, ___4350 ___2841, ___2722& ___2721, std::vector<___1350> const& fieldDatas, ___1348 const& zoneInfo) { boost::unordered_set<int64_t> ghostCellSet; GhostInfo_pa partitionGhostCellInfo = ___2335.zonePartitionGhostCellInfoGetRef(___2675 + 1, ___2975 + 1); for(___81 itemNum = 1; itemNum <= ___2335.ghostInfoGetNumItemsByRef(partitionGhostCellInfo); ++itemNum) { ___81 ___447 = ___2335.ghostInfoGetItemByRef(partitionGhostCellInfo, itemNum); ghostCellSet.insert(static_cast<int32_t>(___447)); } GhostInfo_pa partitionGhostNodeInfo = ___2335.zonePartitionGhostNodeInfoGetRef(___2675 + 1, ___2975 + 1); for(___81 itemNum = 1; itemNum <= ___2335.ghostInfoGetNumItemsByRef(partitionGhostNodeInfo); ++itemNum) { ___81 ___2707 = ___2335.ghostInfoGetItemByRef(partitionGhostNodeInfo, itemNum); ___2088::___2978 neighbor = ___2335.ghostInfoGetNeighborByRef(partitionGhostNodeInfo, itemNum); ___81 neighborNode = ___2335.ghostInfoGetNeighborItemByRef(partitionGhostNodeInfo, itemNum); boost::unordered_set<___2088::SubzoneOffset_t> cellSubzones; std::vector<___2477> varMinMaxes(___2841); if (gatherConnectedCellInfoForNode(cellSubzones, varMinMaxes, ___2707, ___2721, m_partitionTecUtil, fieldDatas, zoneInfo, ghostCellSet)) { NeighborCellSubzoneInfo& neighborCellSubzoneInfo = neighborCellSubzoneInfoMap[neighbor - 1]; neighborCellSubzoneInfo.m_nodes.push_back(___2707 - 1); neighborCellSubzoneInfo.m_neighborNodes.push_back(neighborNode - 1); neighborCellSubzoneInfo.m_cellSubzones.push_back(cellSubzones); neighborCellSubzoneInfo.m_varMinMaxes.push_back(varMinMaxes); } } } void SZLFEPartitionedZoneWriter::exchangeGhostInfo(std::vector<boost::shared_ptr<___1348> >& partitionInfos) { PartitionTecUtilDecorator partitionTecUtilDecorator(___2335, ___2675 + 1); ___4350 const numVarsToWrite = m_varIter.___2810(); ___2088::___2978 const numPartitions = static_cast<___2088::___2978>(___2335.zoneGetNumPartitions(___2675 + 1)); for(___2088::___2978 ___2975 = 0; ___2975 < numPartitions; ++___2975) { ___2722 ___2721(&partitionTecUtilDecorator, ___2975 + 1); std::vector<___1350> fieldDatas(numVarsToWrite); m_varIter.reset(); ___4350 const baseVar = m_varIter.baseItem(); while (m_varIter.hasNext()) { ___4350 const datasetVar = m_varIter.next(); ___4350 const fileVar = datasetVar - baseVar; if (___2335.___4351(datasetVar + 1) && !___2335.___924(___2675 + 1, datasetVar + 1)) { if (___2335.___908(___2675 + 1, datasetVar + 1) == ___4328)
fieldDatas[fileVar] = ___1350(&partitionTecUtilDecorator, ___2975 + 1, datasetVar + 1, false, false); else fieldDatas[fileVar] = ___1350(&partitionTecUtilDecorator, ___2975 + 1, datasetVar + 1, false, true); } } NeighborCellSubzoneInfoMap neighborCellSubzoneInfoMap; gatherNeighborCellSubzoneInfo(neighborCellSubzoneInfoMap, ___2975, numVarsToWrite, ___2721, fieldDatas, *(partitionInfos[___2975])); std::set<___2088::___2978> referencedPartitions; for(___2088::___2978 i = 0; i < partitionInfos[___2975]->getNumReferencedPartitions(); ++i) referencedPartitions.insert(partitionInfos[___2975]->getReferencedPartitions()[i]); for (NeighborCellSubzoneInfoMap::iterator valuePair = neighborCellSubzoneInfoMap.begin(); valuePair != neighborCellSubzoneInfoMap.end(); ++valuePair) { ___2088::___2978 const neighbor = valuePair->first; NeighborCellSubzoneInfo const& neighborCellSubzoneInfo = valuePair->second; referencedPartitions.insert(neighbor); partitionInfos[neighbor]->addNeighborCszInfo(___2975, neighborCellSubzoneInfo.m_neighborNodes, neighborCellSubzoneInfo.m_cellSubzones, neighborCellSubzoneInfo.m_varMinMaxes); for(size_t i = 0; i < neighborCellSubzoneInfo.m_nodes.size(); ++i) { ___2088 szCoordinate = partitionInfos[neighbor]->___3922(neighborCellSubzoneInfo.m_neighborNodes[i]); partitionInfos[___2975]->addNeighborNodeCoordinate(neighborCellSubzoneInfo.m_nodes[i], szCoordinate); } } if (!referencedPartitions.empty()) partitionInfos[___2975]->addReferencedPartitions(referencedPartitions); } } void SZLFEPartitionedZoneWriter::createPartitionWriters() { std::vector<boost::shared_ptr<___1348> > partitionInfos; for(___4634 ___2975 = 0; ___2975 < ___2335.zoneGetNumPartitions(___2675 + 1); ++___2975) { partitionInfos.push_back(___2678.getFEZonePartitionInfo(___2675, ___2975, m_partitionTecUtil)); m_partitionNumCells[___2975] = static_cast<uint32_t>(partitionInfos[___2975]->___1764() - partitionInfos[___2975]->getNumGhostCells()); m_partitionNumNodes[___2975] = static_cast<uint32_t>(partitionInfos[___2975]->___1766() - partitionInfos[___2975]->getNumGhostNodes()); } exchangeGhostInfo(partitionInfos); for(___4634 ___2975 = 0; ___2975 < ___2335.zoneGetNumPartitions(___2675 + 1); ++___2975) { m_partitionWriters[___2975] = boost::make_shared<SZLFEPartitionWriter> ( boost::ref(m_varIter), ___2675, m_baseZone, ___2975, boost::ref(m_writeVariables), m_writeConnectivity, boost::ref(m_partitionTecUtil), partitionInfos[___2975]); } } ___372 SZLFEPartitionedZoneWriter::writeZoneData(FileWriterInterface& szpltFile) { if (m_partitionWriters.empty()) createPartitionWriters(); for(___4634 ___2975 = 0; ___2975 < ___2335.zoneGetNumPartitions(___2675 + 1); ++___2975) { m_partitionWriters[___2975]->writeZone(szpltFile, szpltFile.fileLoc()); m_partitionHeaderFilePositions[___2975] = m_partitionWriters[___2975]->getZoneHeaderFilePosition();
m_varIter.reset(); ___4350 const baseVar = m_varIter.baseItem(); while (m_varIter.hasNext()) { ___4350 const datasetVar = m_varIter.next(); ___4350 const fileVar = datasetVar - baseVar; m_varPartitionMinMaxes[fileVar][___2975] = m_partitionWriters[___2975]->varMinMax(datasetVar); } } return ___4224; } uint64_t SZLFEPartitionedZoneWriter::zoneDataFileSize(bool ___2000) { if (m_partitionWriters.empty()) createPartitionWriters(); uint64_t ___3356 = 0; for(___4634 ___2975 = 0; ___2975 < ___2335.zoneGetNumPartitions(___2675 + 1); ++___2975) ___3356 += m_partitionWriters[___2975]->zoneFileSize(___2000); return ___3356; } ___372 SZLFEPartitionedZoneWriter::writeZoneConnectivity(FileWriterInterface&  ) { return ___4224; } uint64_t SZLFEPartitionedZoneWriter::zoneConnectivityFileSize(bool  ) { return 0; } ___372 SZLFEPartitionedZoneWriter::writeZoneHeader(FileWriterInterface& szpltFile) { REQUIRE(szpltFile.___2039()); return m_headerWriter.write(szpltFile); } uint64_t SZLFEPartitionedZoneWriter::zoneHeaderFileSize(bool ___2000) { return m_headerWriter.sizeInFile(___2000); } }}
