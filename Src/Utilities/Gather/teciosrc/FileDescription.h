 #pragma once
#include "ThirdPartyHeadersBegin.h"
#  include <string>
#include "ThirdPartyHeadersEnd.h"
#include "IJK.h"
#include "fileStuff.h"
#include "SzlFileLoader.h"
namespace tecplot { namespace ___3931 { class ___1386 { public: static inline bool validIsAscii(___372 ___2000) { return VALID_BOOLEAN(___2000); }; static inline bool validDataFileType(DataFileType_e ___842) { return VALID_ENUM(___842, DataFileType_e); } static inline bool validIJKSubzoneSize(___1842 const& ijkSubzoneSize) { return ijkSubzoneSize.___2065() && ijkSubzoneSize.blockSize()<=___2088::MAX_ITEM_OFFSET+1; }; static inline bool validFESubzoneSize(___2088::ItemOffset_t feSubzoneSize) { return feSubzoneSize>0 && feSubzoneSize<=___2088::MAX_ITEM_OFFSET+1; }; static inline bool validFileVersion(uint32_t fileVersion) { return fileVersion >= SZPLT_MIN_READ_VERSION; } private: ___372                 m_isAscii; DataFileType_e            m_dataFileType; ___1842                       m_maxIJKSubzoneSize; ___2088::ItemOffset_t m_maxFESubzoneSize; uint32_t                  m_fileVersion; uint32_t                  m_codeRevision; public: ___1386() { invalidate(); } ___1386( ___372 const                 ___2000, DataFileType_e                  ___842, ___1842 const&                      ijkSubzoneSize, ___2088::ItemOffset_t const feSubzoneSize) { invalidate(); ___3492(___2000); setDataFileType(___842); setMaxIJKSubzoneSize(ijkSubzoneSize); setMaxFESubzoneSize(feSubzoneSize); setFileVersion(SZPLT_CUR_WRITE_VERSION); } inline void invalidate(void) { m_isAscii = ___372(-1); m_dataFileType = ___845; m_maxIJKSubzoneSize.invalidate(); m_maxFESubzoneSize = ___2088::INVALID_ITEM_OFFSET; m_fileVersion = 0; m_codeRevision = 0; }
 #if 0
inline bool operator ==(___1386 const& ___1306) const { return ___2000() == ___1306.___2000() && ___842() == ___1306.m_dataFileType() && ___1755() == ___1306.___1755() && ___1754() == ___1306.___1754() && getFileVersion() == ___1306.getFileVersion() && getRevision() == ___1306.getRevision(); } inline bool operator !=(___1386 const& ___1306) const { return !(*this == ___1306); }
 #endif
inline void ___3492(___372 ___2000) { REQUIRE(validIsAscii(___2000)); m_isAscii = ___2000; } inline void setDataFileType(DataFileType_e ___842) { REQUIRE(validDataFileType(___842)); m_dataFileType = ___842; } inline void setMaxIJKSubzoneSize(___1842 const& maxIJKSubzoneSize) { REQUIRE(validIJKSubzoneSize(maxIJKSubzoneSize)); m_maxIJKSubzoneSize = maxIJKSubzoneSize; } inline void setMaxFESubzoneSize(___2088::ItemOffset_t maxFESubzoneSize) { REQUIRE(validFESubzoneSize(maxFESubzoneSize)); m_maxFESubzoneSize = maxFESubzoneSize; } inline void setFileVersion(uint32_t fileVersion) { m_fileVersion = fileVersion; } inline void setCodeRevision(uint32_t codeRevision) { m_codeRevision = codeRevision; } inline ___372 ___2000() const { ENSURE(VALID_BOOLEAN(m_isAscii)); return m_isAscii; } inline DataFileType_e ___842() const { ENSURE(VALID_ENUM(m_dataFileType, DataFileType_e)); return m_dataFileType; } inline ___1842 const& ___1755() const { ENSURE(validIJKSubzoneSize(m_maxIJKSubzoneSize)); return m_maxIJKSubzoneSize; } inline ___2088::ItemOffset_t ___1754() const { ENSURE(validFESubzoneSize(m_maxFESubzoneSize)); return m_maxFESubzoneSize; } inline uint32_t getFileVersion() const { ENSURE(validFileVersion(m_fileVersion)); return m_fileVersion; } inline uint32_t getCodeRevision() const { return m_codeRevision; } }; }}
