#include "SZLFEZoneWriter.h"
#include "ThirdPartyHeadersBegin.h"
#include <boost/assign.hpp>
#include <boost/bind/bind.hpp>
#include <boost/function.hpp>
#include <boost/make_shared.hpp>
#include <boost/unordered_set.hpp>
#include "ThirdPartyHeadersEnd.h"
 #if !defined TECIOMPI
#include "AtomicMinMax.h"
 #endif
#include "checkPercentDone.h"
#include "FECellSubzoneCompressor.h"
#include "FieldData.h"
#include "gatherOffsets.h"
#include "IJKZoneInfo.h"
#include "ItemSetIterator.h"
#include "NodeMap.h"
#include "writeValueArray.h"
 #define MINMAX_MAX_TASKS_PER_CORE 2 
 #define MINMAX_MIN_CSZ_TASK_SIZE 16 
 #define MINMAX_MIN_NODE_TASK_SIZE 16 
 #define FEWRITER_MIN_CSZS_PER_CHUNK 1000 
 #define FEWRITER_MAX_CSZS_PER_CHUNK 1000 
namespace tecplot { namespace ___3931 { SZLFEZoneWriter::SZLFEZoneWriter( ItemSetIterator&                           varIter, ___4634                                zone, ___4634                                ___341, std::vector<___372> const&              ___4562, ___372                                  ___4497, ___37&                                ___36, boost::shared_ptr<___1348 const> const& zoneInfo) : ___4707(varIter, zone, ___341, ___4562, ___4497, ___36) , m_headerWriter(varIter, zone, ___341, ___36, *zoneInfo, (___4497 == ___4224), ___2671, m_cszConnectivityFileLocs, m_nszConnectivityFileLocs, m_numRefNodeSubzones, m_numRefCellSubzones, m_cszIncludesPartitionOffsetsBitArray, m_nszIncludesPartitionOffsetsBitArray) , m_feZoneInfo(zoneInfo) , m_zoneNumberLabel(SZPLT_ZONE_NUM_DESCRIPTION) { ___4350 const numVarsToWrite = m_varIter.___2810(); if (!___2671.alloc(numVarsToWrite, ___330)) { std::ostringstream ___2890; ___2890 << "Unable to allocate arrays for outputting zone " << zone; throw std::runtime_error(___2890.str()); } } SZLFEZoneWriter::~SZLFEZoneWriter() {} void SZLFEZoneWriter::setZoneNumberLabel(std::string const& zoneNumberLabel) { REQUIRE(!zoneNumberLabel.empty()); m_zoneNumberLabel = zoneNumberLabel; } namespace { void calculateAndApplyCellMinMaxes( ___2088::SubzoneOffset_t              cellSubzoneStart, ___2088::SubzoneOffset_t              cellSubzoneEnd, ___1348 const&                         ___1347, ___2722 const&                            ___2721, ___1350 const&                          nlFieldData, ___1350 const&                          ccFieldData,
 #if defined TECIOMPI
___2479&                          cszMinMaxArray, ___2479&                          ___2760)
 #else
___2238<___225<double> >& cszMinMaxArray, ___2238<___225<double> >& ___2760)
 #endif
{ REQUIRE(___2721.___2065()); REQUIRE(nlFieldData.___2065()); ___680 const ___2787 = static_cast<___680>(___2721.___1762()); ___476(___2787 <= MAX_NUM_CELL_CORNERS); for (___2088::SubzoneOffset_t ___467 = cellSubzoneStart; ___467 < cellSubzoneEnd; ++___467) { ___2088::ItemOffset_t const ___2780 = ___1347.___2780(___467); for (___2088::ItemOffset_t cszOffset = 0; cszOffset < ___2780; cszOffset++) { ___2088 ___686(___2088::UNKNOWN_PARTITION, ___467, cszOffset); ___463 const zoneCell = ___1347.___4606(___686); ___2716 zoneNodeAtCorner[MAX_NUM_CELL_CORNERS]; ___2477 cellMinMax; for (___680 ___679 = 0; ___679 < ___2787; ++___679) { ___2716 const ___4654 = ___2721.___1761(zoneCell + 1, ___679 + 1) - 1; zoneNodeAtCorner[___679] = ___4654; cellMinMax.include(nlFieldData.___1778(___4654 + 1)); } for (___680 ___679 = 0; ___679 < ___2787; ++___679) { ___2088 const ___2757 = ___1347.___3922(zoneNodeAtCorner[___679]); ___2088::___2978 const ___2975 = ___2757.___2975(); if (___2975 == ___1347.getPartition()) { ___2088::SubzoneOffset_t const ___2732 = ___2757.subzoneOffset(); ___2760[___2732].include(cellMinMax); } } if ( ccFieldData.___2065() ) cellMinMax.include(ccFieldData.___1778(zoneCell + 1)); cszMinMaxArray[___467].include(cellMinMax); } } } } namespace {
 #if !defined TECIOMPI
void applyNodalValuesToNodeSubzoneMinMaxes( ___2716 nodeStart, ___2716 nodeEnd, ___1350 const& ___1349, ___1348 const& ___1347, boost::unordered_set<___2716> const& ghostNodeSet,
 #if defined TECIOMPI
___2479& ___2760)
 #else
___2238<___225<double> >& ___2760)
 #endif
{ REQUIRE(___1349.___2065()); for (___2716 ___4654 = nodeStart; ___4654 < nodeEnd; ++___4654) { if (ghostNodeSet.find(___4654) == ghostNodeSet.end()) { double const ___4296 = ___1349.___1778(___4654 + 1); ___2088 const ___2757 = ___1347.___3922(___4654); ___476 (___2757.___2975() == ___1347.getPartition()); ___2088::SubzoneOffset_t const ___2755 = ___2757.subzoneOffset(); ___2760[___2755].include(___4296); } } } typedef boost::function<void(void)> VoidFunction; void threadPoolJob(___90 ___2121) { VoidFunction* voidFunction = reinterpret_cast<VoidFunction*>(___2121); (*voidFunction)(); delete voidFunction; } ___372 calculateAndApplyCellMinMaxesMultithreaded( ___37 &___36, ___1348 const& ___1347, ___4634 zone, ___2722& ___2721, ___1350 const& nlFieldData, ___1350 const& ccFieldData, ___2479 &cszMinMaxArray, ___2479 &___2760) { ___2238<___225<double> > atomicCszMinMaxArray; ___2238<___225<double> > atomicNszMinMaxArray; ___2088::SubzoneOffset_t const ___2781 = ___1347.___2781(); ___2088::SubzoneOffset_t const ___2821 = ___1347.___2821(); ___372 ___2037 = atomicCszMinMaxArray.alloc(___2781) && atomicNszMinMaxArray.alloc(___2821); if (___2037) { size_t const maxNumTasks = static_cast<size_t>(___36.___4155() * MINMAX_MAX_TASKS_PER_CORE); size_t const numCszTasksAtMinJobSize = static_cast<size_t>(___2781 + MINMAX_MIN_CSZ_TASK_SIZE - 1) / MINMAX_MIN_CSZ_TASK_SIZE; size_t const numCszTasks = std::min(numCszTasksAtMinJobSize, maxNumTasks); ___2118 ___2117 = ___36.___4156(); ___2088::SubzoneOffset_t cellSubzoneStart = 0; for (size_t task = 1; task <= numCszTasks; ++task) { ___2088::SubzoneOffset_t const cellSubzoneEnd = static_cast<___2088::SubzoneOffset_t>(___2781 * task / numCszTasks); ___476(cellSubzoneStart < cellSubzoneEnd); VoidFunction* voidFunction = new VoidFunction(boost::bind( &calculateAndApplyCellMinMaxes, cellSubzoneStart, cellSubzoneEnd, boost::ref(___1347), boost::ref(___2721), boost::ref(nlFieldData), boost::ref(ccFieldData), boost::ref(atomicCszMinMaxArray), boost::ref(atomicNszMinMaxArray))); ___36.___4154(threadPoolJob, (___90)voidFunction, ___2117); cellSubzoneStart = cellSubzoneEnd; } ___2716 const ___2819 = ___1347.___1766(); size_t const numNodesTasksAtMinJobSize = static_cast<size_t>(___2819 + MINMAX_MIN_NODE_TASK_SIZE - 1) / MINMAX_MIN_NODE_TASK_SIZE; size_t const numNodeTasks = std::min(numNodesTasksAtMinJobSize, maxNumTasks); boost::unordered_set<___2716> ghostNodeSet; GhostInfo_pa ghostNodeInfo = ___36.zoneGhostNodeInfoGetRef(zone + 1); if (ghostNodeInfo) for (___81 i = 0; i < ___36.ghostInfoGetNumItemsByRef(ghostNodeInfo); ++i) ghostNodeSet.insert(static_cast<___2716>(___36.ghostInfoGetItemByRef(ghostNodeInfo, i + 1) - 1));
___2716 nodeStart = 0; for (size_t task = 1; task <= numNodeTasks; ++task) { ___2716 const nodeEnd = static_cast<___2716>(___2819 * task / numNodeTasks); ___476(nodeStart < nodeEnd); VoidFunction *voidFunction = new VoidFunction(boost::bind( applyNodalValuesToNodeSubzoneMinMaxes, nodeStart, nodeEnd, nlFieldData, boost::ref(___1347), boost::ref(ghostNodeSet), boost::ref(atomicNszMinMaxArray))); ___36.___4154(threadPoolJob, (___90)voidFunction, ___2117); nodeStart = nodeEnd; } ___36.___4159(___2117); ___36.___4157(&___2117); if (___2037) { for (___2088::SubzoneOffset_t ___467 = 0; ___467 < ___2781; ++___467) { ENSURE(atomicCszMinMaxArray[___467].___2065()); cszMinMaxArray[___467].include(atomicCszMinMaxArray[___467].minValue()); cszMinMaxArray[___467].include(atomicCszMinMaxArray[___467].maxValue()); } for (___2088::SubzoneOffset_t ___2732 = 0; ___2037 && ___2732 < ___2821; ++___2732) { ENSURE(atomicNszMinMaxArray[___2732].___2065()); ___2760[___2732].include(atomicNszMinMaxArray[___2732].minValue()); ___2760[___2732].include(atomicNszMinMaxArray[___2732].maxValue()); } atomicCszMinMaxArray.___935(); atomicNszMinMaxArray.___935(); } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; }
 #endif 
___372 ___1665( ___37&        ___36, ___1348 const&  ___1347, ___4634        zone, ___4350         fileVar, ___1350 const&   nlFieldData, ___1350 const&   ccFieldData, ___2479&       cszMinMaxArray, ___2479&       ___2760) { REQUIRE(zone >= 0); REQUIRE(fileVar >= 0); REQUIRE(nlFieldData.___2065()); REQUIRE("ccFieldData might be invalid if not CC data"); ___372 ___2037 = ___4224; ___2727 ___2721 = boost::make_shared<___2722>(&___36, zone + 1); if (!___2721->___2065()) ___2037 = ___1303; if (___2037) {
 #ifndef NO_ASSERTS
___2088::SubzoneOffset_t const ___2781 = ___1347.___2781(); ___2088::SubzoneOffset_t const ___2821 = ___1347.___2821(); for (___2088::SubzoneOffset_t ___2732 = 0; ___2732 < ___2821; ___2732++) ___476(!___2760[___2732].___2065()); for (___2088::SubzoneOffset_t ___467 = 0; ___467 < ___2781; ___467++) ___476(!cszMinMaxArray[___467].___2065());
 #endif
___1348::NszMinMaxMap const& nszMinMaxes = ___1347.getNszMinMaxes(); for (___1348::NszMinMaxMap::const_iterator valuePair = nszMinMaxes.begin(); valuePair != nszMinMaxes.end(); ++valuePair) { ___2760[valuePair->first].include(valuePair->second[fileVar]); }
 #if defined TECIOMPI
calculateAndApplyCellMinMaxes(0, ___1347.___2781(), ___1347, *___2721, nlFieldData, ccFieldData, cszMinMaxArray, ___2760);
 #else
___2037 = calculateAndApplyCellMinMaxesMultithreaded(___36, ___1347, zone, *___2721, nlFieldData, ccFieldData, cszMinMaxArray, ___2760);
 #endif
} ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } ___372 SZLFEZoneWriter::calculateVarSubzoneMinMaxes( ___4350   datasetVar, ___2479& ___2760, ___2479& cszMinMaxArray) { REQUIRE(cszMinMaxArray.empty()); REQUIRE(___2760.empty()); REQUIRE(m_writeVariables[datasetVar - m_varIter.baseItem()]); ___372 ___2037 = ___4224; ___2037 = ___2037 && cszMinMaxArray.alloc(m_feZoneInfo->___2781(), ___2477()); ___2037 = ___2037 && ___2760.alloc(m_feZoneInfo->___2821(), ___2477()); if (___2037) { if (___2335.___908(___2675 + 1, datasetVar + 1) == ___4328) { ___1350 nlFieldData(&___2335, ___2675 + 1, datasetVar + 1, false , false/*___962*/); ___1350 ccFieldData; ___2037 = nlFieldData.___2065() && ___1665(___2335, *m_feZoneInfo, ___2675, datasetVar - m_varIter.baseItem(), nlFieldData, ccFieldData, cszMinMaxArray, ___2760); } else { ___1350 nlFieldData(&___2335, ___2675 + 1, datasetVar + 1, false , true/*___962*/); ___1350 ccFieldData(&___2335, ___2675 + 1, datasetVar + 1, false , false/*___962*/); ___2037 = nlFieldData.___2065() && ccFieldData.___2065() && ___1665(___2335, *m_feZoneInfo, ___2675, datasetVar - m_varIter.baseItem(), nlFieldData, ccFieldData, cszMinMaxArray, ___2760); } } return ___2037; } ___372 SZLFEZoneWriter::___4499( FileWriterInterface&         file, ___2088::SubzoneOffset_t ___467) { ___372 ___2037 = ___4224; REQUIRE(file.___2039()); if (file.___2000()) { ___2037 = writeValue<uint32_t, false, 0>(file, "cszConnectivityMarker*", SZPLT_CSZ_CONNECTIVITY_MARKER) && writeValue<uint32_t, false, 0>(file, m_zoneNumberLabel.c_str(), (___2675 - m_baseZone + 1)) && writeValue<uint64_t, false, 0>(file, "subzoneNum*", ___467 + 1); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } uint64_t SZLFEZoneWriter::cszConnectivityHeaderFileSize(bool ___2000) { uint64_t ___3356 = 0; if (___2000) { ___3356 += 2 * valueSizeInFile<uint32_t, false>(___2000) + valueSizeInFile<uint64_t, false>(___2000); } return ___3356; } ___372 SZLFEZoneWriter::___4498( FileWriterInterface&           file, ___1337 const& compressor, bool                           outputPartitionIndices) { REQUIRE(file.___2039()); ___372 ___2037 = ___4224; if (outputPartitionIndices) { if (compressor.numRefPartitions() <= MAX_REFS_FOR_2_BIT_COMPRESSION) { uint8_t const* refPtn2BitOffsets = compressor.refPtn2BitOffsets(); ___2037 = ___2037 && ___4561<uint8_t, true, 0>(file, "refPtn2BitOffsets", ___2743, (compressor.numRefNszs() + 3) / 4, &refPtn2BitOffsets[0], ___944 / 4); } else if (compressor.numRefPartitions() <= MAX_REFS_FOR_4_BIT_COMPRESSION) { uint8_t const* refPtn4BitOffsets = compressor.refPtn4BitOffsets(); ___2037 = ___2037 && ___4561<uint8_t, true, 0>(file, "refPtn4BitOffsets", ___2743, (compressor.numRefNszs() + 1) / 2, &refPtn4BitOffsets[0], ___944 / 2);
} else if (compressor.numRefPartitions() <= MAX_REFS_FOR_8_BIT_COMPRESSION) { uint8_t const* refPtn8BitOffsets = compressor.refPtn8BitOffsets(); ___2037 = ___2037 && ___4561<uint8_t, true, 0>(file, "refPtn8BitOffsets", ___2743, compressor.numRefNszs(), &refPtn8BitOffsets[0]); } else { uint16_t const* refPtn16BitOffsets = compressor.refPtn16BitOffsets(); ___2037 = ___2037 && ___4561<uint16_t, true, 0>(file, "refPtn16BitOffsets", ___2743, compressor.numRefNszs(), &refPtn16BitOffsets[0]); } } ___2037 = ___2037 && ___4561<uint32_t, false, 1>(file, CSZ_CONNECT_REF_NSZ_ARRAY_DESCRIPTION, ___2743, compressor.numRefNszs(), &compressor.___3317()[0]); size_t ___2793 = static_cast<size_t>(compressor.___2780() * m_feZoneInfo->___1765()); if (compressor.numRefNszs() <= MAX_REFS_FOR_2_BIT_COMPRESSION) { uint8_t const* refNsz2BitOffsets = compressor.refNsz2BitOffsets(); ___2037 = ___2037 && ___4561<uint8_t, true, 0>(file, CSZ_CONNECT_REF_NSZ_OFFSET_2BIT_ARRAY_DESCRIPTION, ___2743, ___2793 / 4, &refNsz2BitOffsets[0], m_feZoneInfo->___1765()/4); } else if (compressor.numRefNszs() <= MAX_REFS_FOR_4_BIT_COMPRESSION) { uint8_t const* ___3319 = compressor.___3319(); ___2037 = ___2037 && ___4561<uint8_t, true, 0>(file, CSZ_CONNECT_REF_NSZ_OFFSET_4BIT_ARRAY_DESCRIPTION, ___2743, ___2793 / 2, &___3319[0], m_feZoneInfo->___1765()/2); } else if (compressor.numRefNszs() <= MAX_REFS_FOR_8_BIT_COMPRESSION) { uint8_t const* ___3320 = compressor.___3320(); ___2037 = ___2037 && ___4561<uint8_t, true, 0>(file, CSZ_CONNECT_REF_NSZ_OFFSET_8BIT_ARRAY_DESCRIPTION, ___2743, ___2793, &___3320[0], m_feZoneInfo->___1765()); } else { uint16_t const* ___3318 = compressor.___3318(); ___2037 = ___2037 && ___4561<uint16_t, true, 0>(file, CSZ_CONNECT_REF_NSZ_OFFSET_16BIT_ARRAY_DESCRIPTION, ___2743, ___2793, &___3318[0], m_feZoneInfo->___1765()); } uint8_t const* ___2762 = compressor.___2762(); ___2037 = ___2037 && ___4561<uint8_t, false, 0>(file, CSZ_CONNECT_NSZ_OFFSET_ARRAY_DESCRIPTION, ___2743, ___2793, &___2762[0], m_feZoneInfo->___1765()); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } uint64_t SZLFEZoneWriter::cszConnectivityDataFileSize( bool ___2000, size_t totalNumCellCorners, size_t numRefNszs, ___2088::___2978 numRefPartitions, bool outputPartitionIndices) { uint64_t ___3356 = 0; if (outputPartitionIndices) { if (numRefPartitions <= MAX_REFS_FOR_2_BIT_COMPRESSION) ___3356 += arraySizeInFile<uint8_t, true  >((numRefNszs + 3) / 4, ___2000); else if (numRefPartitions <= MAX_REFS_FOR_4_BIT_COMPRESSION) ___3356 += arraySizeInFile<uint8_t, true  >((numRefNszs + 1) / 2, ___2000); else if (numRefPartitions <= MAX_REFS_FOR_8_BIT_COMPRESSION) ___3356 += arraySizeInFile<uint8_t, true  >(numRefNszs, ___2000); else ___3356 += arraySizeInFile<uint16_t, true  >(numRefNszs, ___2000);
} ___3356 += arraySizeInFile<uint32_t, false>(numRefNszs, ___2000); if (numRefNszs <= MAX_REFS_FOR_2_BIT_COMPRESSION) ___3356 += arraySizeInFile<uint8_t, true  >(totalNumCellCorners / 4, ___2000); else if (numRefNszs <= MAX_REFS_FOR_4_BIT_COMPRESSION) ___3356 += arraySizeInFile<uint8_t, true  >(totalNumCellCorners / 2, ___2000); else if (numRefNszs <= MAX_REFS_FOR_8_BIT_COMPRESSION) ___3356 += arraySizeInFile<uint8_t, true  >(totalNumCellCorners, ___2000); else ___3356 += arraySizeInFile<uint16_t, true  >(totalNumCellCorners, ___2000); ___3356 += arraySizeInFile<uint8_t, false>(totalNumCellCorners, ___2000); return ___3356; } struct CompressSubzoneJobData { ___2238<___1337>* m_compressorVector; ___2727 ___2495; ___1348 const* m_feZoneInfo; ___2088::SubzoneOffset_t m_compressorBegin; ___2088::SubzoneOffset_t m_subzoneBegin; ___2088::SubzoneOffset_t m_subzoneCount; }; void compressSubzoneJob(___90 ___2121) { CompressSubzoneJobData* compressSubzoneJobData = reinterpret_cast<CompressSubzoneJobData*>(___2121); ___2238<___1337>& compressorVector = *compressSubzoneJobData->m_compressorVector; ___2727 ___2721 = compressSubzoneJobData->___2495; ___1348 const& ___1347 = *compressSubzoneJobData->m_feZoneInfo; ___2088::SubzoneOffset_t const compressorBegin = compressSubzoneJobData->m_compressorBegin; ___2088::SubzoneOffset_t const subzoneBegin = compressSubzoneJobData->m_subzoneBegin; ___2088::SubzoneOffset_t const subzoneCount = compressSubzoneJobData->m_subzoneCount; for (___2088::SubzoneOffset_t i = 0; i < subzoneCount; ++i) { ___2088::SubzoneOffset_t const whichCompressor = compressorBegin + i; ___2088::SubzoneOffset_t const ___3878 = subzoneBegin + i; ___1337& feCellSubzoneCompressor = compressorVector[whichCompressor]; feCellSubzoneCompressor.___534(___2721, ___1347, ___3878); } } ___372 SZLFEZoneWriter::writeCszConnectivity( FileWriterInterface&      szpltFile, ___2727                ___2721, PartitionSubzoneSetArray& nszRefPtnCszSets) { REQUIRE(szpltFile.___2039()); REQUIRE(___2721->___2065()); REQUIRE(nszRefPtnCszSets.size() == size_t(m_feZoneInfo->___2821())); ___372 ___2037 = ___4224; size_t const ___2781 = size_t(m_feZoneInfo->___2781()); ___476(___2781 > 0); size_t const ___2825 = size_t(___2335.___4155()); size_t const numChunks = 1 + (___2781-1)/FEWRITER_MIN_CSZS_PER_CHUNK; size_t const numTasks = std::min(___2825, numChunks); size_t const subzonesPerTask = std::min<size_t>(FEWRITER_MAX_CSZS_PER_CHUNK, 1 + (___2781-1)/numTasks); size_t const subzonesPerChunk = numTasks * subzonesPerTask; ___2238<___1337> compressorVector; if (!compressorVector.alloc(subzonesPerChunk)) throw std::bad_alloc(); ___2238<CompressSubzoneJobData> compressSubzoneJobDataVector; if (!compressSubzoneJobDataVector.alloc(numTasks))
throw std::bad_alloc(); for(size_t task = 0; task < numTasks; ++task) { compressSubzoneJobDataVector[task].m_compressorVector = &compressorVector; compressSubzoneJobDataVector[task].___2495 = ___2721; compressSubzoneJobDataVector[task].m_feZoneInfo = m_feZoneInfo.get(); } ___2118 ___2117 = ___2335.___4156();
 #if defined OUTPUT_TIMES
uint64_t compressTime = 0; uint64_t ___4547 = 0; uint64_t ___3685 = ___715();
 #endif
for (size_t chunkSubzoneBegin = 0; ___2037 && chunkSubzoneBegin < ___2781; chunkSubzoneBegin += subzonesPerChunk) { size_t const chunkSubzoneEnd = std::min(chunkSubzoneBegin + subzonesPerChunk, ___2781); size_t const numCszsThisChunk = chunkSubzoneEnd-chunkSubzoneBegin; size_t const subzonesPerTaskThisChunk = 1 + (numCszsThisChunk-1)/numTasks; size_t const numTasksThisChunk = 1 + (numCszsThisChunk-1)/subzonesPerTaskThisChunk; for(size_t task = 0; task < numTasksThisChunk; ++task) { size_t const threadSubzoneBegin = chunkSubzoneBegin + task * subzonesPerTaskThisChunk; size_t const threadSubzoneEnd = std::min(threadSubzoneBegin + subzonesPerTaskThisChunk, ___2781); CompressSubzoneJobData* compressSubzoneJobData = &compressSubzoneJobDataVector[task]; compressSubzoneJobData->m_subzoneBegin = ___2088::SubzoneOffset_t(threadSubzoneBegin); compressSubzoneJobData->m_subzoneCount = ___2088::SubzoneOffset_t(threadSubzoneEnd - threadSubzoneBegin); compressSubzoneJobData->m_compressorBegin = ___2088::SubzoneOffset_t(threadSubzoneBegin - chunkSubzoneBegin); ___2335.___4154(compressSubzoneJob, (___90)compressSubzoneJobData, ___2117); } ___2335.___4159(___2117);
 #if defined OUTPUT_TIMES
uint64_t ___1165 = ___715(); compressTime += (___1165 - ___3685); ___3685 = ___1165;
 #endif
___4634 const fileZone = ___2675 - m_baseZone; for(___2088::SubzoneOffset_t ___3921 = ___2088::SubzoneOffset_t(chunkSubzoneBegin); ___2037 && ___3921 < ___2088::SubzoneOffset_t(chunkSubzoneEnd); ++___3921) { m_cszConnectivityFileLocs[___3921] = szpltFile.fileLoc(); ___1337& feCellSubzoneCompressor = compressorVector[___3921 - chunkSubzoneBegin]; ___2088::SubzoneOffset_t const numRefNszs = feCellSubzoneCompressor.numRefNszs(); bool outputPartitionIndices = false; for(___2088::SubzoneOffset_t ___3321 = 0; ___3321 < numRefNszs; ++___3321) { ___2088::___2978 ___2975 = feCellSubzoneCompressor.refPtnNszs()[___3321].first; if (___2975 == ___2088::INVALID_PARTITION || static_cast<___4634>(___2975) == fileZone) { ___2088::SubzoneOffset_t const ___2755 = feCellSubzoneCompressor.refPtnNszs()[___3321].second; PartitionSubzone ptnCsz(fileZone, ___3921); nszRefPtnCszSets[___2755].insert(ptnCsz); } else { outputPartitionIndices = true; } } ___2037 = ___2037 && ___4499(szpltFile, ___3921); ___2037 = ___2037 && ___4498(szpltFile, compressorVector[___3921 - chunkSubzoneBegin], outputPartitionIndices); if (outputPartitionIndices) setBit(m_cszIncludesPartitionOffsetsBitArray, ___3921); m_numRefNodeSubzones[___3921] = compressorVector[___3921 - chunkSubzoneBegin].numRefNszs(); }
 #if defined OUTPUT_TIMES
___1165 = ___715(); ___4547 += (___1165 - ___3685); ___3685 = ___1165;
 #endif
}
 #if defined OUTPUT_TIMES
___1929(NULL, "%g seconds compressing cell subzones.", (double)(compressTime) / 1000.0); ___1929(NULL, "%g seconds writing cell subzones.", (double)(___4547) / 1000.0);
 #endif
___2335.___4157(&___2117); return ___2037; } uint64_t SZLFEZoneWriter::cszConnectivityFileSize(bool ___2000, PartitionSubzoneSetArray& nszRefPtnCszSets) { uint64_t ___3356 = m_feZoneInfo->___2781() * cszConnectivityHeaderFileSize(___2000); ___2722 ___2721(&___2335, ___2675 + 1); ___2225 ___2787 = ___2721.___1762(); ___4634 const fileZone = ___2675 - m_baseZone; for(___2088::SubzoneOffset_t ___684 = 0; ___684 < m_feZoneInfo->___2781(); ++___684) { boost::unordered_set<PartitionSubzone> refPtnNszSet; bool outputPartitionIndices = false; for(___2088::ItemOffset_t off = 0; off < m_feZoneInfo->___2780(___684); ++off) { ___2088 cellCoordinate(___2088::UNKNOWN_PARTITION, ___684, off); ___463 ___447 = m_feZoneInfo->___4606(cellCoordinate); for(int32_t ___679 = 1; ___679 <= ___2787; ++___679) { int64_t ___2707 = ___2721.___1761(___447 + 1, ___679); ___2088 nodeCoordinate = m_feZoneInfo->___3922(___2707 - 1); ___2088::___2978 ___2975 = nodeCoordinate.___2975(); ___2088::SubzoneOffset_t ___2755 = nodeCoordinate.subzoneOffset(); if (___2975 == ___2088::INVALID_PARTITION || static_cast<___4634>(___2975) == fileZone) { refPtnNszSet.insert(PartitionSubzone(fileZone, ___2755)); nszRefPtnCszSets[___2755].insert(PartitionSubzone(fileZone, ___684)); } else { refPtnNszSet.insert(PartitionSubzone(___2975, ___2755)); outputPartitionIndices = true; } } } size_t totalNumCellCorners = static_cast<size_t>(m_feZoneInfo->___2780(___684)) * ___2787; uint64_t cszDataFileSize = cszConnectivityDataFileSize( ___2000, totalNumCellCorners, refPtnNszSet.size(), m_feZoneInfo->getNumReferencedPartitions(), outputPartitionIndices); ___3356 += cszDataFileSize; } return ___3356; } ___372 SZLFEZoneWriter::___4535( FileWriterInterface&         file, ___2088::SubzoneOffset_t ___2732) { ___372 ___2037 = ___4224; REQUIRE(file.___2039()); if (file.___2000()) { ___2037 = writeValue<uint32_t, false, 0>(file, "nszConnectivityMarker*", SZPLT_NSZ_CONNECTIVITY_MARKER) && writeValue<uint32_t, false, 0>(file, m_zoneNumberLabel.c_str(), (___2675 - m_baseZone + 1)) && writeValue<uint64_t, false, 0>(file, "subzoneNum*", ___2732 + 1); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } uint64_t SZLFEZoneWriter::nszConnectivityHeaderFileSize(bool ___2000) { uint64_t ___3356 = 0; if (___2000) ___3356 += 2 * valueSizeInFile<uint32_t, false>(___2000) + valueSizeInFile<uint64_t, false>(___2000); return ___3356; } namespace { inline ___372 ___4534( FileWriterInterface&       file, char const*                ___970, PartitionSubzoneSet const& refPtnCszSet, PartitionArray const&      referencedPartitions, ___2088::___2978   numReferencedPartitions, bool                       outputPartitionIndices) { ___4276(___970); if (refPtnCszSet.size() > uint16_t(-1)) { std::cerr << "Overflow while writing Node subzone. Too many cells use the same node (> 65536)." << std::endl;
return ___1303; } UInt32Array refPtnArray; UInt32Array refCszArray; uint16_t const numRefCszs = uint16_t(refPtnCszSet.size()); ___372 ___2037 = ___4224; if (___2037 && numRefCszs > 0) { ___2037 = refPtnArray.alloc(numRefCszs) && refCszArray.alloc(numRefCszs); if ( ___2037 ) { ___2088::SubzoneOffset_t refCszIndex = 0; for (PartitionSubzoneSet::const_iterator iter = refPtnCszSet.begin(); iter != refPtnCszSet.end(); iter++) { ___2088::___2978 ___2975 = iter->first; refPtnArray[refCszIndex] = ___2975; refCszArray[refCszIndex] = iter->second; refCszIndex++; } ___476(refCszIndex==numRefCszs); if (outputPartitionIndices) { if (numReferencedPartitions <= MAX_REFS_FOR_2_BIT_COMPRESSION) { UInt8Array refPtn2BitOffsets; ___2037 = refPtn2BitOffsets.alloc(numRefCszs / 4 + 1); if (___2037) { gather2BitOffsets(&refPtn2BitOffsets[0], &refPtnArray[0], numRefCszs, &referencedPartitions[0], numReferencedPartitions); ___2037 = ___2037 && ___4561<uint8_t, true, 0>(file, "refPtn2BitOffsets", ___2743, (numRefCszs + 3) / 4, &refPtn2BitOffsets[0], ___944 / 4); } } else if (numReferencedPartitions <= MAX_REFS_FOR_4_BIT_COMPRESSION) { UInt8Array refPtn4BitOffsets; ___2037 = refPtn4BitOffsets.alloc(numRefCszs / 2 + 1); if (___2037) { gather4BitOffsets(&refPtn4BitOffsets[0], &refPtnArray[0], numRefCszs, &referencedPartitions[0], numReferencedPartitions); ___2037 = ___2037 && ___4561<uint8_t, true, 0>(file, "refPtn4BitOffsets", ___2743, (numRefCszs + 1) / 2, &refPtn4BitOffsets[0], ___944 / 2); } } else if (numReferencedPartitions <= MAX_REFS_FOR_8_BIT_COMPRESSION) { UInt8Array refPtn8BitOffsets; ___2037 = refPtn8BitOffsets.alloc(numRefCszs); if (___2037) { gatherOffsets(&refPtn8BitOffsets[0], &refPtnArray[0], numRefCszs, &referencedPartitions[0], numReferencedPartitions); ___2037 = ___2037 && ___4561<uint8_t, true, 0>(file, "refPtn8BitOffsets", ___2743, numRefCszs, &refPtn8BitOffsets[0]); } } else { UInt16Array refPtn16BitOffsets; ___2037 = refPtn16BitOffsets.alloc(numRefCszs); if (___2037) { gatherOffsets(&refPtn16BitOffsets[0], &refPtnArray[0], numRefCszs, &referencedPartitions[0], numReferencedPartitions); ___2037 = ___2037 && ___4561<uint16_t, true, 0>(file, "refPtn16BitOffsets", ___2743, numRefCszs, &refPtn16BitOffsets[0]); } } } ___2037 = ___2037 && ___4561<uint32_t, false, 1>(file, NSZ_CONNECT_REF_CSZS, ___2743, numRefCszs, &refCszArray[0]); } refPtnArray.___935(); refCszArray.___935(); } ENSURE(refPtnArray.empty()); ENSURE(refCszArray.empty()); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } uint64_t nszConnectivityDataFileSize( bool ___2000, ___2088::___2978 numReferencedPartitions, bool outputPartitionIndices, PartitionSubzoneSet const& refPtnCszSet) { uint64_t ___3356 = 0; size_t const numRefCszs = refPtnCszSet.size(); if (outputPartitionIndices) { if (numReferencedPartitions <= MAX_REFS_FOR_2_BIT_COMPRESSION) ___3356 += arraySizeInFile<uint8_t, true  >((numRefCszs + 3) / 4, ___2000); else if (numReferencedPartitions <= MAX_REFS_FOR_4_BIT_COMPRESSION)
___3356 += arraySizeInFile<uint8_t, true  >((numRefCszs + 1) / 2, ___2000); else if (numReferencedPartitions <= MAX_REFS_FOR_8_BIT_COMPRESSION) ___3356 += arraySizeInFile<uint8_t, true  >(numRefCszs, ___2000); else ___3356 += arraySizeInFile<uint16_t, true  >(numRefCszs, ___2000); } ___3356 += arraySizeInFile<uint32_t, false>(numRefCszs, ___2000); return ___3356; } } ___372 SZLFEZoneWriter::___4533( FileWriterInterface&      szpltFile, PartitionSubzoneSetArray& nszRefPtnCszSets) { ___372 ___2037 = ___4224; for (___1348::NeighborCszRefMap::const_iterator entryIt = m_feZoneInfo->getNeighborCszRefs().begin(); entryIt != m_feZoneInfo->getNeighborCszRefs().end(); ++entryIt) { ___1348::NeighborCszRefMap::value_type const& entry = *entryIt; ___2088::SubzoneOffset_t ___2732 = entry.first; for (boost::unordered_set<PartitionSubzone>::iterator ptnCszIt = entry.second.begin(); ptnCszIt != entry.second.end(); ++ptnCszIt) { PartitionSubzone const& ptnCsz = *ptnCszIt; nszRefPtnCszSets[___2732].insert(ptnCsz); } } ___4634 const fileZone = ___2675 - m_baseZone; for (___2088::SubzoneOffset_t ___2732 = 0; ___2037 && ___2732 < m_feZoneInfo->___2821(); ___2732++) { m_nszConnectivityFileLocs[___2732] = szpltFile.fileLoc(); m_numRefCellSubzones[___2732] = static_cast<uint16_t>(nszRefPtnCszSets[___2732].size()); bool outputPartitionIndices = false; for (PartitionSubzoneSet::iterator partitionSubzoneIt = nszRefPtnCszSets[___2732].begin(); partitionSubzoneIt != nszRefPtnCszSets[___2732].end(); ++partitionSubzoneIt) { PartitionSubzone const& partitionSubzone = *partitionSubzoneIt; ___2088::___2978 ptnIndex = partitionSubzone.first; if (ptnIndex != ___2088::INVALID_PARTITION && static_cast<___4634>(ptnIndex) != fileZone) { outputPartitionIndices = true; } } if (outputPartitionIndices) setBit(m_nszIncludesPartitionOffsetsBitArray, ___2732); ___2037 = ___2037 && ___4535(szpltFile, ___2732); ___2037 = ___2037 && ___4534(szpltFile, "nszConnectivity", nszRefPtnCszSets[___2732], m_feZoneInfo->getReferencedPartitions(), m_feZoneInfo->getNumReferencedPartitions(), outputPartitionIndices); } return ___2037; } uint64_t SZLFEZoneWriter::nszConnectivityFileSize(bool ___2000, PartitionSubzoneSetArray& nszRefPtnCszSets) { uint64_t ___3356 = m_feZoneInfo->___2821() * nszConnectivityHeaderFileSize(___2000); for (___1348::NeighborCszRefMap::const_iterator entry = m_feZoneInfo->getNeighborCszRefs().begin(); entry != m_feZoneInfo->getNeighborCszRefs().end(); ++entry) { ___2088::SubzoneOffset_t ___2732 = entry->first; for (boost::unordered_set<PartitionSubzone>::const_iterator ptnCsz = entry->second.begin(); ptnCsz != entry->second.end(); ++ptnCsz) { nszRefPtnCszSets[___2732].insert(*ptnCsz); } } ___4634 const fileZone = ___2675 - m_baseZone; for(___2088::SubzoneOffset_t ___2755 = 0; ___2755 < m_feZoneInfo->___2821(); ++___2755) { bool outputPartitionIndices = false;
for (PartitionSubzoneSet::iterator partitionSubzone = nszRefPtnCszSets[___2755].begin(); partitionSubzone != nszRefPtnCszSets[___2755].end(); ++partitionSubzone) { ___2088::___2978 ptnIndex = partitionSubzone->first; if (ptnIndex != ___2088::INVALID_PARTITION && static_cast<___4634>(ptnIndex) != fileZone) outputPartitionIndices = true; } ___3356 += nszConnectivityDataFileSize(___2000, m_feZoneInfo->getNumReferencedPartitions(), outputPartitionIndices, nszRefPtnCszSets[___2755]); } return ___3356; } ___372 SZLFEZoneWriter::writeZoneConnectivity(FileWriterInterface& szpltFile) { ___372 ___2037 = ___4224; if (m_writeConnectivity) { ___2335.___856(); PartitionSubzoneSetArray nszRefPtnCszSets;
 #if defined OUTPUT_TIMES
uint64_t ___3685 = ___715();
 #endif
___2037 = ___2037 && ___483(SzPltWriteOperation_WriteConnectivity, ___2335, 0 , ___2675); ___2037 = ___2037 && nszRefPtnCszSets.alloc(m_feZoneInfo->___2821()); ___2037 = ___2037 && m_cszConnectivityFileLocs.alloc(m_feZoneInfo->___2781(), ___330); ___2037 = ___2037 && m_numRefNodeSubzones.alloc(m_feZoneInfo->___2781(), 0); ___2037 = ___2037 && m_numRefCellSubzones.alloc(m_feZoneInfo->___2821(), 0); ___2037 = ___2037 && m_cszIncludesPartitionOffsetsBitArray.alloc(numBytesForNumBits(m_feZoneInfo->___2781()), 0); ___2037 = ___2037 && m_nszIncludesPartitionOffsetsBitArray.alloc(numBytesForNumBits(m_feZoneInfo->___2821()), 0); ___2727 ___2721 = boost::make_shared<___2722>(&___2335, ___2675 + 1); if (!___2721->___2065()) ___2037 = ___1303; try { ___2037 = ___2037 && writeCszConnectivity(szpltFile, ___2721, nszRefPtnCszSets);
 #if defined OUTPUT_TIMES
uint64_t ___1165 = ___715(); ___1929(NULL, "%g seconds writing cell subzone connectivity.", (double)(___1165 - ___3685) / 1000.0); ___3685 = ___1165;
 #endif
} catch (___1337::Error const& e) { std::cerr << "Error compressing node map: " << e.what() << std::endl; ___2037 = ___1303; } ___2037 = ___2037 && m_nszConnectivityFileLocs.alloc(m_feZoneInfo->___2821(), ___330); ___2037 = ___2037 && ___4533(szpltFile, nszRefPtnCszSets);
 #if defined OUTPUT_TIMES
uint64_t ___1165 = ___715(); ___1929(NULL, "%g seconds writing node subzone connectivity.", (double)(___1165 - ___3685) / 1000.0);
 #endif
___2335.___857(); } return ___2037; } uint64_t SZLFEZoneWriter::zoneConnectivityFileSize(bool ___2000) { uint64_t ___3356 = 0; if (m_writeConnectivity) { PartitionSubzoneSetArray nszRefPtnCszSets; if (nszRefPtnCszSets.alloc(m_feZoneInfo->___2821())) { ___3356 += cszConnectivityFileSize(___2000, nszRefPtnCszSets); ___3356 += nszConnectivityFileSize(___2000, nszRefPtnCszSets); } } return ___3356; } ___372 SZLFEZoneWriter::___4510( FileWriterInterface&         file, ValueLocation_e              ___4324, ___4350                   datasetVar, ___2088::SubzoneOffset_t ___3878) { ___372 ___2037 = ___4224; REQUIRE(file.___2039()); REQUIRE(___4324 == ___4326 || ___4324 == ___4328); if (file.___2000()) { if ( ___4324 == ___4326 ) ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, "cszFieldDataMarker*", SZPLT_CSZ_FIELD_DATA_MARKER); else ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, "nszFieldDataMarker*", SZPLT_NSZ_FIELD_DATA_MARKER); ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, "variableNum*", (datasetVar - m_varIter.baseItem() + 1)); ___2037 = ___2037 && writeValue<uint32_t, false, 0>(file, m_zoneNumberLabel.c_str(), (___2675 - m_baseZone + 1)); ___2037 = ___2037 && writeValue<uint64_t, false, 0>(file, "subzoneNum*", ___3878 + 1); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } uint64_t SZLFEZoneWriter::fieldDataSubzoneHeaderFileSize(bool ___2000) { uint64_t ___3356 = 0; if (___2000) { ___3356 += 3 * valueSizeInFile<uint32_t, false>(___2000) + valueSizeInFile<uint64_t, false>(___2000); } return ___3356; } template <typename T, bool isBitArray> uint64_t SZLFEZoneWriter::cellSubzoneFieldDataFileSize(bool ___2000, ___2088::SubzoneOffset_t ___467) const { size_t ___2780 = static_cast<size_t>(m_feZoneInfo->___2780(___467)); return arraySizeInFile<T, false>(___2780, ___2000); } template <> uint64_t SZLFEZoneWriter::cellSubzoneFieldDataFileSize<uint8_t, true>(bool ___2000, ___2088::SubzoneOffset_t ___467) const { size_t ___2780 = static_cast<size_t>(m_feZoneInfo->___2780(___467)); return arraySizeInFile<uint8_t, false>(numBytesForNumBits(___2780), ___2000); } template <typename T, bool isBitArray> uint64_t SZLFEZoneWriter::nodeSubzoneFieldDataFileSize(bool ___2000, ___2088::SubzoneOffset_t ___2732) const { size_t ___2820 = static_cast<size_t>(m_feZoneInfo->___2820(___2732)); return arraySizeInFile<T, false>(___2820, ___2000); } template <> uint64_t SZLFEZoneWriter::nodeSubzoneFieldDataFileSize<uint8_t, true>(bool ___2000, ___2088::SubzoneOffset_t ___2732) const { size_t ___2820 = static_cast<size_t>(m_feZoneInfo->___2820(___2732)); return arraySizeInFile<uint8_t, false>(numBytesForNumBits(___2820), ___2000); } template <typename T, bool isBitArray  > uint64_t SZLFEZoneWriter::subzoneFieldDataFileSize(bool ___2000, ___2088::SubzoneOffset_t ___3878, ValueLocation_e ___4324) const
{ if (___4324 == ___4326) return cellSubzoneFieldDataFileSize<T, isBitArray>(___2000, ___3878); else return nodeSubzoneFieldDataFileSize<T, isBitArray>(___2000, ___3878); } template <typename T, bool isBitArray  > uint64_t SZLFEZoneWriter::variableFileSize(bool ___2000, ValueLocation_e ___4324) { uint64_t ___3356 = 0; ___2088::SubzoneOffset_t const ___2821 = m_feZoneInfo->___2821(); ___3356 += arraySizeInFile<std::pair<T, T>, false >(static_cast<size_t>(___2821), ___2000); ___2088::SubzoneOffset_t const ___2781 = m_feZoneInfo->___2781(); ___3356 += arraySizeInFile<std::pair<T, T>, false >(static_cast<size_t>(___2781), ___2000); ___2088::SubzoneOffset_t const numDataSubzones = (___4324 == ___4326) ? ___2781 : ___2821; for (___2088::SubzoneOffset_t ___3921 = 0; ___3921 < numDataSubzones; ___3921++) { ___3356 += fieldDataSubzoneHeaderFileSize(___2000); ___3356 += subzoneFieldDataFileSize<T, isBitArray>(___2000, ___3921, ___4324); } return ___3356; } uint64_t SZLFEZoneWriter::zoneDataFileSize(bool ___2000) { uint64_t ___3356 = 0; m_varIter.reset(); ___4350 const baseVar = m_varIter.baseItem(); while (m_varIter.hasNext()) { ___4350 const datasetVar = m_varIter.next(); ___4350 const fileVar = datasetVar - baseVar; if (!m_writeVariables[fileVar]) continue; FieldDataType_e const ___1361 = ___2335.___921(___2675 + 1, fileVar + 1); ValueLocation_e const ___4324 = ___2335.___908(___2675 + 1, fileVar + 1); switch (___1361) { case FieldDataType_Float: ___3356 += variableFileSize<float, false>(___2000, ___4324); break; case FieldDataType_Double: ___3356 += variableFileSize<double, false>(___2000, ___4324); break; case FieldDataType_Int32: ___3356 += variableFileSize<int32_t, false>(___2000, ___4324); break; case FieldDataType_Int16: ___3356 += variableFileSize<int16_t, false>(___2000, ___4324); break; case FieldDataType_Byte: ___3356 += variableFileSize<uint8_t, false>(___2000, ___4324); break; case ___1363: ___3356 += variableFileSize<uint8_t, true>(___2000, ___4324); break; default: ___476(___1303); break; } } return ___3356; } template <typename T, bool isBitArray  > ___372 SZLFEZoneWriter::___4494( FileWriterInterface&         szpltFile, ___1350 const&             ___1349, ___2088::SubzoneOffset_t ___467) { ___372 ___2037 = ___4224; REQUIRE(szpltFile.___2039()); REQUIRE(___1349.___2065()); REQUIRE(___1349.___1784() == ___4326); ___2238<T> valueArray; ___2088::SubzoneOffset_t ___2780 = m_feZoneInfo->___2780(___467); ___2037 = ___2037 && valueArray.alloc(___2780); T* rawPointer = static_cast<T*>(___1349.getRawPointer()); if (___2037) { for (___2088::ItemOffset_t cszOffset = 0; cszOffset < ___2780; cszOffset++) { ___2088 const ___686(___2088::UNKNOWN_PARTITION, ___467, cszOffset);
___463 const ___447 = m_feZoneInfo->___4606(___686); if (rawPointer) valueArray[cszOffset] = rawPointer[___447]; else valueArray[cszOffset] = static_cast<T>(___1349.___1778(___447 + 1)); } } ___2037 = ___2037 && ___4561<T, false, 0>(szpltFile, "cszFieldData", ___2743, ___2780, &valueArray[0]); valueArray.___935(); ENSURE(valueArray.empty()); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } template <> ___372 SZLFEZoneWriter::___4494<uint8_t, true>( FileWriterInterface&         szpltFile, ___1350 const&             ___1349, ___2088::SubzoneOffset_t ___467) { ___372 ___2037 = ___4224; REQUIRE(szpltFile.___2039()); REQUIRE(___1349.___2065()); REQUIRE(___1349.___1784() == ___4326); ___2238<uint8_t> valueArray; ___2088::SubzoneOffset_t ___2780 = m_feZoneInfo->___2780(___467); uint64_t arraySize = numBytesForNumBits(___2780); ___2037 = ___2037 && valueArray.alloc(arraySize); if (___2037) { for (___2088::ItemOffset_t cszItemOffset = 0; cszItemOffset < ___2780; cszItemOffset++) { ___2088 const ___686(___2088::UNKNOWN_PARTITION, ___467, cszItemOffset); ___463 const ___447 = m_feZoneInfo->___4606(___686); double const ___4296 = ___1349.___1778(___447 + 1); if (___4296 < 1.0) clearBit(valueArray, cszItemOffset); else setBit(valueArray, cszItemOffset); } } ___2037 = ___2037 && ___4561<uint8_t, false, 0>(szpltFile, "cszFieldData", ___2743, arraySize, &valueArray[0]); valueArray.___935(); ENSURE(valueArray.empty()); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } template <typename T, bool isBitArray  > ___372 SZLFEZoneWriter::___4529( FileWriterInterface&         szpltFile, ___1350 const&             ___1349, ___2088::SubzoneOffset_t ___2732) { ___372 ___2037 = ___4224; REQUIRE(szpltFile.___2039()); REQUIRE(___1349.___2065()); REQUIRE(___1349.___1784() == ___4328); ___2238<T> valueArray; ___2088::ItemOffset_t ___2820 = m_feZoneInfo->___2820(___2732); ___2037 = ___2037 && valueArray.alloc(___2820); T* rawPointer = static_cast<T*>(___1349.getRawPointer()); if (___2037) { for (___2088::ItemOffset_t nszItemOffset = 0; nszItemOffset < ___2820; nszItemOffset++) { ___2088 const ___2757(___2088::UNKNOWN_PARTITION, ___2732, nszItemOffset); ___2716 const ___2707 = m_feZoneInfo->___4655(___2757); if (rawPointer) valueArray[nszItemOffset] = rawPointer[___2707]; else valueArray[nszItemOffset] = static_cast<T>(___1349.___1778(___2707 + 1)); } } ___2037 = ___2037 && ___4561<T, false, 0>(szpltFile, "nszFieldData", ___2743, ___2820, &valueArray[0]); valueArray.___935(); ENSURE(valueArray.empty()); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } template <> ___372 SZLFEZoneWriter::___4529<uint8_t, true>(
FileWriterInterface&         szpltFile, ___1350 const&             ___1349, ___2088::SubzoneOffset_t ___2732) { ___372 ___2037 = ___4224; REQUIRE(szpltFile.___2039()); REQUIRE(___1349.___2065()); REQUIRE(___1349.___1784() == ___4328); ___2238<uint8_t> valueArray; ___2088::ItemOffset_t ___2820 = m_feZoneInfo->___2820(___2732); uint64_t arraySize = numBytesForNumBits(___2820); ___2037 = ___2037 && valueArray.alloc(arraySize); if (___2037) { for (___2088::ItemOffset_t ___2761 = 0; ___2761 < ___2820; ___2761++) { ___2088 const ___2757(___2088::UNKNOWN_PARTITION, ___2732, ___2761); ___2716 const ___2707 = m_feZoneInfo->___4655(___2757); double const ___4296 = ___1349.___1778(___2707 + 1); if (___4296 < 1.0) clearBit(valueArray, ___2761); else setBit(valueArray, ___2761); } } ___2037 = ___2037 && ___4561<uint8_t, false, 0>(szpltFile, "nszFieldData", ___2743, arraySize, &valueArray[0]); valueArray.___935(); ENSURE(valueArray.empty()); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } template <typename T, bool isBitArray  > ___372 SZLFEZoneWriter::writeVariable( FileWriterInterface&     szpltFile, ___4350 const         datasetVar, ___2479 const&       nszDataMinMax, ___2479 const&       cszDataMinMax) { ___2088::SubzoneOffset_t const ___2781 = m_feZoneInfo->___2781(); ___2088::SubzoneOffset_t const ___2821 = m_feZoneInfo->___2821(); ___4350 const fileVar = datasetVar - m_varIter.baseItem(); ___372 ___2037 = ___4526<T>(szpltFile, NODE_SUBZONE_DATA_MIN_MAX_ARRAY_DESCRIPTION, fileVar, ___2821, &nszDataMinMax[0], ___944 / 2) && ___4526<T>(szpltFile, CELL_SUBZONE_DATA_MIN_MAX_ARRAY_DESCRIPTION, fileVar, ___2781, &cszDataMinMax[0], ___944 / 2); ___1350 ___1349(&___2335, ___2675 + 1, datasetVar + 1); ___2037 = ___2037 && ___1349.___2065(); ValueLocation_e const ___4324 = ___1349.___1784(); ___2088::SubzoneOffset_t const numDataSubzones = (___4324 == ___4326) ? ___2781 : ___2821; for (___2088::SubzoneOffset_t ___3921 = 0; ___2037 && ___3921 < numDataSubzones; ___3921++) { ___2037 = ___4510(szpltFile, ___4324, datasetVar, ___3921); if (___4324 == ___4326) ___2037 = ___2037 && ___4494<T, isBitArray>(szpltFile, ___1349, ___3921); else ___2037 = ___2037 && ___4529<T, isBitArray>(szpltFile, ___1349, ___3921); } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 SZLFEZoneWriter::writeZoneData(FileWriterInterface& szpltFile) {
 #if defined OUTPUT_TIMES
uint64_t ___3685 = ___715(); uint64_t minMaxTime = 0; uint64_t ___4547 = 0;
 #endif
___372 ___2037 = ___4224; ___2479 ___2760; ___2479 cszMinMaxArray; m_varIter.reset(); ___4350 const baseVar = m_varIter.baseItem(); while (___2037 && m_varIter.hasNext()) { ___4350 const datasetVar = m_varIter.next(); ___4350 const fileVar = datasetVar - baseVar; if (!m_writeVariables[fileVar]) continue; ___2335.___856(); ___2037 = ___483(SzPltWriteOperation_WriteFieldData, ___2335, datasetVar, ___2675); ___2037 = ___2037 && calculateVarSubzoneMinMaxes(datasetVar, ___2760, cszMinMaxArray);
 #if defined OUTPUT_TIMES
uint64_t ___1165 = ___715(); minMaxTime += (___1165 - ___3685); ___3685 = ___1165;
 #endif
___2671[fileVar] = szpltFile.fileLoc(); if (___2037) { switch (___2335.___921(___2675 + 1, datasetVar + 1)) { case FieldDataType_Float: ___2037 = writeVariable<float, false>(szpltFile, datasetVar, ___2760, cszMinMaxArray); break; case FieldDataType_Double: ___2037 = writeVariable<double, false>(szpltFile, datasetVar, ___2760, cszMinMaxArray); break; case FieldDataType_Int32: ___2037 = writeVariable<int32_t, false>(szpltFile, datasetVar, ___2760, cszMinMaxArray); break; case FieldDataType_Int16: ___2037 = writeVariable<int16_t, false>(szpltFile, datasetVar, ___2760, cszMinMaxArray); break; case FieldDataType_Byte: ___2037 = writeVariable<uint8_t, false>(szpltFile, datasetVar, ___2760, cszMinMaxArray); break; case ___1363: ___2037 = writeVariable<uint8_t, true>(szpltFile, datasetVar, ___2760, cszMinMaxArray); break; default: ___476(___1303); ___2037 = ___1303; break; } } ___2760.___935(); cszMinMaxArray.___935();
 #if defined OUTPUT_TIMES
___1165 = ___715(); ___4547 += (___1165 - ___3685); ___3685 = ___1165;
 #endif
___2335.___857(); }
 #if defined OUTPUT_TIMES
uint64_t ___1165 = ___715(); ___1929(NULL, "%g seconds calculating variable ranges.", (double)(minMaxTime) / 1000.0); ___1929(NULL, "%g seconds writing zone data.", (double)(___4547) / 1000.0);
 #endif
ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 SZLFEZoneWriter::writeZoneHeader(FileWriterInterface& szpltFile) { REQUIRE(szpltFile.___2039()); return m_headerWriter.write(szpltFile); } uint64_t SZLFEZoneWriter::zoneHeaderFileSize(bool ___2000) { return m_headerWriter.sizeInFile(___2000); } }}
