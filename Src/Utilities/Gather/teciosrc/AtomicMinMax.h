 #pragma once
#include "ThirdPartyHeadersBegin.h"
#include <limits>
#include <boost/atomic.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "CodeContract.h"
#include "MinMax.h"
namespace tecplot { namespace ___3931 { template <typename T> struct ___225 { boost::atomic<T> m_min; boost::atomic<T> m_max; ___225(void) { invalidate(); } ___225(double newMin, double newMax) { m_min = static_cast<T>(newMin); m_max = static_cast<T>(newMax); } ___225(double ___4296) { m_min = static_cast<T>(___4296); m_max = static_cast<T>(___4296); } ___225(___225<T> const& ___2886) : m_min(___2886.m_min.load()) , m_max(___2886.m_max.load()) {} inline double minValue(void) const { return m_min; }; inline double maxValue(void) const { return m_max; }; inline void ___3497(double newMin, double newMax) { REQUIRE(newMin<=newMax); m_min = static_cast<T>(newMin); m_max = static_cast<T>(newMax); }; inline void ___3497(___225<T> const& ___2886) { m_min = ___2886.m_min.load(); m_max = ___2886.m_max.load(); }; inline void include(double ___4296) { T const tVal = static_cast<T>(___4296); T curMin = m_min; while(tVal < curMin && !m_min.compare_exchange_weak(curMin, tVal)) ; T curMax = m_max; while(tVal > curMax && !m_max.compare_exchange_weak(curMax, tVal)) ; } inline void include(___225<T> const& minMax) { T testMin = minMax.m_min; T curMin = m_min; while(testMin < curMin && !m_min.compare_exchange_weak(curMin, testMin)) ; T testMax = minMax.m_max; T curMax = m_max; while(testMax > curMax && !m_max.compare_exchange_weak(curMax, testMax)) ; } inline void include(___2477 const& minMax) { T testMin = static_cast<T>(minMax.minValue()); T curMin = m_min; while(testMin < curMin && !m_min.compare_exchange_weak(curMin, testMin)) ; T testMax = static_cast<T>(minMax.maxValue()); T curMax = m_max; while(testMax > curMax && !m_max.compare_exchange_weak(curMax, testMax)) ; } inline bool containsValue(double ___4296) const { return ( m_min <= ___4296 && ___4296 <= m_max ); } inline void invalidate(void) { m_min =  std::numeric_limits<T>::max(); m_max = -std::numeric_limits<T>::max(); } inline bool ___2065(void) const { return m_min.load() <= m_max.load(); } ___225<T>& operator=(___225<T> const& ___3390) { m_min = ___3390.m_min.load(); m_max = ___3390.m_max.load(); return *this; } }; }}
