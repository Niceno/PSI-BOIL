#include "stdafx.h"
#include "MASTER.h"
#include "GLOBAL.h"
#include "CodeContract.h"
#include "TASSERT.h"
#include "ALLOC.h"
#include "ARRLIST.h"
#include "DATASET.h"
#include "SET.h"
#include "FILESTREAM.h"
#include "Q_MSG.h"
#include "DATASET0.h"
using namespace tecplot; void ___2887() { ___1175(___4215("Cannot allocate enough memory for this operation.")); } void ___1354(___1359 ___1350) { REQUIRE(VALID_REF(___1350)); { ___1356(___1350); } } ___1360::___1360( ___2225 numIPts, ___2225 numJPts, ___2225 numKPts) : ___814(NULL) , ___1779(NULL) , ___3504(NULL) , ___4690(___4702) , ___4333(___1367) , ___4325(___4327) , iDim(numIPts) , jDim(numJPts) , kDim(numKPts) { } ___1360::~___1360() { ___1354(this); } ___2225 ___1360::numIPts() const { return iDim; } ___2225 ___1360::numJPts() const { return jDim; } ___2225 ___1360::numKPts() const { return kDim; } namespace { ___1359 ___1352( ___2225 numIPts, ___2225 numJPts, ___2225 numKPts) { ___1359 ___3356 = NULL; try { ___3356 = new ___1360(numIPts, numJPts, numKPts); } catch (std::bad_alloc const&) { ENSURE(___3356 == NULL); } ENSURE(VALID_REF(___3356) || ___3356 == NULL); return ___3356; } } namespace { void FieldDataDeallocRawData(___1359 ___1349) { REQUIRE(VALID_REF(___1349)); if (___1718(___1349) != NULL) { char* Tmp = static_cast<char*>(___1718(___1349)); ___1528(Tmp, "FieldData _Data"); ___3485(___1349, NULL); } } } ___2225 ___1715(___1359 ___1350) { ___2225 numIPts = ___1350->numIPts(); ___2225 numJPts = ___1350->numJPts(); ___2225 numKPts = ___1350->numKPts(); if (___1350->___4690 == ___4702) { if (numIPts == -1 || numJPts == -1 || numKPts == -1) { return -1; } else { if (___1350->___4325 == ___4328) { return numIPts * numJPts * numKPts; } else if (numIPts == 0 && numJPts == 0 && numKPts == 0) { return 0; } else { if (numKPts > 1) --numKPts; else if (numJPts > 1) --numJPts; else if (numIPts > 1) --numIPts; return numIPts * numJPts * numKPts; } } } else if (___1350->___4325 == ___4328) { return numIPts; } else { return numJPts; } } void ___1356(___1359 ___1350) { REQUIRE(VALID_REF(___1350)); { FieldDataDeallocRawData(___1350); } ENSURE(___1718(___1350) == NULL); } void ___1355(___1359 *___1350, ___372     ___1101) {
 #ifndef TECPLOTKERNEL
___4276(___1101);
 #endif
REQUIRE(VALID_REF(___1350)); REQUIRE(VALID_REF(*___1350) || *___1350 == NULL); if (*___1350 != NULL) { { delete *___1350; } *___1350 = NULL; } ENSURE(*___1350 == NULL); } template <typename T> static void copyTypedValueArray(void*       ___1120, ___2225   ___1125, void const* ___3655, ___2225   ___3663, ___2225   ___3657) { REQUIRE(VALID_REF(___1120)); REQUIRE(___1125 >= 0); REQUIRE(VALID_REF(___3655)); REQUIRE(0 <= ___3663 && ___3663 <= ___3657+1); REQUIRE(___1120 != ___3655); size_t const ___2777 = sizeof(T) * (___3657 - ___3663 + 1); if (___2777 != 0) { T const* SrcPtr = ((T const*)___3655) + ___3663; T* DstPtr       = ((T*)___1120) + ___1125; if (DstPtr && SrcPtr) memcpy(DstPtr, SrcPtr, ___2777); } } void ___677( FieldDataType_e ___4333, void*           ___1120, ___2225       ___1125, void const*     ___3655, ___2225       ___3663, ___2225       ___3657) { REQUIRE(VALID_FIELD_DATA_TYPE(___4333) && ___4333 != ___1363); REQUIRE(VALID_REF(___1120)); REQUIRE(___1125 >= 0); REQUIRE(VALID_REF(___3655)); REQUIRE(0 <= ___3663 && ___3663 <= ___3657+1); REQUIRE(___1120 != ___3655); switch (___4333) { case ___1366 : ___476(___1303); case FieldDataType_Double : { ___476(sizeof(uint64_t) == 8 && sizeof(double) == 8); copyTypedValueArray<uint64_t>(___1120, ___1125, ___3655, ___3663, ___3657); } break; case FieldDataType_Float : case FieldDataType_Int32 : { ___476(sizeof(uint32_t) == 4 && sizeof(float) == 4); copyTypedValueArray<uint32_t>(___1120, ___1125, ___3655, ___3663, ___3657); } break; case FieldDataType_Int16 : { ___476(sizeof(uint16_t) == 2); copyTypedValueArray<uint16_t>(___1120, ___1125, ___3655, ___3663, ___3657); } break; case FieldDataType_Byte : { copyTypedValueArray<uint8_t>(___1120, ___1125, ___3655, ___3663, ___3657); } break; default : ___476(___1303); } } void ___3909(FieldDataType_e  ___4333, void            *___3655, ___2225        ___3663, ___2225        ___3657, ___2225        ___3662) { REQUIRE(VALID_FIELD_DATA_TYPE(___4333) && ___4333 != ___1363); REQUIRE(VALID_REF(___3655)); REQUIRE(0 <= ___3663 && ___3663 <= ___3657); REQUIRE(___3662 > 0); switch (___4333) { case ___1366: ___476(___1303); case FieldDataType_Double: { uint64_t *SrcPtr = ((uint64_t *)___3655) + ___3663; uint64_t *SrcPtrEnd = ((uint64_t *)___3655) + ___3657; ___476(sizeof(uint64_t) == 8 && sizeof(double) == 8); while (SrcPtr <= SrcPtrEnd) { ___3368(SrcPtr); SrcPtr += ___3662; } } break; case FieldDataType_Float: case FieldDataType_Int32: { uint32_t *SrcPtr = ((uint32_t *)___3655) + ___3663; uint32_t *SrcPtrEnd = ((uint32_t *)___3655) + ___3657; ___476(sizeof(uint32_t) == 4 && sizeof(float) == 4); while (SrcPtr <= SrcPtrEnd) { ___3365(SrcPtr); SrcPtr += ___3662; } } break; case FieldDataType_Int16: { uint16_t *SrcPtr = ((uint16_t *)___3655) + ___3663; uint16_t *SrcPtrEnd = ((uint16_t *)___3655) + ___3657;
___476(sizeof(uint16_t) == 2); while (SrcPtr <= SrcPtrEnd) { ___3362(SrcPtr); SrcPtr += ___3662; } } break; case FieldDataType_Byte: case ___1363: { } break; default: ___476(___1303); } } void ___3910(FieldDataType_e  ___4333, void            *___3655, ___2225        ___3663, ___2225        ___3657, ___2225        ___3662) { REQUIRE(VALID_FIELD_DATA_TYPE(___4333) && ___4333 != ___1363); REQUIRE(VALID_REF(___3655)); REQUIRE(0 <= ___3663 && ___3663 <= ___3657); REQUIRE(___3662 > 0); switch (___4333) { case ___1366: ___476(___1303); case FieldDataType_Double: { uint8_t *SrcPtr = ((uint8_t *)___3655) + ___3663 * sizeof(uint64_t); uint8_t *SrcPtrEnd = ((uint8_t *)___3655) + ___3657 * sizeof(uint64_t); size_t byte_skip = ___3662 * sizeof(uint64_t); ___476(sizeof(uint64_t) == 8 && sizeof(double) == 8); while (SrcPtr <= SrcPtrEnd) { ___3369(SrcPtr); SrcPtr += byte_skip; } } break; case FieldDataType_Float: case FieldDataType_Int32: { uint8_t *SrcPtr = ((uint8_t *)___3655) + ___3663 * sizeof(uint32_t); uint8_t *SrcPtrEnd = ((uint8_t *)___3655) + ___3657 * sizeof(uint32_t); size_t byte_skip = ___3662 * sizeof(uint32_t); ___476(sizeof(uint32_t) == 4 && sizeof(float) == 4); while (SrcPtr <= SrcPtrEnd) { ___3366(SrcPtr); SrcPtr += byte_skip; } } break; case FieldDataType_Int16: { uint8_t *SrcPtr = ((uint8_t *)___3655) + ___3663 * sizeof(uint16_t); uint8_t *SrcPtrEnd = ((uint8_t *)___3655) + ___3657 * sizeof(uint16_t); size_t byte_skip = ___3662 * sizeof(uint16_t); ___476(sizeof(uint16_t) == 2); while (SrcPtr <= SrcPtrEnd) { ___3363(SrcPtr); SrcPtr += byte_skip; } } break; case FieldDataType_Byte: case ___1363: { } break; default: ___476(___1303); } }
 #define DEBUG_FIELDVALUES_BAD_VALUE 0x11
 #if !defined NO_ASSERTS
template <typename T> inline bool IsFieldDataValueInitialized( ___1359 ___1306, ___2225    ___3247) {
 #ifndef TECPLOTKERNEL
___4276(___1306);
 #endif
 #if defined DEBUG_FIELDVALUES
static unsigned char BadValueStr[] = { DEBUG_FIELDVALUES_BAD_VALUE, DEBUG_FIELDVALUES_BAD_VALUE, DEBUG_FIELDVALUES_BAD_VALUE, DEBUG_FIELDVALUES_BAD_VALUE, DEBUG_FIELDVALUES_BAD_VALUE, DEBUG_FIELDVALUES_BAD_VALUE, DEBUG_FIELDVALUES_BAD_VALUE, DEBUG_FIELDVALUES_BAD_VALUE }; ___476(sizeof(T) <= sizeof(BadValueStr)); ___4276(___3247); return ((sizeof(T) < 4)   || \ memcmp(BadValueStr,((char*)___1718(___1306))+sizeof(T)*(___3247), sizeof(T)) != 0);
 #else
___4276(___1306); ___4276(___3247); return true;
 #endif
}
 #endif
double ___1740(const ___1359 ___1306, ___2225          ___3247) { REQUIRE(VALID_REF(___1306)); REQUIRE(0 <= ___3247 && ___3247 < ___1715(___1306)); REQUIRE(IsFieldDataValueInitialized<float>(___1306, ___3247)); double ___3357 = (double)___1688(___1306)[___3247]; return ___3357; } double ___1739(const ___1359 ___1306, ___2225          ___3247) { REQUIRE(VALID_REF(___1306)); REQUIRE(0 <= ___3247 && ___3247 < ___1715(___1306)); REQUIRE(IsFieldDataValueInitialized<double>(___1306, ___3247)); double ___3357 = ___1682(___1306)[___3247]; return ___3357; } double ___1742(const ___1359 ___1306, ___2225          ___3247) { REQUIRE(VALID_REF(___1306)); REQUIRE(0 <= ___3247 && ___3247 < ___1715(___1306)); REQUIRE(IsFieldDataValueInitialized<int32_t>(___1306, ___3247)); double ___3357 = (double)___1703(___1306)[___3247]; return ___3357; } double ___1741(const ___1359 ___1306, ___2225          ___3247) { REQUIRE(VALID_REF(___1306)); REQUIRE(0 <= ___3247 && ___3247 < ___1715(___1306)); REQUIRE(IsFieldDataValueInitialized<int16_t>(___1306, ___3247)); double ___3357 = (double)___1697(___1306)[___3247]; return ___3357; } double ___1738(const ___1359 ___1306, ___2225          ___3247) { REQUIRE(VALID_REF(___1306)); REQUIRE(___1724(___1306) == FieldDataType_Byte); REQUIRE(0 <= ___3247 && ___3247 < ___1715(___1306)); REQUIRE(IsFieldDataValueInitialized<uint8_t>(___1306, ___3247)); double ___3357 = (double)___1679(___1306)[___3247]; return ___3357; } double ___1737(const ___1359 ___1306, ___2225          ___3247) { REQUIRE(VALID_REF(___1306)); REQUIRE(___1724(___1306) == ___1363); REQUIRE(0 <= ___3247 && ___3247 < ___1715(___1306)); REQUIRE(IsFieldDataValueInitialized<uint8_t>(___1306, ___3247 / 8)); ___2225 ByteOffset = ___3247 / 8; uint8_t    BitMask    = (01 << (___3247 % 8)); uint8_t *byte_array = ___1679(___1306); double ___3357 = (byte_array[ByteOffset] & BitMask) ? 1.0 : 0.0; return ___3357; } ___1381 DetermineFieldDataGetFunction(___1359 ___1349) { REQUIRE(VALID_REF(___1349)); ___1381 ___3357 = NULL; switch (___1724(___1349)) { case FieldDataType_Float:  ___3357 = ___1740;  break; case FieldDataType_Double: ___3357 = ___1739; break; case FieldDataType_Int32:  ___3357 = ___1742;  break; case FieldDataType_Int16:  ___3357 = ___1741;  break; case FieldDataType_Byte:   ___3357 = ___1738;   break; case ___1363:    ___3357 = ___1737;    break; default: ___476(___1303); break; } return ___3357; } static void SetFieldValueForFloat(___1359 ___1306, ___2225    ___3247, double       ___4296) { REQUIRE(VALID_REF(___1306)); REQUIRE(0 <= ___3247 && ___3247 < ___1715(___1306)); REQUIRE("val can have any value"); ___1688(___1306)[___3247] = ___648(___4296); ENSURE(IsFieldDataValueInitialized<float>(___1306, ___3247)); } static void SetFieldValueForDouble(___1359 ___1306, ___2225    ___3247, double       ___4296) { REQUIRE(VALID_REF(___1306)); REQUIRE(0 <= ___3247 && ___3247 < ___1715(___1306));
REQUIRE("val can have any value"); ___1682(___1306)[___3247] = ___487(___4296); ENSURE(IsFieldDataValueInitialized<double>(___1306, ___3247)); } static void SetFieldValueForInt32(___1359 ___1306, ___2225    ___3247, double       ___4296) { REQUIRE(VALID_REF(___1306)); REQUIRE(0 <= ___3247 && ___3247 < ___1715(___1306)); REQUIRE("val can have any value"); ___1703(___1306)[___3247] = ___650(___4296); ENSURE(IsFieldDataValueInitialized<int32_t>(___1306, ___3247)); } static void SetFieldValueForInt16(___1359 ___1306, ___2225    ___3247, double       ___4296) { REQUIRE(VALID_REF(___1306)); REQUIRE(0 <= ___3247 && ___3247 < ___1715(___1306)); REQUIRE("val can have any value"); ___1697(___1306)[___3247] = ___649(___4296); ENSURE(IsFieldDataValueInitialized<int16_t>(___1306, ___3247)); } static void SetFieldValueForByte(___1359 ___1306, ___2225    ___3247, double       ___4296) { REQUIRE(VALID_REF(___1306)); REQUIRE(___1724(___1306) == FieldDataType_Byte); REQUIRE(0 <= ___3247 && ___3247 < ___1715(___1306)); REQUIRE("val can have any value"); ___1679(___1306)[___3247] = CONVERT_DOUBLE_TO_UINT8(___4296); ENSURE(IsFieldDataValueInitialized<uint8_t>(___1306, ___3247)); } static void SetFieldValueForBit(___1359 ___1306, ___2225    ___3247, double       ___4296) { REQUIRE(VALID_REF(___1306)); REQUIRE(___1724(___1306) == ___1363); REQUIRE(0 <= ___3247 && ___3247 < ___1715(___1306)); REQUIRE("val can have any value"); ___2225 ByteOffset = ___3247 / 8; uint8_t   BitMask    = (01 << (___3247 % 8)); if (___4296 < 1.0) ___1679(___1306)[ByteOffset] &= ~BitMask; else ___1679(___1306)[ByteOffset] |= BitMask; ENSURE(IsFieldDataValueInitialized<uint8_t>(___1306, ___3247 / 8)); } ___1382 DetermineFieldDataSetFunction(___1359 ___1349) { REQUIRE(VALID_REF(___1349)); ___1382 ___3357 = NULL; switch (___1724(___1349)) { case FieldDataType_Float:  ___3357 = SetFieldValueForFloat;  break; case FieldDataType_Double: ___3357 = SetFieldValueForDouble; break; case FieldDataType_Int32:  ___3357 = SetFieldValueForInt32;  break; case FieldDataType_Int16:  ___3357 = SetFieldValueForInt16;  break; case FieldDataType_Byte:   ___3357 = SetFieldValueForByte;   break; case ___1363:    ___3357 = SetFieldValueForBit;    break; default: ___476(___1303); break; } return ___3357; }
 #if !defined TECPLOTKERNEL
namespace {
 #endif
int64_t ___1357(___2225       ___2840, FieldDataType_e ___905) { int64_t ___3357 = 0; REQUIRE(___2840 >= 0); REQUIRE(VALID_FIELD_DATA_TYPE(___905)); switch (___905) { case FieldDataType_Float:  ___3357 = ((int64_t)___2840)*sizeof(float);         break; case FieldDataType_Double: ___3357 = ((int64_t)___2840)*sizeof(double);        break; case FieldDataType_Int32:  ___3357 = ((int64_t)___2840)*sizeof(int32_t);       break; case FieldDataType_Int16:  ___3357 = ((int64_t)___2840)*sizeof(int16_t);       break; case FieldDataType_Byte:   ___3357 = ((int64_t)___2840)*sizeof(uint8_t);       break; case ___1363:    ___3357 = ((int64_t)(___2840+7)/8)*sizeof(uint8_t); break; default: ___476(___1303); break; } ENSURE(___3357 >= 0); return ___3357; }
 #if !defined TECPLOTKERNEL
}
 #endif
 #if defined ___1993 || defined HPUX || defined ___3891
 # define SIZEOF_LARGEST_OBJECT_TO_ALIGN sizeof(int64_t)
 #else
 # define SIZEOF_LARGEST_OBJECT_TO_ALIGN sizeof(int32_t)
 #endif
void FieldDataReinitializeMetaData( ___1359    ___1349, ZoneType_e      ___4690, FieldDataType_e dataType, ValueLocation_e ___4324, ___372       isReadOnly, ___372       ___2062) { REQUIRE(VALID_REF(___1349)); REQUIRE(VALID_ENUM(___4690, ZoneType_e)); REQUIRE(VALID_FIELD_DATA_TYPE(dataType)); REQUIRE(VALID_ENUM(___4324, ValueLocation_e)); REQUIRE(VALID_BOOLEAN(isReadOnly)); REQUIRE(VALID_BOOLEAN(___2062)); REQUIRE(IMPLICATION(___2062, isReadOnly)); ___1354(___1349); ___1349->___4690      = ___4690; ___1349->___4333     = dataType; ___1349->___4325 = ___4324; { ___4276(isReadOnly); ___4276(___2062); ___1349->___1779 = DetermineFieldDataGetFunction(___1349); ___1349->___3504 = DetermineFieldDataSetFunction(___1349); } ENSURE(___1718(___1349) == NULL); }
 #if !defined TECPLOTKERNEL
namespace {
 #endif
___372 ___2313( ___1359 ___1350, ___372    ___3569) { REQUIRE(VALID_REF(___1350)); REQUIRE(___1724(___1350) != ___1367); REQUIRE(___1718(___1350) == NULL); REQUIRE(VALID_BOOLEAN(___3569)); int64_t ActualBytesNeeded = ___1357(___1715(___1350), ___1724(___1350)); size_t  BytesToAllocate   = (size_t)ActualBytesNeeded; ___476(sizeof(size_t) == 4 || sizeof(size_t) == 8); ___372 ___2038 = (___1715(___1350) <= ___2371 && IMPLICATION(sizeof(size_t) == 4, ActualBytesNeeded <= (int64_t)0xffffffff)); if (___2038) { if (___1715(___1350) > 0) { ___3485(___1350, (void*)___23(BytesToAllocate, char, "FieldData's Data"));
 #if defined DEBUG_FIELDVALUES
{ if (___1718(___1350) != NULL) memset(___1718(___1350), DEBUG_FIELDVALUES_BAD_VALUE, BytesToAllocate); }
 #endif
if (___1724(___1350) == ___1363 && ___1718(___1350) != NULL) ((char*)___1718(___1350))[BytesToAllocate-1] = '\0'; } ___2038 = (___1715(___1350) == 0 || ___1718(___1350) != NULL); if (!___2038 && ___3569) ___2887(); } else if (___3569) { ___1175(___4215("Storage limit (%lld) exceeded for a single variable."), (lldfmt_t)___2371); } ENSURE(VALID_REF(___1718(___1350)) || ___1718(___1350) == NULL); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; }
 #if !defined TECPLOTKERNEL
}
 #endif
___372 ___1353( ___1359 ___1350, ___372    ___3569) { REQUIRE(VALID_REF(___1350)); REQUIRE(___1724(___1350) != ___1367); REQUIRE(___1718(___1350) == NULL); REQUIRE(VALID_BOOLEAN(___3569)); ___372 ___2037 = ___2313(___1350, ___3569); ENSURE(VALID_REF(___1718(___1350)) || ___1718(___1350) == NULL); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; }
 #if !defined NO_ASSERTS
 #endif
___1359 ___28(___2225       ___2840, FieldDataType_e ___4234, ___372       ___3569) { REQUIRE(___2840 >= 0); REQUIRE(VALID_FIELD_DATA_TYPE(___4234)); REQUIRE(VALID_BOOLEAN(___3569)); ___1359 ___3357 = ___1352(___2840,1,1); if (___3357 != NULL) { ___372 const isReadOnly = ___1303; ___372 const ___2062  = ___1303; FieldDataReinitializeMetaData(___3357, ___4702, ___4234, ___4328, isReadOnly, ___2062); if (!___1353(___3357, ___3569)) ___1355(&___3357, ___1303); } else if (___3569) { ___2887(); } ENSURE(VALID_REF(___3357) || ___3357 == NULL); ENSURE(IMPLICATION(___3357 != NULL, (___1715(___3357) >= 0                     && IMPLICATION(___1715(___3357) != 0, VALID_REF(___1718(___3357))) && VALID_FIELD_DATA_TYPE(___1724(___3357))))); return ___3357; } void ___936(___1359 *FieldDataRef) { ___1355(FieldDataRef, ___1303); }
 #if 0 
 #endif
void ___673(___1359  ___1119, ___2225     ___1122, ___1359  ___3654, ___2225     ___3659) { REQUIRE(VALID_REF(___1119)); REQUIRE(VALID_REF(___3654)); REQUIRE(___1122 >= 0 && ___1122 < ___1715(___1119) && ___3659 >= 0 && ___3659 < ___1715(___3654)); ___372 DoBruteForceCopy = ___4224; if (___2017(___3654) && ___2017(___1119) && ___1724(___3654) == ___1724(___1119)) { switch (___1724(___3654)) { case ___1366 : ___476(___1303); case FieldDataType_Double : { ___476(sizeof(uint64_t) == 8 && sizeof(double) == 8); uint64_t *dst_ptr = ___1676(___1119) + ___1122; uint64_t *src_ptr = ___1676(___3654) + ___3659; *dst_ptr = *src_ptr; DoBruteForceCopy = ___1303; } break; case FieldDataType_Float : case FieldDataType_Int32 : { ___476(sizeof(uint32_t) == 4 && sizeof(float) == 4); uint32_t *dst_ptr = ___1673(___1119) + ___1122; uint32_t *src_ptr = ___1673(___3654) + ___3659; *dst_ptr = *src_ptr; DoBruteForceCopy = ___1303; } break; case FieldDataType_Int16 : { ___476(sizeof(uint16_t) == 2); uint16_t *dst_ptr = ___1670(___1119) + ___1122; uint16_t *src_ptr = ___1670(___3654) + ___3659; *dst_ptr = *src_ptr; } break; case FieldDataType_Byte : { ___1679(___1119)[___1122] = ___1679(___3654)[___3659]; DoBruteForceCopy = ___1303; } break; case ___1363 : break; default : ___476(___1303); } } if (DoBruteForceCopy) { ___3488(___1119, ___1122, ___1733(___3654, ___3659)); } } void SetFieldDataArrayBytesToZero(___1359 ___1306) { REQUIRE(VALID_REF(___1306)); ___2225 NumBytesToMemSet = 0; ___2225 const ___2840 = ___1715(___1306); switch (___1724(___1306)) { case ___1366 : ___476(___1303); case FieldDataType_Double : { ___476(sizeof(uint64_t) == 8 && sizeof(double) == 8); NumBytesToMemSet = ___2840 * static_cast<___2225>(sizeof(int64_t)); } break; case FieldDataType_Int32 : case FieldDataType_Float : { ___476(sizeof(uint32_t) == 4 && sizeof(float) == 4); NumBytesToMemSet = ___2840 * static_cast<___2225>(sizeof(int32_t)); } break; case FieldDataType_Int16 : { ___476(sizeof(uint16_t) == 2); NumBytesToMemSet = ___2840 * static_cast<___2225>(sizeof(int16_t)); } break; case FieldDataType_Byte : { NumBytesToMemSet = ___2840 * static_cast<___2225>(sizeof(uint8_t)); } break; case ___1363 : { NumBytesToMemSet = ((___2840 + 7) / 8) * static_cast<___2225>(sizeof(uint8_t)); } break; default : { ___476(___1303); } break; } memset((char*)___1730(___1306), 0, NumBytesToMemSet); } void ___3484(___1359 ___1306) { REQUIRE(VALID_REF(___1306)); if (___2017(___1306)) { SetFieldDataArrayBytesToZero(___1306); } else { ___2225 const ___2840 = ___1715(___1306); for (___2225 ___1839 = 0; ___1839 < ___2840; ___1839++) ___3488(___1306, ___1839, 0.0); } }
