#include "stdafx.h"
#include "MASTER.h"
#include "ThirdPartyHeadersBegin.h"
#include <memory>
#include "ThirdPartyHeadersEnd.h"
 #define ___854
#include "GLOBAL.h"
#include "CodeContract.h"
#include "TASSERT.h"
#include "ALLOC.h"
#include "AUXDATA.h"
#include "DATASET.h"
#include "FILESTREAM.h"
#include "TecplotVersion.h"
#include "FileSystem.h"
#include "TecplotFileZoneFormat.h"
#include "GEOM2.h"
#include "GEOM.h"
#include "INPUT.h"
#include "SET.h"
#include "TEXT.h"
#include "DATAIO4.h"
#include "DATASET0.h"
#include "CHARTYPE.h"
#include "STRUTIL.h"
#include "ARRLIST.h"
#include "STRLIST.h"
#include "Q_MSG.h"
 #if defined ___1992
#include <ieeefp.h>
 #endif
using namespace tecplot;
 #if defined MSWIN
 #if !defined TECPLOTKERNEL
 #pragma warning(disable : 4244)
 #endif
 #pragma warning(disable: 4789)
 #endif
 #if defined DECALPHA || defined ___532
 #define _IEEE_FP_INEXACT
 #define _IEEE_FP
 #endif
 #if defined SUN41
 #define SEEK_SET 0
 #define SEEK_CUR 1
 #define SEEK_END 2
 #endif
static char FilterFloatChar(float X) { char C; if (((X >= 32.0) && (X <= 127.0)) || ((X >= 160.0) && (X <= 255.0)) || (X == 0.0)) C = (char)X; else C = '?'; return (C); } double ___1760(___1403   *___1399, FieldDataType_e ___1362, double          VMin, double          VMax, ___372      *___2038) { double X = 0.0; REQUIRE(VALID_REF(___2038) && VALID_BOOLEAN(*___2038)); REQUIRE(!(*___2038) || VALID_FIELD_DATA_TYPE(___1362)); REQUIRE(!(*___2038) || VALID_REF(___1399)); if (*___2038) { switch (___1362) { case FieldDataType_Float : { float XX; *___2038 = (___4196(&XX, 4, 1, ___1399->File) == 1); if (!___1399->___2005) ___3365(&XX); if (*___2038) X = XX; else X = 0.0; } break; case FieldDataType_Double : { double XX; *___2038 = (___4196(&XX, sizeof(double), 1, ___1399->File) == 1); if (!___1399->___2005) ___3368(&XX); if (*___2038) X = XX; else X = 0.0; } break; case FieldDataType_Int32  : { int32_t ___2163; *___2038 = (___4196(&___2163, sizeof(int32_t), 1, ___1399->File) == 1); if (!___1399->___2005) ___3365(&___2163); if (*___2038) X = (double)___2163; } break; case FieldDataType_Int16  : { int16_t S; *___2038 = (___4196(&S, sizeof(int16_t), 1, ___1399->File) == 1); if (!___1399->___2005) ___3362(&S); if (*___2038) X = (double)S; } break; case FieldDataType_Byte  : { uint8_t B; *___2038 = (___4196(&B, sizeof(uint8_t), 1, ___1399->File) == 1); if (*___2038) X = (double)B; } break; case ___1363 : { uint8_t B; *___2038 = (___4196(&B, sizeof(uint8_t), 1, ___1399->File) == 1); if (*___2038) X = (double)(B & (uint8_t)01); } break; default: ___476(___1303); break; } if (*___2038) { if ((X < VMin) || (X > VMax)) { *___2038 = ___1303; } } } return X; } template <typename SRC_INT_TYPE> SRC_INT_TYPE ___1748( ___1403* ___1398, short         pltFileVersion, SRC_INT_TYPE  minValue, SRC_INT_TYPE  maxValue, ___372*    ___2037) { REQUIRE(VALID_REF(___2037) && VALID_BOOLEAN(*___2037)); REQUIRE(!(*___2037) || (0 < pltFileVersion && pltFileVersion <= TecplotSDKBinaryFileVersion)); REQUIRE(!(*___2037) || (VALID_REF(___1398) && VALID_REF(___1398->File))); REQUIRE(!(*___2037) || minValue <= maxValue); SRC_INT_TYPE intValue = 0; if (*___2037) { if (pltFileVersion <= 63) { if (*___2037) { float X = (float)___1760(___1398, FieldDataType_Float, (double)minValue - 1.0e-10, (double)maxValue + 1.0e-10, ___2037); if (*___2037) { if (___1(X) < (float)___2180) intValue = (SRC_INT_TYPE)X; else *___2037 = ___1303; } else *___2037 = ___1303; } } else { *___2037 = (___4196(&intValue, sizeof(intValue), 1, ___1398->File) == 1); if (*___2037 && !___1398->___2005) { if (sizeof(intValue) == 2) ___3362(&intValue); else if (sizeof(intValue) == 4) ___3365(&intValue); else if (sizeof(intValue) == 8) ___3368(&intValue); } } if (static_cast<___2225>(intValue) < minValue || maxValue < static_cast<___2225>(intValue)) *___2037 = ___1303; } return intValue; } template int32_t ___1748<int32_t>(___1403*, short, int32_t, int32_t, ___372*);
template int64_t ___1748<int64_t>(___1403*, short, int64_t, int64_t, ___372*); static ___372 ReallocString(char      **___3811, size_t    NewLength) { ___372 ___2038; char *___2698; REQUIRE(VALID_REF(___3811)); REQUIRE(*___3811 == NULL || VALID_REF(*___3811)); REQUIRE((*___3811 != NULL && NewLength >= strlen(*___3811)) || (*___3811 == NULL)); ___2698 = ___23(NewLength + 1, char, "reallocated string"); ___2038 = (___2698 != NULL); if (___2038) { if (*___3811 == NULL) { ___2698[0] = '\0'; } else { strcpy(___2698, *___3811); ___1528(*___3811, "old string"); } *___3811 = ___2698; } ENSURE(VALID_BOOLEAN(___2038)); ENSURE(IMPLICATION(___2038, VALID_REF(*___3811))); return ___2038; } namespace { ___372 ___3287(___1403  *___1399, short          ___2102, int            ___2349, char         **TargetStr, ___372      ___3201) { REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(0 < ___2102 && ___2102 <= TecplotSDKBinaryFileVersion); REQUIRE(IMPLICATION(___2102 < 63 || ___3201, ___2349 >= 0)); REQUIRE(IMPLICATION(___3201, VALID_REF(TargetStr))); REQUIRE(VALID_BOOLEAN(___3201)); ___372 ___2038 = ___4224; if (___2102 < 63) { float X; if (___3201) { *TargetStr = ___23(___2349 + 1, char, "target string"); ___2038 = (*TargetStr != NULL); } if (___2038) { ___2225 ___1830; for (___1830 = 0; ___2038 && ___1830 < ___2349; ___1830++) { X = (float)___1760(___1399, FieldDataType_Float, 0.0, 127.0, &___2038); if (!___2038) break; if (___3201) (*TargetStr)[___1830] = FilterFloatChar(X); } if (___3201) (*TargetStr)[___1830] = '\0'; } else { ___1175(___4215("Cannot allocate memory for string during read", "'string' meaning the computer science data type")); } } else { size_t const MAX_STRBUFFER_LEN = 4095; static char  StrBuffer[MAX_STRBUFFER_LEN+1]; size_t       StrBufferLen = 0; size_t       TargetStrLen = 0; int          ___1830 = 0; ___2225    CharValue = 0; if (___3201) *TargetStr = NULL; do { CharValue = ___1748<int32_t>(___1399, ___2102, 0, 255, &___2038); if (___2038 && ___3201) { if (CharValue != '\0' && (___1830 < ___2349 || ___2349 == 0)) { StrBuffer[StrBufferLen] = (char)CharValue; StrBufferLen++; } if (CharValue == '\0' || StrBufferLen == MAX_STRBUFFER_LEN) { if (StrBufferLen != 0 || *TargetStr == NULL) { StrBuffer[StrBufferLen] = '\0'; TargetStrLen += StrBufferLen; ___2038 = ReallocString(TargetStr, TargetStrLen); if (___2038) strcat(*TargetStr, StrBuffer); StrBufferLen = 0; } } } ___1830++; } while (___2038 && (char)CharValue != '\0'); if (!___2038       && ___3201 && *TargetStr != NULL) { ___1528(*TargetStr, "failed read string"); *TargetStr = NULL; } } ENSURE(IMPLICATION(___3201, (VALID_REF(*TargetStr) || *TargetStr == NULL))); ENSURE(VALID_BOOLEAN(___2038)); return (___2038); } } namespace { ___372 ___3287(___1403* ___1398, short         iVersion, int           maxCharacters, std::string*  targetStrPtr, ___372     processData) { REQUIRE(VALID_REF(___1398) && VALID_REF(___1398->File));
REQUIRE(0 < iVersion && iVersion <= TecplotSDKBinaryFileVersion); REQUIRE(IMPLICATION(iVersion < 63 || processData, maxCharacters >= 0)); REQUIRE(IMPLICATION(processData, VALID_REF(targetStrPtr) && targetStrPtr->empty())); REQUIRE(VALID_BOOLEAN(processData)); ___372 ___2037 = ___4224; char* targetCstr = NULL; try { ___2037 = ___3287(___1398, iVersion, maxCharacters, processData ? &targetCstr : NULL, processData); if (___2037 && processData) *targetStrPtr = targetCstr; } catch (std::bad_alloc const&) { ___2037 = ___1303; } if (targetCstr != NULL) ___1528(targetCstr, "C string"); ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } } static void ReadDoubleBlock(___1403 *___1399, ___372     ___1097, double       *___417, ___2225     ___3683, ___2225     ___2840, ___372    *___2038) { if (___1097) { double *DPtr = ___417 + ___3683; *___2038 = (___4196(DPtr, sizeof(double), ___2840, ___1399->File) == (size_t)___2840); if (!___1399->___2005 && *___2038) { ___2225 N; for (N = 0; N < ___2840; N++) ___3368(&DPtr[N]); } } else *___2038 = (___4198(___1399->File, ___2840 * sizeof(double), SEEK_CUR) == 0); } static void ReadFloatBlock(___1403 *___1399, ___372     ___1097, float        *___417, ___2225     ___3683, ___2225     ___2840, ___372    *___2038) { if (___1097) { float *FPtr = ___417 + ___3683; *___2038 = (___4196(FPtr, sizeof(float), ___2840, ___1399->File) == (size_t)___2840); if (!___1399->___2005 && *___2038) { ___2225 N; for (N = 0; N < ___2840; N++) ___3365(&FPtr[N]); } } else *___2038 = (___4198(___1399->File, ___2840 * sizeof(float), SEEK_CUR) == 0); } static void ReadBitBlock(___1403 *___1399, ___372     ___1097, uint8_t       *___417, ___2225     ___2840, ___372    *___2038) { REQUIRE(VALID_REF(___1399)); REQUIRE(VALID_BOOLEAN(___1097)); REQUIRE(IMPLICATION(___1097, VALID_REF(___417))); REQUIRE((___1097 == ___4224) == (___417 != NULL)); REQUIRE(___2840 > 0); REQUIRE(VALID_REF(___2038) && VALID_BOOLEAN(*___2038)); ___2225 const NumBytes = (___2840 + 7) / 8; if (___1097) { *___2038 = (___4196(___417, sizeof(uint8_t), NumBytes, ___1399->File) == (size_t)NumBytes); } else *___2038 = (___4198(___1399->File, NumBytes * sizeof(uint8_t), SEEK_CUR) == 0); ENSURE(VALID_BOOLEAN(*___2038)); } void ___3275(___1403 *___1399, ___372     ___1097, uint8_t       *___417, ___2225     ___3683, ___2225     ___2840, ___372    *___2038) { REQUIRE(VALID_REF(___1399)); REQUIRE(VALID_BOOLEAN(___1097)); REQUIRE(IMPLICATION(___1097, VALID_REF(___417))); REQUIRE((___1097 == ___4224) == (___417 != NULL)); REQUIRE(___3683 >= 0); REQUIRE(___2840 > 0); REQUIRE(VALID_REF(___2038) && VALID_BOOLEAN(*___2038)); if (___1097) { *___2038 = (___4196(___417 + ___3683, sizeof(uint8_t), ___2840, ___1399->File) == (size_t)___2840); } else *___2038 = (___4198(___1399->File, ___2840 * sizeof(uint8_t), SEEK_CUR) == 0); ENSURE(VALID_BOOLEAN(*___2038)); } void ___3288(___1403 *___1399,
___372     ___1097, int16_t      *___417, ___2225     ___3683, ___2225     ___2840, ___372    *___2038) { REQUIRE(VALID_REF(___1399)); REQUIRE(VALID_BOOLEAN(___1097)); REQUIRE(IMPLICATION(___1097, VALID_REF(___417))); REQUIRE((___1097 == ___4224) == (___417 != NULL)); REQUIRE(___3683 >= 0); REQUIRE(___2840 > 0); REQUIRE(VALID_REF(___2038) && VALID_BOOLEAN(*___2038)); if (___1097) { int16_t *___1984 = ___417 + ___3683; *___2038 = (___4196(___1984, sizeof(int16_t), ___2840, ___1399->File) == (size_t)___2840); if (!___1399->___2005 && *___2038) { ___2225 N; for (N = 0; N < ___2840; N++) ___3362(&___1984[N]); } } else *___2038 = (___4198(___1399->File, ___2840 * sizeof(int16_t), SEEK_CUR) == 0); ENSURE(VALID_BOOLEAN(*___2038)); } void ___3289(___1403 *___1399, ___372     ___1097, int32_t      *___417, ___2225     ___3683, ___2225     ___2840, ___372    *___2038) { REQUIRE(VALID_REF(___1399)); REQUIRE(VALID_BOOLEAN(___1097)); REQUIRE(IMPLICATION(___1097, VALID_REF(___417))); REQUIRE((___1097 == ___4224) == (___417 != NULL)); REQUIRE(___3683 >= 0); REQUIRE(___2840 > 0); REQUIRE(VALID_REF(___2038) && VALID_BOOLEAN(*___2038)); if (___1097) { ___2225 EndIndex = ___3683 + ___2840; for (___2225 ValueIndex = ___3683; *___2038 && ValueIndex < EndIndex; ValueIndex++) { int16_t ___4313; *___2038 = (___4196(&___4313, sizeof(int16_t), 1, ___1399->File) == 1); if (!___1399->___2005 && *___2038) ___3362(&___4313); ___417[ValueIndex] = (int32_t)___4313; } } else *___2038 = (___4198(___1399->File, ___2840 * sizeof(int16_t), SEEK_CUR) == 0); ENSURE(VALID_BOOLEAN(*___2038)); } void ___3290(___1403 *___1399, ___372     ___1097, int32_t      *___417, ___2225     ___3683, ___2225     ___2840, ___372    *___2038) { REQUIRE(VALID_REF(___1399)); REQUIRE(VALID_BOOLEAN(___1097)); REQUIRE(IMPLICATION(___1097, VALID_REF(___417))); REQUIRE((___1097 == ___4224) == (___417 != NULL)); REQUIRE(___3683 >= 0); REQUIRE(___2840 > 0); REQUIRE(VALID_REF(___2038) && VALID_BOOLEAN(*___2038)); if (___1097) { int32_t* int32Ptr = ___417 + ___3683; size_t const freadResult = ___4196(int32Ptr, sizeof(int32_t), ___2840, ___1399->File); *___2038 = (freadResult == (size_t)___2840); if (!___1399->___2005 && *___2038) { for (___2225 N = 0; N < ___2840; N++) ___3365(&int32Ptr[N]); } } else *___2038 = (___4198(___1399->File, ___2840 * sizeof(int32_t), SEEK_CUR) == 0); ENSURE(VALID_BOOLEAN(*___2038)); } void ReadInt64Block(___1403 *___1399, ___372     ___1097, int64_t      *___417, ___2225     ___3683, ___2225     ___2840, ___372    *___2038) { REQUIRE(VALID_REF(___1399)); REQUIRE(VALID_BOOLEAN(___1097)); REQUIRE(IMPLICATION(___1097, VALID_REF(___417))); REQUIRE((___1097 == ___4224) == (___417 != NULL)); REQUIRE(___3683 >= 0); REQUIRE(___2840 > 0); REQUIRE(VALID_REF(___2038) && VALID_BOOLEAN(*___2038)); if (___1097) { int64_t *___1984 = ___417 + ___3683; *___2038 = (___4196(___1984,
sizeof(int64_t), ___2840, ___1399->File) == (size_t)___2840); if (!___1399->___2005 && *___2038) { ___2225 N; for (N = 0; N < ___2840; N++) ___3368(&___1984[N]); } } else *___2038 = (___4198(___1399->File, ___2840 * sizeof(int64_t), SEEK_CUR) == 0); ENSURE(VALID_BOOLEAN(*___2038)); } void ___3294(___1403   *___1399, ___372       ___1097, void           *___417, FieldDataType_e ___1362, ___2225       ___3683, ___2225       ___2840, ___372      *___2038) { REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(VALID_BOOLEAN(___1097)); REQUIRE(!___1097 || VALID_REF(___417)); REQUIRE(VALID_FIELD_DATA_TYPE(___1362)); REQUIRE(___3683 >= 0); REQUIRE(___2840 >= 0); REQUIRE(VALID_REF(___2038) && VALID_BOOLEAN(*___2038)); switch (___1362) { case FieldDataType_Float : { ReadFloatBlock(___1399, ___1097, (float *)___417, ___3683, ___2840, ___2038); } break; case FieldDataType_Double : { ReadDoubleBlock(___1399, ___1097, (double *)___417, ___3683, ___2840, ___2038); } break; case ___1363 : { if (___3683 != 0) { ___1175(___4215("Internal Error: Attempt to read bit data at non-zero offset", "see Tecplot User's manual for a definition of 'bit' data")); *___2038 = ___1303; } else ReadBitBlock(___1399, ___1097, (uint8_t *)___417, ___2840, ___2038); } break; case FieldDataType_Byte : { ___3275(___1399, ___1097, (uint8_t *)___417, ___3683, ___2840, ___2038); } break; case FieldDataType_Int16 : { ___3288(___1399, ___1097, (int16_t *)___417, ___3683, ___2840, ___2038); } break; case FieldDataType_Int32 : { ___3290(___1399, ___1097, (int32_t *)___417, ___3683, ___2840, ___2038); } break; case ___1364 : case ___1366 : default: ___476(___1303); break; } ENSURE(VALID_BOOLEAN(*___2038)); } void ___3274(___1403   *___1399, ___1359    ___1350, ___372       ___1097, FieldDataType_e ___1365, ___2225       ___3683, ___2225       EndIndex, ___372      *___2038) { REQUIRE(VALID_REF(___2038) && VALID_BOOLEAN(*___2038)); REQUIRE(IMPLICATION(___2038, VALID_REF(___1399))); REQUIRE(IMPLICATION(___2038, VALID_FIELD_DATA_TYPE(___1365))); REQUIRE(VALID_BOOLEAN(___1097)); REQUIRE(IMPLICATION(___1097, VALID_REF(___1350))); ___372 ReadByBlock = IMPLICATION(___1097, ___1724(___1350) == ___1365); REQUIRE(ReadByBlock || (___1365 != ___1363)); if (*___2038) { ___2225 ___2840 = EndIndex - ___3683 + 1; if (ReadByBlock) { void *data_array; if (___1097) data_array = ___1730(___1350); else data_array = NULL; ___3294(___1399, ___1097, data_array, ___1365, ___3683, ___2840, ___2038); } else { ___2225 N; for (N = 0; *___2038 && (N < ___2840); N++) { double D = ___1760(___1399, ___1365, -___2177, ___2177, ___2038); if (___1097) ___3488(___1350, N + ___3683, D); } } } } void ___3276(___1403         *___841,
___1359          ___1350, FieldDataType_e       ___1365, ___2225             ___2808, ___2225             ___2813, ___2225             ___2816, ___372            *___2038) { REQUIRE(IMPLICATION(*___2038, VALID_REF(___841))); REQUIRE(IMPLICATION(*___2038, VALID_FIELD_DATA_TYPE(___1365))); REQUIRE(VALID_REF(___1350)); REQUIRE(___2808 >= 0); REQUIRE(___2813 >= 0); REQUIRE(___2816 >= 0); REQUIRE(VALID_REF(___2038) && VALID_BOOLEAN(*___2038)); if (*___2038) { ___2225 ___2104, ___2133; ___2225 ___2805  = ___2808 * ___2813; ___2225 ___1837      = MAX(___2808 - 1, 1); ___2225 ___2109      = MAX(___2813 - 1, 1); ___2225 ___2137      = MAX(___2816 - 1, 1); ___2225 ___2840 = (___1837 * ___2109 * ___2137); ___372 IsLinear  = ((___2813 == 1 && ___2816 == 1) || (___2808 == 1 && ___2816 == 1) || (___2808 == 1 && ___2813 == 1)); if (IsLinear) ___3274(___841, ___1350, ___4224, ___1365, 0, ___2840 - 1, ___2038); else for (___2133 = 0; ___2133 < ___2137 && ___2038; ___2133++) for (___2104 = 0; ___2104 < ___2109 && ___2038; ___2104++) { ___2225 ___461 = 0 + (___2104 * ___2808) + (___2133 * ___2805); ___3274(___841, ___1350, ___4224, ___1365, ___461, ___461 + ___1837 - 1, ___2038); } } ENSURE(VALID_BOOLEAN(*___2038)); } static void AdjustCustomColor(short         ___2102, ___514 *___351) { REQUIRE(0 < ___2102 && ___2102 <= TecplotSDKBinaryFileVersion); REQUIRE(VALID_REF(___351)); if ((___2102 < 70) && (*___351 >= 15) && (*___351 <= 22)) *___351 -= 7; } ___372 ___3285(___1403   *___1399, short           ___2102, char          **___901, DataFileType_e *___1406, int            *NumVars, ___3837  *___4364) { ___1170   ___716; ___372    ___2038 = ___4224; REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(0 < ___2102 && ___2102 <= TecplotSDKBinaryFileVersion); REQUIRE(VALID_REF(___901) || (___901 == NULL)); REQUIRE(VALID_REF(___1406) || (___1406 == NULL)); REQUIRE(VALID_REF(NumVars)); REQUIRE(VALID_REF(___4364) || (___4364 == NULL)); *NumVars      = 0; if (___901) *___901 = NULL; if (___2102 >= 109) { if (___1406) *___1406 = (DataFileType_e)___1748<int32_t>(___1399, ___2102, 0, ___846, &___2038); else ___1748<int32_t>(___1399, ___2102, 0, ___846, &___2038); } if (___3287(___1399, ___2102, ((___2102 < 63) ? 80 : ___2353), ___901, (___372)(___901 != NULL))) { if (___901) ___4223(*___901); *NumVars = ___1748<int32_t>(___1399, ___2102, 0, ___2389, &___2038); } else ___2038 = ___1303; if (___2038 && (*NumVars > ___2380)) { ___1175(___4215("Too many variables")); ___2038 = ___1303; } if (___2038 && ___4364) { if (*NumVars > 0) { *___4364 = ___3819(); ___2038 = (*___4364 != NULL); if (___2038) ___2038 = ___3841(*___4364, *NumVars - 1, NULL);
if (!___2038) { if (*___4364 != NULL) ___3826(___4364); ___1175(___4215("Out of space while allocating var names")); } } } for (___716 = 0; ___2038 && (___716 < *NumVars); ___716++) { char *VName = NULL; ___2038 = ___3287(___1399, ___2102, ((___2102 < 63) ? 5 : ___2354), ___4364 ? &VName : NULL, (___372)(___4364 != NULL)); if (___2038 && ___4364) { if (VName == NULL) { VName = ___23(1, char, "empty variable name"); strcpy(VName, ""); } ___4223(VName); ___2038 = ___3351(&VName); ___2038 = ___2038 && ___3841(*___4364, ___716, VName); if (VName != NULL) ___1528(VName, "variable name"); } if (!___2038) { if (___4364 && *___4364) ___3826(___4364); ___1175(___4215("Out of space while allocating variable names")); } } ENSURE(VALID_BOOLEAN(___2038)); return (___2038); } namespace { ___372 ReadInPresetZoneColor( ___1403* ___1399, short         ___2102, ___4681&   ___4675) { REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(0 < ___2102 && ___2102 <= TecplotSDKBinaryFileVersion); ___372 ___2038 = ___4224; ___2225 ZoneColor = ___1748<int32_t>(___1399, ___2102, -1, ___2193, &___2038); if (___2038) { if (VALID_BASIC_COLOR(ZoneColor)) { ___4675.___4645.___3172 = (___1170)ZoneColor; AdjustCustomColor(___2102, &___4675.___4645.___3172); } else if (ZoneColor != -1) { ___2038 = ___1303; } } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } } namespace{ void ConvertCommonTimeToSolutionTime(___4681& ___4675) { REQUIRE(___4675.___230 == NULL || VALID_REF(___4675.___230)); int32_t ___2094; if (___4675.___230 != NULL && ___246(___4675.___230, AuxData_Common_Time, &___2094)) { const char    *SameName; ___90     ___4313; AuxDataType_e  ___4234; ___372      ___3360; ___244(___4675.___230, ___2094, &SameName, &___4313, &___4234, &___3360); ___476(ustrcmp(AuxData_Common_Time, SameName) == 0); ___476(___4234 == ___270); char *EndPtr = NULL; double ___3639 = strtod((const char *)___4313, &EndPtr); if (EndPtr != (char *)___4313) { while (tecplot::isspace(*EndPtr)) EndPtr++; } if (EndPtr != (char *)___4313 && *EndPtr == '\0') { ___4675.___3639 = ___3639; ___4675.___3784     = ___3785; ___237(___4675.___230, ___2094); } } } } ___372 ___3293( ___1403*                ___1399, TecplotFileZoneFormat const& tecplotFileZoneFormat, ___4681&                  ___4675, ___3499                       ___2073, ___1170                   NumVars, ___90                   ___263, ___372*                   ___2051, ___2225*                   ___1439) { ___1170 ___4335; ___372  ___2038 = ___4224; ___2225  I1; short const pltFileVersion = tecplotFileZoneFormat.fileVersion(); REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(tecplotFileZoneFormat.___2065()); REQUIRE(___2073 == NULL || VALID_REF(___2073));
REQUIRE(NumVars >= 0); REQUIRE(VALID_REF(___2051)); REQUIRE(VALID_REF(___1439)); ___4675.tecplotFileZoneVersion = tecplotFileZoneFormat.zoneVersion(); if (___2073 != NULL) { ___491(___2073); ___2038 = ___1199(___2073, NumVars, ___1303); } char* zoneName = NULL; if (___2038) ___2038 = ___3287(___1399, pltFileVersion, ((pltFileVersion < 63) ? 10 : ___2356), &zoneName, ___4224); if (___2038) { try { ___4675.___2683 = zoneName; ___3856(___4675.___2683, ___2356); } catch (std::bad_alloc const&) { ___2038 = ___1303; } ___1528(zoneName, "zone name"); zoneName = NULL; } if (___2038 && pltFileVersion < 101) { ___372    IsZoneFinite   = ___1303; DataFormat_e ZoneDataFormat = ___853; I1 = ___1748<int32_t>(___1399, pltFileVersion, 0, 3, &___2038); ___2038 = (0 <= I1 && I1 <= 3); if (___2038) { ZoneDataFormat = (DataFormat_e)I1; IsZoneFinite = (ZoneDataFormat == ___850 || ZoneDataFormat == ___849); ___4675.___4645.___2025 = (ZoneDataFormat == ___851 || ZoneDataFormat == ___849); } if (___2038 && pltFileVersion > 62) ___2038 = ReadInPresetZoneColor(___1399, pltFileVersion, ___4675); if (___2038 && pltFileVersion < 60) ___1760(___1399, FieldDataType_Float, -___2177, ___2177, &___2038); ___2225 numIPts = 1; ___2225 numJPts = 1; ___2225 numKPts = 1; if (___2038) { ___476(!tecplotFileZoneFormat.has64BitFaceCounts()); numIPts = ___1748<int32_t>(___1399, pltFileVersion, 0, ___2180, &___2038); numJPts = ___1748<int32_t>(___1399, pltFileVersion, 0, ___2180, &___2038); numKPts = pltFileVersion >= 60 ? ___1748<int32_t>(___1399, pltFileVersion, 0, ___2180, &___2038) : 1; } if (___2038) { if (!((numIPts == 0) && (numJPts == 0) && (numKPts == 0)) && ((numIPts <= 0) || (numJPts <= 0) || (numKPts < 0)  || ((!IsZoneFinite && (numKPts == 0))))) { ___1175(___4215("Datafile is corrupted")); ___2038 = ___1303; } if (IsZoneFinite) { if (pltFileVersion >= 61) { ___4675.___4234 = (ZoneType_e)(numKPts + 1); if (___4675.___4234 == ___4702   || ___4675.___4234 == ___4696 || ___4675.___4234 == ___4697) { ___2038 = ___1303; } if (!___2038) ___1175(___4215("Datafile corrupted: Invalid element type for FE DataSet")); } else { ___4675.___4234 = ___4698; } } else { ___4675.___4234 = ___4702; } } if (___2038) ___4675.assignMetrics(numIPts, numJPts, numKPts); *___2051 = ___1303; *___1439  = 0; } else if (___2038) { if (___2038 && (pltFileVersion >= 107)) { ___1748<int32_t>(___1399, pltFileVersion, -___2180, ___2180, &___2038); } if (___2038 && (pltFileVersion >= 106)) { ___4675.___3784     = ___1748<int32_t>(___1399, pltFileVersion, -2, ___2389 - 1, &___2038); ___4675.___3639 = ___1760(___1399, FieldDataType_Double, -___2177, ___2177, &___2038); if (!___2038) ___1175(___4215("Invalid datafile: bad StrandID or SolutionTime")); } ___2038 = ___2038 && ReadInPresetZoneColor(___1399, pltFileVersion, ___4675);
I1 = (ZoneType_e)___1748<int32_t>(___1399, pltFileVersion, 0, 7, &___2038); switch (I1) { case 0: ___4675.___4234 = ___4702;      break; case 1: ___4675.___4234 = ___4694;    break; case 2: ___4675.___4234 = ___4700;   break; case 3: ___4675.___4234 = ___4698;       break; case 4: ___4675.___4234 = ___4699;      break; case 5: ___4675.___4234 = ___4693;      break; case 6: ___4675.___4234 = ___4696;    break; case 7: ___4675.___4234 = ___4697; break; default: { ___1175(___4215("Invalid datafile: unknown zone type.")); ___2038 = ___1303; } break; } if (pltFileVersion < 112) ___4675.___4645.___2025 = ((DataPacking_e)___1748<int32_t>(___1399, pltFileVersion, 0, 1, &___2038) == ___872); else ___4675.___4645.___2025 = ___4224; if (___1748<int32_t>(___1399, pltFileVersion, 0, 1, &___2038) != 0 && ___2038) { for (___4335 = 0; ___4335 < NumVars && ___2038; ___4335++) { if (___1748<int32_t>(___1399, pltFileVersion, 0, 1, &___2038) != 0 && ___2038 && ___2073 != NULL) { ___2038 = (___4675.___4645.___2025); if (___2038) ___2038 = ___17(___2073, ___4335, ___1303); else ___1175(___4215("Invalid datafile: cell centered " "variable must be in block format.", "See the Tecplot User's Manual for a definition of 'block format'")); } } } if (pltFileVersion >= 108 && ___2038) { *___2051 = ___1748<int32_t>(___1399, pltFileVersion, 0, 1, &___2038) != 0; if (*___2051 && (___4675.___4234 == ___4702 || ___4675.___4234 == ___4694)) { ___2038 = ___1303; ___1175(___4215("Invalid datafile: raw face neighbors may not be " "supplied for ordered or FE line segment zones.")); } } else *___2051 = ___1303; ___4675.___228 = !(*___2051); *___1439 = ___1748<int32_t>(___1399, pltFileVersion, 0, ___2180, &___2038); if (*___1439 != 0) ___4675.___1438 = (FaceNeighborMode_e)___1748<int32_t>(___1399, pltFileVersion, 0, 3, &___2038); if (pltFileVersion >= 108 && ___2038) { ___372 FaceNeighborsComplete = ___1303; if (*___1439 != 0 && ___4675.___4234 != ___4702) FaceNeighborsComplete = ___1748<int32_t>(___1399, pltFileVersion, 0, 1, &___2038) != 0; if (FaceNeighborsComplete) ___4675.___228 = ___1303; } ___2225 numIPts = 1; ___2225 numJPts = 1; ___2225 numKPts = 1; ___2225 ___2802 = 0; ___2225 numFaceBndryFaces = 0; ___2225 numFaceBndryItems = 0; if (___4675.___4234 == ___4702) { numIPts = ___1748<int32_t>(___1399, pltFileVersion, 0, ___2180, &___2038); numJPts = ___1748<int32_t>(___1399, pltFileVersion, 0, ___2180, &___2038); numKPts = ___1748<int32_t>(___1399, pltFileVersion, 0, ___2180, &___2038); if (___2038 && !(numIPts == 0 && numJPts == 0 && numKPts == 0)  && (numIPts == 0 || numJPts == 0 || numKPts == 0)) { ___1175(___4215("Invalid data file: incorrect specification of I, J, or K points for ordered data set."));
___2038 = ___1303; } } else { numIPts = ___1748<int32_t>(___1399, pltFileVersion, 0, ___2180, &___2038); if (___4675.___4234 == ___4696 || ___4675.___4234 == ___4697) { if (tecplotFileZoneFormat.has64BitFaceCounts()) numKPts = ___1748<int64_t>(___1399, pltFileVersion, 0, ___2181, &___2038); else numKPts = ___1748<int32_t>(___1399, pltFileVersion, 0, ___2180, &___2038); if (pltFileVersion >= 111) { if (tecplotFileZoneFormat.has64BitFaceCounts()) ___2802 = ___1748<int64_t>(___1399, pltFileVersion, 0, ___2181, &___2038); else ___2802 = ___1748<int32_t>(___1399, pltFileVersion, 0, ___2180, &___2038); numFaceBndryFaces = ___1748<int32_t>(___1399, pltFileVersion, 0, ___2180, &___2038); if (numFaceBndryFaces > 0) { ___476(pltFileVersion <= 191 && numFaceBndryFaces >= 2); numFaceBndryFaces -= 1; } numFaceBndryItems = ___1748<int32_t>(___1399, pltFileVersion, 0, ___2180, &___2038); } } else { if (___4675.___4234 == ___4702   || ___4675.___4234 == ___4696 || ___4675.___4234 == ___4697) { ___2038 = ___1303; } if (!___2038) ___1175(___4215("Invalid data file: invalid element type for FE data set.")); } numJPts = ___1748<int32_t>(___1399, pltFileVersion, 0, ___2180, &___2038); ___476(pltFileVersion <= 191); ___1748<int32_t>(___1399, pltFileVersion, 0, ___2180, &___2038); ___1748<int32_t>(___1399, pltFileVersion, 0, ___2180, &___2038); ___1748<int32_t>(___1399, pltFileVersion, 0, ___2180, &___2038); } if (___2038) { if (___4675.___4234 == ___4696 || ___4675.___4234 == ___4697) ___4675.assignMetrics(numIPts, numJPts, numKPts, ___2802, numFaceBndryFaces, numFaceBndryItems); else ___4675.assignMetrics(numIPts, numJPts, numKPts); } for (I1 = ___1748<int32_t>(___1399, pltFileVersion, 0, 1, &___2038); ___2038 && I1 != 0; I1 = ___1748<int32_t>(___1399, pltFileVersion, 0, 1, &___2038)) { if (___4675.___230 == NULL) ___4675.___230 = ___231(___263); ___2038 = (___4675.___230 != NULL); if (___2038) ___2038 = ___3283(___1399, pltFileVersion, ___4675.___230); } } if (pltFileVersion < 106 && ___2038) ConvertCommonTimeToSolutionTime(___4675); ENSURE(VALID_BOOLEAN(___2038)); return (___2038); } ___372 ___3284(___1403  *___1399, short          ___2102, ___372      ___2866, ___3837 *___789) { ___2225 NumLabels; short     ___1830; ___372 ___2038 = ___4224; REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(___2102 > 0); REQUIRE(VALID_BOOLEAN(___2866)); REQUIRE(!(___2866) || VALID_REF(___789)); NumLabels = (short)___1748<int32_t>(___1399, ___2102, 0, ___2179, &___2038); if (___2038 && NumLabels != 0 && ___2866) { *___789 = ___3819(); ___2038 = (*___789 != NULL); if (!___2038) ___1175(___4215("Cannot allocate memory for Custom Labels.")); } for (___1830 = 0; ___2038 && (___1830 < NumLabels); ___1830++) { char *TLabel = NULL; ___2038 = ___3287(___1399, ___2102,
1024, &TLabel, ___2866); ___4223(TLabel); if (___2038 && ___2866) { ___2038 = ___3821(*___789, TLabel); if (TLabel != NULL) ___1528(TLabel, "custom label"); if (!___2038) ___1175(___4215("Cannot allocate memory for Custom Label.")); } } if (!___2038) ___1175(___4215("Invalid custom axis label record in binary datafile")); ENSURE(VALID_BOOLEAN(___2038)); ENSURE(!(___2038 && NumLabels != 0 && ___2866) || ___3846(*___789)); return ___2038; } ___372 ___3292( ___1403* ___1399, short         ___2102, char**        ___4283) { if (!___3287(___1399, ___2102, 0, ___4283, (___372)(___4283 != NULL))) { ___1175(___4215("Invalid USERREC record in binary datafile")); return (___1303); } return (___4224); } ___372 ___3283(___1403 *___1399, short         ___2102, ___264    ___230) { ___372 ___2038; ___372 DoCollectData; char      *AuxName  = NULL; ___2225 AuxValueType; char      *AuxValue = NULL; REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(0 < ___2102 && ___2102 <= TecplotSDKBinaryFileVersion); REQUIRE(___230 == NULL || VALID_REF(___230)); DoCollectData = (___230 != NULL); ___2038 = ___3287(___1399, ___2102, ___2354, &AuxName, DoCollectData); if (___2038 && DoCollectData && !___249(AuxName)) { ___1175(___4215("Invalid auxiliary data name.")); ___2038 = ___1303; } if (___2038) { AuxValueType = ___1748<int32_t>(___1399, ___2102, 0, 0, &___2038); if (___2038 && (AuxValueType != (___2225)___270)) { ___1175(___4215("Unsupported auxiliary data type")); ___2038 = ___1303; } } if (___2038) ___2038 = ___3287(___1399, ___2102, ___2351, &AuxValue, DoCollectData); if (___2038 && DoCollectData) ___2038 = ___267(___230, AuxName, (___90)AuxValue, ___270, ___4224); if (AuxName != NULL) ___1528(AuxName, "data set auxiliary data item name"); if (AuxValue != NULL) ___1528(AuxValue, "data set auxiliary data item value"); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } static void GetZoneAttachment(___1403 *___1399, short         ___2102, ___1170   *Z, ___372    *IsAttached, ___372    *___2038) { REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(VALID_REF(Z)); REQUIRE(VALID_REF(IsAttached)); REQUIRE(VALID_REF(___2038) && VALID_BOOLEAN(*___2038)); if (___2102 >= 47) *Z = ___1748<int32_t>(___1399, ___2102, -1, ___2389, ___2038); else *Z = 0; if (___2102 < 70) (*Z)--; if (*Z == -1) { *Z          = 0; *IsAttached = ___1303; } else *IsAttached = ___4224; ENSURE(VALID_BOOLEAN(*IsAttached)); ENSURE(VALID_BOOLEAN(*___2038)); ENSURE(*Z >= 0); } static ___372 ReadMacroFunctionCommand(___1403  *___1399, short          ___2102, ___372      ___2866, char         **___2329) { ___372 ___3357 = ___1303; REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(___2102 > 0); REQUIRE(VALID_BOOLEAN(___2866)); REQUIRE(VALID_REF(___2329));
___3357 = ___3287(___1399, ___2102, 0, ___2329, ___2866); ENSURE(VALID_BOOLEAN(___3357)); return (___3357); } ___372 ___3286(___1403 *___1399, short         ___2102, ___372     ___2866, ___1630       *___1554, ___2225     ___2364) { ___2225        ___1830; ___2225        S; FieldDataType_e  FFT; ___372        ___2038 = ___4224; ___4216 ErrMsgString = ___4215("Invalid geometry record"); REQUIRE(VALID_REF(___1554)); if (___2102 < 70) FFT = FieldDataType_Float; else FFT = FieldDataType_Double; if (___2102 < 101) ___1830 = ___1748<int32_t>(___1399, ___2102, 0, 1, &___2038); else ___1830 = ___1748<int32_t>(___1399, ___2102, 0, 4, &___2038); if (___1830 == 0) ___1554->___3165 = CoordSys_Grid; else if (___1830 == 1) ___1554->___3165 = CoordSys_Frame; else if (___1830 == 4) ___1554->___3165 = CoordSys_Grid3D; else { ErrMsgString = ___4215("Invalid geometry coordinate system"); ___2038 = ___1303; } ___1554->___3441 = (Scope_e)___1748<int32_t>(___1399, ___2102, 0, 1, &___2038); if (___2102 >= 102) ___1554->___1111 = (DrawOrder_e)___1748<int32_t>(___1399, ___2102, 0, 1, &___2038); ___1554->position.setXOrTheta(___1760(___1399, FFT, -___2177, ___2177, &___2038)); ___1554->position.setYOrR(___1760(___1399, FFT, -___2177, ___2177, &___2038)); if (___2102 >= 45) ___1554->position.setZ(___1760(___1399, FFT, -___2177, ___2177, &___2038)); else ___1554->position.setZ(0.0); GetZoneAttachment(___1399, ___2102, &___1554->___4598, &___1554->___227, &___2038); ___1554->___351 = ___1748<int32_t>(___1399, ___2102, 0, 255, &___2038); AdjustCustomColor(___2102, &___1554->___351); if (___2102 > 47) { ___1554->___1408 = ___1748<int32_t>(___1399, ___2102, 0, 255, &___2038); ___1554->___2021  = ___1748<int32_t>(___1399, ___2102, 0, 1, &___2038) != 0; AdjustCustomColor(___2102, &___1554->___1408); } else { ___1554->___1408 = ___1554->___351; ___1554->___2021  = ___1303; } if (___2102 < 101) { ___1554->___1650 = (GeomType_e)___1748<int32_t>(___1399, ___2102, 0, 5, &___2038); if (___1554->___1650 == GeomType_LineSegs3D) { ___1554->___1650         = GeomType_LineSegs; ___1554->___3165 = CoordSys_Grid3D; } } else { ___1554->___1650 = (GeomType_e)___1748<int32_t>(___1399, ___2102, 0, 4, &___2038); } if (___1554->___3165 == CoordSys_Grid3D && ___1554->___1650 != GeomType_LineSegs) { ErrMsgString = ___4215("Mismatch between geometry coordinate system and geometry type"); ___2038 = ___1303; } if (___2102 > 41) { ___1554->___2262 = (LinePattern_e)___1748<int32_t>(___1399, ___2102, 0, ___2264, &___2038); } else { ___1554->___2262  = (LinePattern_e)((int)___1554->___1650 % 2); ___1554->___1650     = (GeomType_e)((int)___1554->___1650 / 10); } if ((___2102 < 49) && ((short)(___1554->___1650) == 2)) { ___1554->___1650 = GeomType_Rectangle; ___1554->___2021 = ___4224; } if ((___2102 < 70) && ((short)(___1554->___1650) > 1)) ___1554->___1650 = (GeomType_e)((short)___1554->___1650 + 1); ___3353(&___1554->___2329, NULL, ___4224);
___1554->___1888 = ___1898; if (___2102 >= 70) { ___1554->___2985       = ___1760(___1399, FFT, PatternLengthInputSpec.___2468, PatternLengthInputSpec.___2344, &___2038); ___1554->___2288       = ___1760(___1399, FFT, LineThicknessInputSpec.___2468, LineThicknessInputSpec.___2344, &___2038); ___1554->___2792       = ___1748<int32_t>(___1399, ___2102, 2, ___2382, &___2038); ___1554->___188      = (ArrowheadStyle_e)___1748<int32_t>(___1399, ___2102, 0, ___190, &___2038); ___1554->___176 = (ArrowheadAttachment_e)___1748<int32_t>(___1399, ___2102, 0, ___178, &___2038); ___1554->___187  = ___1760(___1399, FFT, ArrowheadSizeInputSpec.___2468, ArrowheadSizeInputSpec.___2344, &___2038); ___1554->___171 = ___1760(___1399, FFT, ArrowheadAngleInputSpec.___2468, ArrowheadAngleInputSpec.___2344, &___2038); if (___2102 >= 75) { ___2038 = ReadMacroFunctionCommand(___1399, ___2102, ___2866, &___1554->___2329); } } else { ___1554->___2288        = 0.001; ___1554->___2985        = 0.02; ___1554->___188       = ___192; ___1554->___176  = ___181; ___1554->___187        = 0.05; ___1554->___171       = 12.0 / ___952; } if (___2102 < 41) { ___1760(___1399, FieldDataType_Float, -___2177, ___2177, &___2038); ___1760(___1399, FieldDataType_Float, -___2177, ___2177, &___2038); ___1760(___1399, FieldDataType_Float, -___2177, ___2177, &___2038); } if (___2102 < 70) ___1554->___905 = FieldDataType_Float; else ___1554->___905 = (FieldDataType_e)___1748<int32_t>(___1399, ___2102, 1, 2, &___2038); ___476(VALID_GEOM_FIELD_DATA_TYPE(___1554->___905)); ___1554->___494 = ___496; if (___2102 >= 101) { ___1554->___494 = (Clipping_e)___1748<int32_t>(___1399, ___2102, 0, 2, &___2038); if (___1554->___494 == (Clipping_e)2) ___1554->___494 = ___495; } if (___2102 < 50 || ___1554->___1650 == GeomType_LineSegs) { ___1554->___2834 = ___1748<int32_t>(___1399, ___2102, 1, ___2369, &___2038); S = -1; ___1830 = 0; while ((S + 1 < ___1554->___2834) && !feof(___1399->File) && ___2038) { S++; ___1554->___2836[S] = ___1748<int32_t>(___1399, ___2102, 1, ___2180, &___2038); if ((___1830 + ___1554->___2836[S] > ___2364) && ___2866) { ErrMsgString = ___4215("Geometry is too big"); ___2038 = ___1303; } else { ___3274(___1399, ___1554->___1571.___1546.___4291, ___2866, ___1554->___905, ___1830, ___1830 + ___1554->___2836[S] - 1, &___2038); ___3274(___1399, ___1554->___1571.___1546.___4293, ___2866, ___1554->___905, ___1830, ___1830 + ___1554->___2836[S] - 1, &___2038); if (GEOM_USES_V3(___1554)) ___3274(___1399, ___1554->___1571.___1546.___4295, ___2866, ___1554->___905, ___1830, ___1830 + ___1554->___2836[S] - 1, &___2038); ___1830 += ___1554->___2836[S]; } } if (___2038 && (___1554->___1650 == GeomType_Rectangle)) { if (___2866) { ___673(___1554->___1571.___1546.___4291, 0, ___1554->___1571.___1546.___4291, 2);
___673(___1554->___1571.___1546.___4293, 0, ___1554->___1571.___1546.___4293, 2); } } } else if (___1554->___1650 == GeomType_Rectangle || ___1554->___1650 == GeomType_Ellipse) { double XX, YY; XX = ___1760(___1399, ___1554->___905, -___2177, ___2177, &___2038); YY = ___1760(___1399, ___1554->___905, -___2177, ___2177, &___2038); if (___2866) { ___3488(___1554->___1571.___4578.___4567, 0, XX); ___3488(___1554->___1571.___4578.___4584, 0, YY); } ___1554->___2834 = 1; ___1554->___2836[0]   = 1; } else { double XX; ___476((___1554->___1650 == GeomType_Square) || (___1554->___1650 == GeomType_Circle)); XX = ___1760(___1399, ___1554->___905, -___2177, ___2177, &___2038); if (___2866) { ___3488(___1554->___1571.___4578.___4567, 0, XX); } ___1554->___2834  = 1; ___1554->___2836[0] = 1; } if (!___2038) ___1175(ErrMsgString); return (___2038); } ___372 ___3291(___1403 *___1399, short         ___2102, ___372     ___2866, ___4116       *Text, ___2225     ___2385) { ___2225        ___1830; FieldDataType_e  FFT; int32_t      TextLength = 0; ___372        ___2038 = ___4224; ___4216 ErrMsgString = ___4215("Invalid text record"); REQUIRE(VALID_REF(Text)); if (___2102 < 70) FFT = FieldDataType_Float; else FFT = FieldDataType_Double; if (___2102 < 101) ___1830 = ___1748<int32_t>(___1399, ___2102, 0, 1, &___2038); else ___1830 = ___1748<int32_t>(___1399, ___2102, 0, 4, &___2038); if (___1830 == 0) Text->___3165 = CoordSys_Grid; else if (___1830 == 1) Text->___3165 = CoordSys_Frame; else if (___1830 == 4) Text->___3165 = CoordSys_Grid3D; else { ErrMsgString = ___4215("Invalid text coordinate system."); ___2038 = ___1303; } Text->___3441   = (Scope_e)___1748<int32_t>(___1399, ___2102, 0, 1, &___2038); Text->___52.___1546.___4290 = ___1760(___1399, FFT, -___2177, ___2177, &___2038); Text->___52.___1546.___4292 = ___1760(___1399, FFT, -___2177, ___2177, &___2038); if (___2102 >= 101) Text->___52.___1546.___4294 = ___1760(___1399, FFT, -___2177, ___2177, &___2038); else Text->___52.___1546.___4294 = 0.0; if (___2102 > 40) { Text->___4119.___1442 = (Font_e)___1748<int32_t>(___1399, ___2102, 0, ___1444, &___2038); } else { Text->___4119.___1442 = ___1452; } if (___2102 < 43) ___1760(___1399, FFT, -___2177, ___2177, &___2038); if (___2102 < 70) { if (Text->___3165 == CoordSys_Grid) Text->___4119.___3599 = ___4267; else Text->___4119.___3599 = ___4266; } else Text->___4119.___3599 = (Units_e)___1748<int32_t>(___1399, ___2102, 0, ___4269, &___2038); Text->___4119.___1825 = ___1760(___1399, FFT, -___2177, ___2177, &___2038); if (___2102 > 47) { Text->___401.___411 = (TextBox_e)___1748<int32_t>(___1399, ___2102, 0, ___4067, &___2038); if (___2102 < 70) { if (Text->___401.___411 == ___4067) Text->___401.___411 = ___4061; else if (Text->___401.___411 == ___4061) Text->___401.___411 = ___4067;
} Text->___401.___2336     = ___1760(___1399, FFT, TextBoxMarginInputSpec.___2468, TextBoxMarginInputSpec.___2344, &___2038); if (___2102 >= 70) Text->___401.___2288 = ___1760(___1399, FFT, LineThicknessInputSpec.___2468, LineThicknessInputSpec.___2344, &___2038); else Text->___401.___2288 = 0.01; Text->___401.___351     = ___1748<int32_t>(___1399, ___2102, 0, 255, &___2038); Text->___401.___1408 = ___1748<int32_t>(___1399, ___2102, 0, 255, &___2038); AdjustCustomColor(___2102, &Text->___401.___351); AdjustCustomColor(___2102, &Text->___401.___1408); } else { Text->___401.___411    = ___4073; Text->___401.___2336     = 0.0; Text->___401.___351     = ___4453; Text->___401.___1408 = ___364; } if (___2102 < 70) { Text->___57       = ___1748<int32_t>(___1399, ___2102, -720, 720, &___2038) / ___952; Text->___2286 = 1; Text->___39      = ___4048; } else { Text->___57       = ___1760(___1399, FFT, TextAngleInputSpec.___2468, TextAngleInputSpec.___2344, &___2038); Text->___2286 = ___1760(___1399, FFT, TextLineSpacingInputSpec.___2468, TextLineSpacingInputSpec.___2344, &___2038); Text->___39      = (TextAnchor_e)___1748<int32_t>(___1399, ___2102, 0, ___4046, &___2038); } GetZoneAttachment(___1399, ___2102, &Text->___4598, &Text->___227, &___2038); Text->___351   = ___1748<int32_t>(___1399, ___2102, 0, 255, &___2038); AdjustCustomColor(___2102, &Text->___351); if (___2102 < 70) TextLength = (short)___1748<int32_t>(___1399, ___2102, 0, 5000, &___2038); Text->___2329.clear(); Text->___494 = ___496; if (___2102 < 70) { try { for (short i = 0; i < TextLength; i++) { short s = (short)___1748<int32_t>(___1399, ___2102, 0, 1000, &___2038); if (___2866 && (i <= ___2385)) Text->Text.push_back((char)s); } } catch (std::bad_alloc const&) { ErrMsgString = ___4215("Insufficient memory available"); ___2038 = ___1303; } } else { char *S = NULL; if (___2102 >= 75) ___2038 = ___3287(___1399, ___2102, 0, &Text->___2329, ___2866); if (___2102 >= 101) { Text->___494 = (Clipping_e)___1748<int32_t>(___1399, ___2102, 0, 2, &___2038); if (Text->___494 == (Clipping_e)2) Text->___494 = ___495; } if (___3287(___1399, ___2102, ___2385, &S, ___2866)) { if (S) { if (___2038) { try { Text->Text = S; } catch (std::bad_alloc const&) { ErrMsgString = ___4215("Insufficient memory available"); ___2038 = ___1303; } } ___1528(S, "Release temp string for new text label"); } else if (___2866) { Text->Text.clear(); } } else { ___2038 = ___1303; } } if (!___2038) ___1175(ErrMsgString); return (___2038); } static ___372 CompareVersion(float      ___4406, char      *VersionString, ___372  ___2005) { char *VersionBuf = (char *) & ___4406; REQUIRE(VALID_REF(VersionString)); if (___2005) return ((VersionString[0] == VersionBuf[0]) && (VersionString[1] == VersionBuf[1]) && (VersionString[2] == VersionBuf[2]) && (VersionString[3] == VersionBuf[3]));
else return ((VersionString[3] == VersionBuf[0]) && (VersionString[2] == VersionBuf[1]) && (VersionString[1] == VersionBuf[2]) && (VersionString[0] == VersionBuf[3])); } static float ValidVersions[] = {7.0F, 6.3F, 6.2F, 6.1F, 6.0F, 5.0F, 4.7F, 4.6F, 4.5F, 4.4F, 4.3F, 4.2F, 4.1F, 4.0F };
 #define NUMVALIDVERSIONS ((int)(sizeof(ValidVersions)/sizeof(ValidVersions[0])))
static ___372 GetDoubleVersion(char      *VersionString, float     *FInputVersion, ___372  ___2005) { int  ___1830; REQUIRE(VALID_REF(FInputVersion)); for (___1830 = 0; ___1830 < NUMVALIDVERSIONS; ___1830++) if (CompareVersion(ValidVersions[___1830], VersionString, ___2005)) { *FInputVersion = ValidVersions[___1830]; return (___4224); } return (___1303); } static short GetNewInputVersion(___1403 *___1399) { char       Buf[4] = { 0, 0, 0, 0 }; short      ___2102 = 0; short      ___1830; ___2225  OneValue; ___372  ___2038 = ___4224; REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(___1399->___2005); if (___4196(Buf, 4, 1, ___1399->File) != 1) return (0); if (strncmp(Buf, "#!TD", 4)) return (0); if (___4196(Buf, 4, 1, ___1399->File) != 1) return (0); if (Buf[0] != 'V') return (0); ___1830 = 1; while ((___1830 < 4) && tecplot::___2010(Buf[___1830])) ___2102 = ___2102 * 10 + Buf[___1830++] - '0'; if (___2102 < 70) return (0); else if (___2102 > TecplotSDKBinaryFileVersion) { ___1175(___4215("Binary file version newer than Tecplot version. " "Upgrade Tecplot or use an older Preplot to produce " "the datafile.")); return (___2102); } OneValue = ___1748<int32_t>(___1399, ___2102, -___2180, ___2180, &___2038); if (!___2038) return (0); ___1399->___2005 = (OneValue == 1); return (___2102); } short ___1747(___1403 *___1399) { ___372    ___2038 = ___4224; float        FInputVersion; short        ___2102; char         VersionString[4]; ___1396 ___3684 = 0; ___3684 = ___4199(___1399->File); ___2102 = GetNewInputVersion(___1399); if (___2102 > TecplotSDKBinaryFileVersion) return ___2102; else if (___2102 == 0) { rewind(___1399->File); ___2038 = (___4198(___1399->File, ___3684, SEEK_SET) == 0); if (___2038 && ___4196(VersionString, 4, 1, ___1399->File) == 1) { if (!GetDoubleVersion(VersionString, &FInputVersion, ___1399->___2005)) { ___1399->___2005 = !___1399->___2005; ___2038 = GetDoubleVersion(VersionString, &FInputVersion, ___1399->___2005); } if (___2038) ___2102 = ___3420(FInputVersion * 10); } } if (___2038) return (___2102); else return ((short)0); } ___372 ___4484( ___1403*  ___1399, uint8_t const* ___428, ___2225      ___2840) { REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(VALID_REF(___428)); REQUIRE(___2840 >= 0); ___372 ___2038 = ___4200(___428, sizeof(uint8_t), (size_t)___2840, ___1399->File) == (size_t)___2840; ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } static inline ___372 WriteBinaryByte(___1403 *___1399, uint8_t        ByteValue) { REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); ___372 ___2038 = ___4484(___1399, &ByteValue, 1); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } template <typename T> void CopyAndReverseUnalignedBytes(T            *___1121, const uint8_t *___3656) { REQUIRE(VALID_REF(___1121));
REQUIRE(VALID_REF(___3656)); size_t typeSize = sizeof(T); for (size_t ___1839 = 0; ___1839 < typeSize; ___1839++) ((uint8_t *)(___1121))[___1839] = ((uint8_t *)(___3656))[typeSize-1-___1839]; } template <typename T> void CopyUnalignedBytes(T            *___1121, const uint8_t *___3656) { REQUIRE(VALID_REF(___1121)); REQUIRE(VALID_REF(___3656)); for (size_t ___1839 = 0; ___1839 < sizeof(T); ___1839++) ((uint8_t *)(___1121))[___1839] = ((uint8_t *)(___3656))[___1839]; } template <typename T> ___372 WriteBinaryDataUnaligned(___1403    *___1399, const uint8_t    *ValueBuffer, const ___372  ValueInNativeOrder) { REQUIRE(VALID_REF(___1399) && VALID_FILE_HANDLE(___1399->File)); REQUIRE(VALID_REF(ValueBuffer)); REQUIRE(VALID_BOOLEAN(ValueInNativeOrder)); T DataValue; if (ValueInNativeOrder != ___1399->___2005) CopyAndReverseUnalignedBytes<T>(&DataValue, ValueBuffer); else CopyUnalignedBytes<T>(&DataValue, ValueBuffer); ___372 ___2038 = ___4200(&DataValue, sizeof(T), 1, ___1399->File) == 1; ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 ___4486(___1403 *___1399, int16_t       ___4313) { REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE("Value can be any int16_t"); return WriteBinaryDataUnaligned<int16_t>(___1399, (uint8_t *) & ___4313, ___4224 ); } ___372 ___4488(___1403 *___1399, int32_t       ___4313) { REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); return WriteBinaryDataUnaligned<int32_t>(___1399, (uint8_t *) & ___4313, ___4224 ); } ___372 WriteBinaryInt64(___1403 *___1399, int64_t       ___4313) { REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE("Value can be any int64_t"); return WriteBinaryDataUnaligned<int64_t>(___1399, (uint8_t *) & ___4313, ___4224 ); } template <typename T> ___372 WriteBinaryBlockUnaligned(___1403    *___1399, const uint8_t    *___4330, const ___2225  ___2840, const ___372  ___4331) { ___372 ___2038 = ___4224; ___372 WriteEachValueSeparately; REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(VALID_REF(___4330)); REQUIRE(___2840 >= 0); REQUIRE(VALID_BOOLEAN(___4331)); WriteEachValueSeparately = (___4331 != ___1399->___2005); if (WriteEachValueSeparately) { for (___2225 NIndex = 0; ___2038 && NIndex < ___2840; NIndex++) { ___2038 = WriteBinaryDataUnaligned<T>(___1399, ___4330 + NIndex * sizeof(T), ___4331); } } else {
 #if 1
size_t NumBytesToWrite = ___2840 * sizeof(T); size_t NumBytesWritten = ___4200(___4330, sizeof(uint8_t), NumBytesToWrite, ___1399->File); ___2038 = NumBytesToWrite == NumBytesWritten;
 #else
___2038 = ___4484(___1399, ___4330, ___2840 * sizeof(T));
 #endif
} ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 ___4487( ___1403*  ___1399, uint8_t const* ___1961, ___2225      ___2840, ___372      ___4331) { REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(VALID_REF(___1961)); REQUIRE(___2840 >= 0); REQUIRE(VALID_BOOLEAN(___4331)); ___372 ___2038 = WriteBinaryBlockUnaligned<int16_t>(___1399, ___1961, ___2840, ___4331); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 ___4489( ___1403*  ___1399, uint8_t const* ___1966, ___2225      ___2840, ___372      ___4331) { REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(VALID_REF(___1966)); REQUIRE(___2840 >= 0); REQUIRE(VALID_BOOLEAN(___4331)); ___372 ___2038 = WriteBinaryBlockUnaligned<int32_t>(___1399, ___1966, ___2840, ___4331); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 WriteBinaryInt64BlockUnaligned( ___1403*  ___1399, uint8_t const* Int64Values, ___2225      ___2840, ___372      ___4331) { REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(VALID_REF(Int64Values)); REQUIRE(___2840 >= 0); REQUIRE(VALID_BOOLEAN(___4331)); ___372 ___2038 = WriteBinaryBlockUnaligned<int64_t>(___1399, Int64Values, ___2840, ___4331); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 ___4491(___1403    *___1399, double           ___3423, FieldDataType_e  ___1362) { ___372 ___2038 = ___1303; REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE((___1362 == FieldDataType_Float)  || (___1362 == FieldDataType_Double) || (___1362 == FieldDataType_Byte)); switch (___1362) { case FieldDataType_Float : { float FloatVal = ___648(___3423); ___2038 = WriteBinaryDataUnaligned<float>(___1399, (uint8_t *) & FloatVal, ___4224 ); } break; case FieldDataType_Double : { double DoubleVal = ___487(___3423); ___2038 = WriteBinaryDataUnaligned<double>(___1399, (uint8_t *) & DoubleVal, ___4224 ); } break; case FieldDataType_Byte : { uint8_t B; if (___3423 > 255) B = 255; else if (___3423 < 0) B = 0; else B = (uint8_t)___3423; ___2038 = WriteBinaryByte(___1399, B); } break; default: ___476(___1303); break; } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 ___4511(___1403    *___1399, FieldDataType_e  ___1308, ___372        ___4483) { if (___4483) return (___4488(___1399, (___2225)___1308)); else { int32_t S = 0; switch (___1308) { case FieldDataType_Float :  S = fprintf(___1399->File, "SINGLE "); break; case FieldDataType_Double : S = fprintf(___1399->File, "DOUBLE "); break; case FieldDataType_Int32 :  S = fprintf(___1399->File, "LONGINT "); break; case FieldDataType_Int16 :  S = fprintf(___1399->File, "SHORTINT "); break; case FieldDataType_Byte :   S = fprintf(___1399->File, "BYTE "); break;
case ___1363 :    S = fprintf(___1399->File, "BIT "); break; default: ___476(___1303); } return (___1480(S)); } } template <typename T> ___372 WriteBinaryByteValues( ___1403*  ___1399, uint8_t const* ___428, ___2225      ___2840 ) { REQUIRE(VALID_REF(___1399) && VALID_FILE_HANDLE(___1399->File)); REQUIRE(VALID_REF(___428)); REQUIRE(___2840 >= 1); ___372 ___2038; if (___2840 == 1) ___2038 = WriteBinaryDataUnaligned<T>(___1399, ___428, ___4224); else ___2038 = WriteBinaryBlockUnaligned<T>(___1399, ___428, ___2840, ___4224); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } template <typename T> ___372 WriteBinaryFieldDataBlockOfType( ___1403* ___1399, ___1359  ___1350, ___2225     ___3684, ___2225     ___2840) { ___372 ___2038 = ___1303; if (___2017(___1350)) { uint8_t *ByteArray = ___1679(___1350) + ___3684 * sizeof(T); ___2038 = WriteBinaryByteValues<T>( ___1399, ByteArray, (___2225)___2840 ); } else { for (___2225 ___2864 = ___3684; ___2864 < ___2840; ___2864++) { T ValueBuffer = (T)___1733(___1350, ___2864); uint8_t* ByteValue = (uint8_t *) & ValueBuffer; ___2038 = WriteBinaryByteValues<T>( ___1399, ByteValue, 1 ); } } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } static ___372 WriteBinaryFieldDataBlockOfTypeBit( ___1403* ___1399, ___1359  ___1350, ___2225     ___3684, ___2225     ___2840) { ___4276(___3684); ___372 ___2038 = ___1303; size_t NumBytes = 1 + (___2840 - 1) / 8; if (___2017(___1350)) { uint8_t *ByteArray = ___1679(___1350); ___2038 = WriteBinaryByteValues<uint8_t>( ___1399, ByteArray, (___2225)NumBytes ); } else { for (___2225 ___2864 = 0; ___2864 < ___2840; ___2864 += 8) { uint8_t ValueBuffer = 0; for (int ___1839 = 0; ___1839 < 8; ___1839++) { uint8_t CurBit = (uint8_t)___1733(___1350, ___2864 + ___1839); ValueBuffer |= (CurBit << ___1839); } ___2038 = WriteBinaryByteValues<uint8_t>( ___1399, &ValueBuffer, 1 ); } } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 ___4485( ___1403* ___1399, ___1359  ___1350, ___2225     ___3684, ___2225     ___2840) { ___372 ___2038 = ___1303; switch (___1724(___1350)) { case FieldDataType_Float  : ___2038 = WriteBinaryFieldDataBlockOfType<float>(___1399, ___1350, ___3684, ___2840); break; case FieldDataType_Double : ___2038 = WriteBinaryFieldDataBlockOfType<double>(___1399, ___1350, ___3684, ___2840); break; case FieldDataType_Int32  : ___2038 = WriteBinaryFieldDataBlockOfType<int32_t>(___1399, ___1350, ___3684, ___2840); break; case FieldDataType_Int16  : ___2038 = WriteBinaryFieldDataBlockOfType<int16_t>(___1399, ___1350, ___3684, ___2840); break; case FieldDataType_Byte   : ___2038 = WriteBinaryFieldDataBlockOfType<uint8_t>(___1399, ___1350, ___3684, ___2840); break; case ___1363    : ___2038 = WriteBinaryFieldDataBlockOfTypeBit(___1399, ___1350, ___3684, ___2840); break;
default: ___476(___1303); break; } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } static ___372 WriteASCIIFieldDataValue( ___1403* ___1399, ___1359  ___1350, ___2225     ___2864, int32_t       ___200) { double V = ___1733(___1350, ___2864); char ___416[100*MAX_SIZEOFUTF8CHAR]; switch (___1724(___1350)) { case FieldDataType_Float : case FieldDataType_Double : sprintf(___416, " %.*E", (int)___200, V); break; case FieldDataType_Int32 : sprintf(___416, " %*d", (int)___200, ROUND32(V)); break; case FieldDataType_Int16 : sprintf(___416, " %6d", ___3418(V)); break; case FieldDataType_Byte : sprintf(___416, " %3d", ___3420(V)); break; case ___1363 : sprintf(___416, " %c", ((V == 0) ? '0' : '1')); break; default: ___476(___1303); break; } ___372 ___2038 = ___1480(fprintf(___1399->File, "%s", ___416)); ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 ___4493(___1403 *___1399, ___1359  ___1350, ___372     ___2041, ___2225     ___2807, ___2225     ___2812, ___2225     ___2815, ___372     ___4483, int32_t   ___200) { ___372 ___2038 = ___4224; ___2225 ___2840; ___2225 ___1830, ___2104, ___2133; ___2225 ___2805 = -1; ___2225 ___1837     = -1; ___2225 ___2109     = -1; ___2225 ___2137     = -1; ___372 IsLinear = -1; REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(VALID_REF(___1350)); REQUIRE(VALID_BOOLEAN(___2041)); REQUIRE(___2807 >= 0); REQUIRE(___2812 >= 0); REQUIRE(___2815 >= 0); REQUIRE(VALID_BOOLEAN(___4483)); REQUIRE(IMPLICATION(!___4483, ___200 >= 0)); if (___2041 && !___4483) { ___2805  = ___2807 * ___2812; ___1837      = MAX(___2807 - 1, 1); ___2109      = MAX(___2812 - 1, 1); ___2137      = MAX(___2815 - 1, 1); ___2840 = (___1837 * ___2109 * ___2137); IsLinear  = ((___2812 == 1 && ___2815 == 1) || (___2807 == 1 && ___2815 == 1) || (___2807 == 1 && ___2812 == 1)); } else { ___2840 = ___1715(___1350); } if (___4483) { ___2038 = ___4485(___1399, ___1350, 0, ___2840); } else { ___2225 NumValuesPerLine = 80 / (___200 + 5); if (___2041 && !IsLinear) { ___2225 ValueIndex = 0; for (___2133 = 0; ___2133 < ___2137 && ___2038; ___2133++) for (___2104 = 0; ___2104 < ___2109 && ___2038; ___2104++) for (___1830 = 0; ___1830 < ___1837 && ___2038; ___1830++) { ___2225 ___461 = ___1830 + (___2104 * ___2807) + (___2133 * ___2805); ___2038 = WriteASCIIFieldDataValue(___1399, ___1350, ___461, ___200); if ((ValueIndex + 1) % NumValuesPerLine == 0 || ValueIndex == ___2840 - 1) ___2038 = (fputc('\n', ___1399->File) != EOF); ValueIndex++; } } else { for (___1830 = 0; ___1830 < ___2840 && ___2038; ___1830++) { ___2038 = WriteASCIIFieldDataValue(___1399, ___1350, ___1830, ___200); if ((___1830 + 1) % NumValuesPerLine == 0 || ___1830 == ___2840 - 1) ___2038 = (fputc('\n', ___1399->File) != EOF); } } } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 ___1129(___1403 *___1399, const char   *S, ___372     ___4483) { ___372 ___2038 = ___4224;
if (___4483) { const char *___683 = S; while (___2038 && ___683 && *___683) ___2038 = ___4488(___1399, (___2225)(unsigned char) * ___683++); if (___2038) ___2038 = ___4488(___1399, 0); } else { const char *___683 = S; fputc('"', ___1399->File); while (___683 && *___683) { if (*___683 == '\n') { ___683++; fputc('\\', ___1399->File); fputc('\\', ___1399->File); fputc('n', ___1399->File); } else { if ((*___683 == '"') || (*___683 == '\\')) fputc('\\', ___1399->File); fputc(*___683++, ___1399->File); } } fputc('"', ___1399->File); ___2038 = (fputc('\n', ___1399->File) != EOF); } return (___2038); } static void WriteAsciiColor(FILE        *File, ___514 Color) { if (Color >= ___1420 && Color <= ___2194) fprintf(File, "CUST%1d ", Color - ___1420 + 1); else { switch (Color) { case ___364  : fprintf(File, "BLACK "); break; case ___3299    : fprintf(File, "RED "); break; case ___1808  : fprintf(File, "GREEN "); break; case ___366   : fprintf(File, "BLUE "); break; case ___797   : fprintf(File, "CYAN "); break; case ___4585 : fprintf(File, "YELLOW "); break; case ___3254 : fprintf(File, "PURPLE "); break; case ___4453  : fprintf(File, "WHITE "); break; } } } static void WriteAsciiTextGeomBasics(FILE*              File, CoordSys_e         CoordSys, ___372          ___227, ___1170         ___4598, ___514       Color, Scope_e            ___3441, ___372          IncludeZ, ___372          ___4523, ___54 const* ___52, double             ___3432) { REQUIRE(VALID_REF(File)); REQUIRE(VALID_TEXT_COORDSYS(CoordSys) || VALID_GEOM_COORDSYS(CoordSys)); REQUIRE(VALID_BOOLEAN(___227)); REQUIRE(IMPLICATION(___227, ___4598 >= 0)); REQUIRE(VALID_ENUM(___3441, Scope_e)); REQUIRE(VALID_BOOLEAN(IncludeZ)); REQUIRE(VALID_BOOLEAN(___4523)); fprintf(File, "CS="); if (CoordSys == CoordSys_Frame) { fprintf(File, "FRAME"); } else if (CoordSys == CoordSys_Grid) { fprintf(File, "GRID"); } else if (CoordSys == CoordSys_Grid3D) { fprintf(File, "GRID3D"); }
 #if 0 
else if (CoordSys == ___659) { fprintf(File,"FRAMEOFFSET"); }
 #endif
else { ___476(___1303); } if (CoordSys == CoordSys_Grid && !IncludeZ && ___4523) { fprintf(File, "\nTHETA=%.12G,R=%.12G", ___3432*___52->___4145.___4139, ___3432*___52->___4145.___3263); ___476(!IncludeZ); } else { fprintf(File, "\nX=%.12G,Y=%.12G", ___3432*___52->___4578.X, ___3432*___52->___4578.Y); if (IncludeZ) fprintf(File, ",Z=%.12G", ___3432*___52->___4578.Z); } if (___227) fprintf(File, "\nZN=%d", ___4598 + 1); fprintf(File, "\nC="); WriteAsciiColor(File, Color); fprintf(File, "\nS="); if (___3441 == ___3442) { fprintf(File, "GLOBAL"); } else { ___476(___3441 == ___3444); fprintf(File, "LOCAL"); } fputc('\n', File); } bool ___1130(___1403* ___1399, ___1630 const* ___1554, ___372     ___4483, ___372     ___4523) { ___2225       ___1830, ___1924; ___2225       SegIndex; bool            ___2038 = ___4224; FieldDataType_e ___1308; REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(VALID_REF(___1554)); REQUIRE(___1554->___1650 != GeomType_Image); if (___4483) { ___4491(___1399, ___1615, FieldDataType_Float); if (___1554->___3165 == CoordSys_Grid) { ___4488(___1399, 0); } else if (___1554->___3165 == CoordSys_Frame) { ___4488(___1399, 1); } else if (___1554->___3165 == CoordSys_Grid3D) { ___4488(___1399, 4); }
 #if 0 
else if (___1554->___3165 == ___659) { ___4488(___1399, 2); }
 #endif
else { ___476(___1303); } ___4488(___1399, (___2225)___1554->___3441); ___4488(___1399, (___2225)___1554->___1111); ___4491(___1399, ___1554->position.XOrTheta(), FieldDataType_Double); ___4491(___1399, ___1554->position.YOrR(), FieldDataType_Double); ___4491(___1399, ___1554->position.Z(), FieldDataType_Double); if (___1554->___227) ___4488(___1399, (___2225)___1554->___4598); else ___4488(___1399, (___2225) - 1); ___4488(___1399, (___2225)___1554->___351); ___4488(___1399, (___2225)___1554->___1408); ___4488(___1399, (___2225)___1554->___2021); ___476(___1554->___1650 != GeomType_LineSegs3D); ___4488(___1399, (___2225)___1554->___1650); ___4488(___1399, (___2225)___1554->___2262); ___4491(___1399, ___1554->___2985, FieldDataType_Double); ___4491(___1399, ___1554->___2288, FieldDataType_Double); ___4488(___1399, (___2225)___1554->___2792); ___4488(___1399, (___2225)___1554->___188); ___4488(___1399, (___2225)___1554->___176); ___4491(___1399, ___1554->___187, FieldDataType_Double); ___4491(___1399, ___1554->___171, FieldDataType_Double); ___1129(___1399, ___1554->___2329, ___4224); ___1308 = ___1745(___1554); ___4511(___1399, ___1308, ___4224); ___4488(___1399, (___2225)___1554->___494); if (___1554->___1650 == GeomType_LineSegs) { short S; ___4488(___1399, ___1554->___2834); ___1830 = 0; for (S = 0; ___2038 && (S < ___1554->___2834); S++) { ___4488(___1399, ___1554->___2836[S]); ___4485(___1399, ___1554->___1571.___1546.___4291, ___1830, ___1554->___2836[S]); ___2038 = ___4485(___1399, ___1554->___1571.___1546.___4293, ___1830, ___1554->___2836[S]) == ___4224; if (GEOM_USES_V3(___1554)) ___2038 = ___4485(___1399, ___1554->___1571.___1546.___4295, ___1830, ___1554->___2836[S]) == ___4224; ___1830 += ___1554->___2836[S]; } } else if (___1554->___1650 == GeomType_Rectangle || ___1554->___1650 == GeomType_Ellipse) { ___4491(___1399, ___1733(___1554->___1571.___4578.___4567, 0), ___1308); ___2038 = ___4491(___1399, ___1733(___1554->___1571.___4578.___4584, 0), ___1308) == ___4224; } else { ___476((___1554->___1650 == GeomType_Square) || (___1554->___1650 == GeomType_Circle)); ___2038 = ___4491(___1399, ___1733(___1554->___1571.___4578.___4567, 0), ___1308) == ___4224; } } else { double ___3432; if (___1554->___3165 == CoordSys_Frame) ___3432 = 100.0; else ___3432 = 1.0; fprintf(___1399->File, "GEOMETRY\nF=POINT\n"); ___54 const positon = ___1554->position.anchorPosition(); WriteAsciiTextGeomBasics(___1399->File, ___1554->___3165, ___1554->___227, ___1554->___4598, ___1554->___351, ___1554->___3441, ___4224, ___4523, &positon, ___3432); switch (___1554->___2262) { case ___2269      : fprintf(___1399->File, "L=SOLID\n"); break;
case ___2265     : fprintf(___1399->File, "L=DASHED\n"); break; case ___2263    : fprintf(___1399->File, "L=DASHDOT\n"); break; case ___2266     : fprintf(___1399->File, "L=DOTTED\n"); break; case ___2268   : fprintf(___1399->File, "L=LONGDASH\n"); break; case ___2264 : fprintf(___1399->File, "L=DASHDOTDOT\n"); break; default: ___476(___1303); break; } fprintf(___1399->File, "PL=%.12G\n", ___1554->___2985*PatternLengthInputSpec.___1976.___3432); fprintf(___1399->File, "LT=%.12G\n", ___1554->___2288*LineThicknessInputSpec.___1976.___3432); if (___1554->___2021) { fprintf(___1399->File, "FC="); WriteAsciiColor(___1399->File, ___1554->___1408); } if (___1554->___494 == ___496) { fprintf(___1399->File, "CLIPPING=CLIPTOVIEWPORT\n"); } else { ___476(___1554->___494 == ___495); fprintf(___1399->File, "CLIPPING=CLIPTOFRAME\n"); } if (___1554->___1111 == ___1112) { fprintf(___1399->File, "DRAWORDER=AFTERDATA\n"); } else { ___476(___1554->___1111 == ___1113); fprintf(___1399->File, "DRAWORDER=BEFOREDATA\n"); } fprintf(___1399->File, "MFC="); ___1129(___1399, ___1554->___2329, ___1303); if ((___1554->___1650 == GeomType_Circle) || (___1554->___1650 == GeomType_Ellipse)) fprintf(___1399->File, "EP=%lld\n", (lldfmt_t)___1554->___2792); if (___1554->___1650 == GeomType_LineSegs && ___1554->___3165 != CoordSys_Grid3D) { switch (___1554->___188) { case ___192  : fprintf(___1399->File, "AST=PLAIN\n"); break; case ___189 : fprintf(___1399->File, "AST=FILLED\n"); break; case ___190 : fprintf(___1399->File, "AST=HOLLOW\n"); break; default: ___476(___1303); break; } switch (___1554->___176) { case ___181        : break; case ___177 : fprintf(___1399->File, "AAT=BEGINNING\n"); break; case ___179       : fprintf(___1399->File, "AAT=END\n"); break; case ___178  : fprintf(___1399->File, "AAT=BOTH\n"); break; default: ___476(___1303); break; } if (___1554->___176 != ___181) { fprintf(___1399->File, "ASZ=%.12G\n", ___1554->___187*ArrowheadSizeInputSpec.___1976.___3432); fprintf(___1399->File, "AAN=%.12G\n", ___1554->___171*ArrowheadAngleInputSpec.___1976.___3432); } } switch (___1554->___1650) { case GeomType_LineSegs : { fprintf(___1399->File, "T=LINE\n"); fprintf(___1399->File, "DT="); ___4511(___1399, ___1724(___1554->___1571.___1546.___4291), ___1303); fputc('\n', ___1399->File); fprintf(___1399->File, "%d\n", (int)___1554->___2834); SegIndex = 0; for (___1830 = 0; ___2038 && (___1830 < ___1554->___2834); ___1830++) { fprintf(___1399->File, "%lld\n", (lldfmt_t)___1554->___2836[___1830]); for (___1924 = 0; ___1924 < ___1554->___2836[___1830]; ___1924++) { fprintf(___1399->File, "%.12G ", ___1733(___1554->___1571.___1546.___4291, SegIndex + ___1924)*___3432);
fprintf(___1399->File, "%.12G", ___1733(___1554->___1571.___1546.___4293, SegIndex + ___1924)*___3432); if (GEOM_USES_V3(___1554)) ___2038 = ___1480(fprintf(___1399->File, " %.12G\n", ___1733(___1554->___1571.___1546.___4295, SegIndex + ___1924))); else ___2038 = (___372)(fputc('\n', ___1399->File) != EOF); } SegIndex += ___1554->___2836[___1830]; } } break; case GeomType_Rectangle : { fprintf(___1399->File, "T=RECTANGLE %.12G %.12G\n", ___1733(___1554->___1571.___4578.___4567, 0)*___3432, ___1733(___1554->___1571.___4578.___4584, 0)*___3432); } break; case GeomType_Square : { fprintf(___1399->File, "T=SQUARE %.12G\n", ___1733(___1554->___1571.___4578.___4567, 0)*___3432); } break; case GeomType_Circle : { fprintf(___1399->File, "T=CIRCLE %.12G\n", ___1733(___1554->___1571.___4578.___4567, 0)*___3432); } break; case GeomType_Ellipse : { fprintf(___1399->File, "T=ELLIPSE %.12G %.12G\n", ___1733(___1554->___1571.___4578.___4567, 0)*___3432, ___1733(___1554->___1571.___4578.___4584, 0)*___3432); } break; default: ___476(___1303); } } return ___2038; } bool ___1131(___1403* ___1399, ___4116 const* Text, ___372     ___4483, ___372     ___4523) { REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(VALID_REF(Text)); REQUIRE(VALID_BOOLEAN(___4483)); REQUIRE(VALID_BOOLEAN(___4523)); if (___4483) { ___4491(___1399, ___4110, FieldDataType_Float); if (Text->___3165 == CoordSys_Grid) { ___4488(___1399, 0); } else if (Text->___3165 == CoordSys_Frame) { ___4488(___1399, 1); } else if (Text->___3165 == CoordSys_Grid3D) { ___4488(___1399, 4); }
 #if 0 
else if (___1554->___3165 == ___659) { ___4488(___1399, 2); }
 #endif
else { ___476(___1303); } ___4488(___1399, (___2225)Text->___3441); ___4491(___1399, Text->___52.___1546.___4290, FieldDataType_Double); ___4491(___1399, Text->___52.___1546.___4292, FieldDataType_Double); ___4491(___1399, Text->___52.___1546.___4294, FieldDataType_Double); { ___4488(___1399, static_cast<___2225>(Text->___4119.___1442)); } ___4488(___1399, (___2225)Text->___4119.___3599); ___4491(___1399, Text->___4119.___1825, FieldDataType_Double); ___4488(___1399, (___2225)Text->___401.___411); ___4491(___1399, Text->___401.___2336, FieldDataType_Double); ___4491(___1399, Text->___401.___2288, FieldDataType_Double); ___4488(___1399, (___2225)Text->___401.___351); ___4488(___1399, (___2225)Text->___401.___1408); ___4491(___1399, Text->___57, FieldDataType_Double); ___4491(___1399, Text->___2286, FieldDataType_Double); ___4488(___1399, (___2225)Text->___39); if (Text->___227) ___4488(___1399, (___2225)Text->___4598); else ___4488(___1399, (___2225) - 1); ___4488(___1399, (___2225)Text->___351); } else { double ___3432; ___372 IncludeZ = Text->___3165 == CoordSys_Grid3D; if (Text->___3165 == CoordSys_Frame) ___3432 = 100.0; else ___3432 = 1.0; fprintf(___1399->File, "TEXT\n"); WriteAsciiTextGeomBasics(___1399->File, Text->___3165, Text->___227, Text->___4598, Text->___351, Text->___3441, IncludeZ, ___4523, &Text->___52, ___3432); fprintf(___1399->File, "HU="); switch (Text->___4119.___3599) { case ___4267  : fprintf(___1399->File, "GRID\n"); break; case ___4266 : fprintf(___1399->File, "FRAME\n"); break; case ___4269 : fprintf(___1399->File, "POINT\n"); break; case ___4265 : default: ___476(___1303); break; } fprintf(___1399->File, "LS=%.4G ", Text->___2286); fprintf(___1399->File, "AN="); switch (Text->___39) { case ___4048       : fprintf(___1399->File, "LEFT\n");        break; case ___4043     : fprintf(___1399->File, "CENTER\n");      break; case ___4053      : fprintf(___1399->File, "RIGHT\n");       break; case ___4050    : fprintf(___1399->File, "MIDLEFT\n");     break; case ___4049  : fprintf(___1399->File, "MIDCENTER\n");   break; case ___4051   : fprintf(___1399->File, "MIDRIGHT\n");    break; case ___4045   : fprintf(___1399->File, "HEADLEFT\n");    break; case ___4044 : fprintf(___1399->File, "HEADCENTER\n");  break; case ___4046  : fprintf(___1399->File, "HEADRIGHT\n");   break; default: ___476(___1303); break; } switch (Text->___401.___411) { case ___4067 : fprintf(___1399->File, "BX=Hollow "); break; case ___4061 : fprintf(___1399->File, "BX=Filled "); break; default :;
} fprintf(___1399->File, "BXM=%.4G ", Text->___401.___2336*100); fprintf(___1399->File, "LT=%.4G ", Text->___401.___2288*100.0); fprintf(___1399->File, "BXO="); WriteAsciiColor(___1399->File, Text->___401.___351); fprintf(___1399->File, "BXF="); WriteAsciiColor(___1399->File, Text->___401.___1408); fprintf(___1399->File, "\nF="); Font_e ___1441; { ___1441 = Text->___4119.___1442; } switch (___1441) { case ___1452                  : fprintf(___1399->File, "HELV");                break; case ___1453              : fprintf(___1399->File, "HELV-BOLD");           break; case Font_HelveticaItalic            : fprintf(___1399->File, "HELV-ITALIC");         break; case Font_HelveticaItalicBold        : fprintf(___1399->File, "HELV-ITALIC-BOLD");    break; case ___1464                      : fprintf(___1399->File, "TIMES");               break; case ___1465                  : fprintf(___1399->File, "TIMES-BOLD");          break; case ___1466                : fprintf(___1399->File, "TIMES-ITALIC");        break; case ___1467            : fprintf(___1399->File, "TIMES-ITALIC-BOLD");   break; case ___1443                    : fprintf(___1399->File, "COURIER");             break; case ___1444                : fprintf(___1399->File, "COURIER-BOLD");        break; case Font_CourierItalic              : fprintf(___1399->File, "COURIER-ITALIC");      break; case Font_CourierItalicBold          : fprintf(___1399->File, "COURIER-ITALIC-BOLD"); break; case ___1447                      : fprintf(___1399->File, "GREEK");               break; case ___1457                       : fprintf(___1399->File, "MATH");                break; case ___1468                : fprintf(___1399->File, "USER-DEF");            break; default: ___476(___1303); break; } if (Text->___4119.___3599 == ___4266) ___3432 = 100.0; else ___3432 = 1.0; fprintf(___1399->File, "\nH=%.12G A=%.12G", Text->___4119.___1825*___3432, Text->___57*___952); } if (!___4483) fprintf(___1399->File, "\nMFC="); ___1129(___1399, Text->___2329.c_str(), ___4483); if (!___4483) { if (Text->___494 == ___496) { fprintf(___1399->File, "CLIPPING=CLIPTOVIEWPORT\n"); } else { ___476(Text->___494 == ___495); fprintf(___1399->File, "CLIPPING=CLIPTOFRAME\n"); } } else { ___4488(___1399, (___2225)Text->___494); } if (!___4483) fprintf(___1399->File, "T="); return ___1129(___1399, Text->Text.c_str(), ___4483) == ___4224; } ___372 ___1128(___1403  *___1399, ___372      ___4483, ___3837  ___2168) { ___372 ___2038 = ___4224; ___2225 ___1924 = 0; ___2225 ___682 = 0; REQUIRE(VALID_REF(___1399) && VALID_REF(___1399->File)); REQUIRE(VALID_BOOLEAN(___4483)); REQUIRE(___3846(___2168)); ___682 = ___3824(___2168);
if (___4483) { ___4491(___1399, ___790, FieldDataType_Float); ___4488(___1399, ___682); } else { fprintf(___1399->File, " CUSTOMLABELS = \n"); } for (___1924 = 0, ___2038 = ___4224; ___1924 < ___682 && ___2038; ___1924++) { const char *CurLabel = ___3833(___2168, ___1924); ___2038 = ___1129(___1399, CurLabel, ___4483); } ENSURE(VALID_BOOLEAN(___2038)); return ___2038; } ___372 ___4490(___1403 *___1399) { return (___4488(___1399, 1)); } bool ___4492(___1403& ___1398, int           ___4407) { char ___416[5]; sprintf(___416, "V%-3d", ___4407); ___476(strlen(___416) == 4); return fprintf(___1398.File, "#!TD%s", ___416) > 0; }
