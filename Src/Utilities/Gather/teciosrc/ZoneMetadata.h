 #pragma once
#include "ThirdPartyHeadersBegin.h"
#include <algorithm>
#include <string>
#include <vector>
#include "ThirdPartyHeadersEnd.h"
#include "basicTypes.h"
#include "IJK.h"
#include "IJKPartitionTree.h"
#include "IJKZoneInfo.h"
#include "FEZoneInfo.h"
#include "MinMaxTree.h"
#include "zoneUtil.h"
#include "ClassicZoneFileLocations.h"
#include "PartitionMetadata.h"
#include "writeValueArray.h"
namespace tecplot { namespace ___3931 { template<typename T> ___2088::SubzoneOffset_t getNumSzFromNumItems(T ___2810) { REQUIRE(___2810>0); ___2088::SubzoneOffset_t ___3356 = static_cast<___2088::SubzoneOffset_t>((___2810 + 0xFF) >> 8); ENSURE(___3356>0); return ___3356; } class ZoneMetadata { private: UNCOPYABLE_CLASS(ZoneMetadata); private: ___4634        ___2675; ZoneType_e         ___2682; bool               m_isSZL; ___1842                m_zoneIJK; std::string        ___2493; FaceNeighborMode_e ___2456; double             ___2619; ___1170         ___2620; ___4634        ___2612; ___2088::___2978 m_numPartitions; ___1861 m_partitionTree; public: ___2238<___1879> m_ijkZoneInfos; ___2238<___463> m_ptnNumCells; ___2238<___2716> m_ptnNumNodes; ___2238<___463> m_ptnFirstCell; ___2238<___2716> m_ptnFirstNode; ___2238<___1842>         m_ptnNodeMinIJKs; ___2238<___1842>         m_ptnNodeMaxIJKs; ___2238<___2088::SubzoneOffset_t> m_ptnNumCszs; ___2238<___2088::SubzoneOffset_t> m_ptnNumNszs; ___2238<___2088::___2978> m_ptnFileNums; ___2238<___1391>                m_ptnHeaderFileLocs; ___2238<___1391>                m_varPtnMinMaxFileLocs; ___2238<MinMaxTree>               m_varPtnMinMaxTrees; ___2238<PartitionMetadata> m_ptnMetadata; ClassicZoneFileLocations             m_classicZoneFileLocations; public: ZoneMetadata() : ___2675(-1) , ___2682(___4701) , m_isSZL(false) , m_zoneIJK() , ___2493() , ___2456(___1288) , ___2619(0.0) , ___2620(___3786) , ___2612(-1) , m_numPartitions(0) { } inline void swap(ZoneMetadata& ___2886) { using std::swap; swap(___2675, ___2886.___2675); swap(___2682, ___2886.___2682); swap(m_isSZL, ___2886.m_isSZL); swap(m_zoneIJK, ___2886.m_zoneIJK); swap(___2493, ___2886.___2493); swap(___2456, ___2886.___2456); swap(___2619, ___2886.___2619); swap(___2620, ___2886.___2620); swap(___2612, ___2886.___2612); swap(m_numPartitions, ___2886.m_numPartitions); } inline ___4634 zone() const { ENSURE(___2675>=0 && ___2675<MAX_NUM_ZONES); return ___2675; } inline ZoneType_e getZoneType() const { ENSURE(VALID_ENUM(___2682,ZoneType_e)); return ___2682; } inline bool isSZL() const { return m_isSZL; } inline ___1842 const& getZoneIJK() const { ENSURE(m_zoneIJK.___2065()); return m_zoneIJK; } inline ___463 ___1764() const { REQUIRE(___2682 != ___4696 && ___2682 != ___4697); if ( ___2682 == ___4702 ) return m_zoneIJK.getNumContiguousCells(); else return m_zoneIJK.___1666(); } inline ___2716 ___1766() const { REQUIRE(___2682 != ___4696 && ___2682 != ___4697); if ( ___2682 == ___4702 ) return m_zoneIJK.___1766();
else return m_zoneIJK.___1668(); } inline ___680 ___1667() const { REQUIRE(___2682 != ___4702 && ___2682 != ___4696 && ___2682 != ___4697); return m_zoneIJK.___1667(); } inline ___680 ___1765() const { REQUIRE(___2682 != ___4696 && ___2682 != ___4697); if ( ___2682 == ___4702 ) return 8; else return ___1667(); } inline std::string getName() const { return ___2493; } inline FaceNeighborMode_e getFaceNeighborMode() const { ENSURE(VALID_ENUM(___2456, FaceNeighborMode_e) || ___2456 == ___1286); return ___2456; } inline double getSolutionTime() const { return ___2619; } inline ___1170 getStrandID() const { REQUIRE(___2620==___3786 || ___4310(___2620)); return ___2620; } inline ___4634 getParentZone() const { REQUIRE(___2612==-1 || (___2612 >= 0 && ___2612 < MAX_NUM_ZONES)); return ___2612; } void setZone(___4634 zone) { REQUIRE(zone >= 0 && zone < MAX_NUM_ZONES); ___2675 = zone; } void setZoneType(ZoneType_e ___4690) { REQUIRE(VALID_ENUM(___4690, ZoneType_e)); ___2682 = ___4690; } inline void setIsSZL(bool isSZL) { m_isSZL = isSZL; } inline void setIJKMax(___1842 const& ijkDim) { REQUIRE(___2682==___4702); m_zoneIJK = ijkDim; } inline void setFEDescription( ___463 ___2779, ___680 ___2787, ___2716 ___2819) { REQUIRE(___2682 != ___4702 && ___2682 != ___4696 && ___2682 != ___4697); REQUIRE(___2779>0 && ___2779 <= MAX_NUM_CELLS); REQUIRE(___2819>0 && ___2819 <= MAX_NUM_NODES); REQUIRE(___2787>0 && ___2787<=MAX_NUM_CELL_CORNERS); m_zoneIJK = ___1842(___2819, ___2779, ___2787); } inline void setName(std::string const& ___2683) { ___2493 = ___2683; } inline void setFaceNeighborMode(FaceNeighborMode_e ___1282) { REQUIRE(VALID_ENUM(___1282, FaceNeighborMode_e) || ___1282 == ___1286); ___2456 = ___1282; } inline void setSolutionTime(double ___3638) { ___2619 = ___3638; } inline void setStrandID(___1170 ___3783) { ___2620 = ___3783; } inline void setParentZone(___4634 ___2972) { REQUIRE(___2972==-1 || (___2972 >= 0 && ___2972 < MAX_NUM_ZONES)); ___2612 = ___2972; } inline ___2088::___2978 getNumPartitions() const { REQUIRE(m_isSZL); ENSURE(VALID_ITEM_ADDRESS_PARTITION(m_numPartitions-1)); return m_numPartitions; } inline ___2088::SubzoneOffset_t getNumCszsInPartition(___2088::___2978 ___2975) const { REQUIRE(m_isSZL); REQUIRE(___2975<m_numPartitions); ___2088::SubzoneOffset_t const numCszs = m_ptnNumCszs[___2975]; ENSURE(IMPLICATION(___2682==___4702, VALID_ITEM_ADDRESS_SUBZONE_OFFSET(numCszs-1))); ENSURE(IMPLICATION(___2682!=___4702, numCszs == getNumSzFromNumItems(m_ptnNumCells[___2975])));
ENSURE(numCszs > 0); return numCszs; } inline ___2088::SubzoneOffset_t getNumNszsInPartition(___2088::___2978 ___2975) const { REQUIRE(m_isSZL); REQUIRE(___2975<m_numPartitions); ___2088::SubzoneOffset_t const numNszs = m_ptnNumNszs[___2975]; ENSURE(IMPLICATION(___2682==___4702, VALID_ITEM_ADDRESS_SUBZONE_OFFSET(numNszs-1))); ENSURE(IMPLICATION(___2682!=___4702, numNszs == getNumSzFromNumItems(m_ptnNumNodes[___2975]))); ENSURE(numNszs > 0); return numNszs; } inline void setNumPartitions(___2088::___2978 numPartitions) { REQUIRE(numPartitions >= 1 && (m_isSZL ? VALID_ITEM_ADDRESS_PARTITION(numPartitions-1) : numPartitions == 1)); m_numPartitions = numPartitions; ENSURE(VALID_ITEM_ADDRESS_PARTITION(m_numPartitions-1)); } inline void addPartitionTreeItem(___2088::___2978 ___2975, ___1842 const& ___2472, ___1842 const& ___2362) { m_partitionTree.___13(___2975, ___2472, ___2362); } inline ___2088::___2978 getPartitionForIJK(___1842 const& ___1841) const { if (m_numPartitions == 1) { return 0; } else { ___1851 ___2476(___1841.i(), ___1841.___2103(), ___1841.___2132()); ___1851 ___2370(___1841.i(), ___1841.___2103(), ___1841.___2132()); std::vector<___1862> ___2097; m_partitionTree.query(boost::geometry::index::intersects(___1853(___2476, ___2370)), std::back_inserter(___2097)); return (___2097.empty() ? ___2088::INVALID_PARTITION : ___2097[0].second); } } inline std::vector<___2088::___2978> getPartitionsForIJKRange(___1842 const& ijkMin, ___1842 const& ___1859) const { if (m_numPartitions == 1) { return std::vector<___2088::___2978>(1, 0); } else { ___1851 ___2476(ijkMin.i(), ijkMin.___2103(), ijkMin.___2132()); ___1851 ___2370(___1859.i(), ___1859.___2103(), ___1859.___2132()); std::vector<___1862> ___2097; m_partitionTree.query(boost::geometry::index::intersects(___1853(___2476, ___2370)), std::back_inserter(___2097)); std::vector<___2088::___2978> ___3356; ___3356.reserve(___2097.size()); for (std::vector<___1862>::const_iterator it = ___2097.begin(); it != ___2097.end(); ++it) ___3356.push_back(it->second); std::sort(___3356.begin(), ___3356.end()); return ___3356; } } inline std::vector<___2088::___2978> getPartitionsForIndexPlane(IJKPlanes_e whichPlane, ___2716 planeIndex) const { if (m_numPartitions == 1) { return std::vector<___2088::___2978>(1, 0); } else { ___1842 planeMin(0, 0, 0); ___1842 planeMax(getZoneIJK() - 1); switch (whichPlane) { case ___1865: planeMin.setI(planeIndex); planeMax.setI(planeIndex); break; case ___1870: planeMin.setJ(planeIndex); planeMax.setJ(planeIndex); break; case ___1872: planeMin.___3495(planeIndex); planeMax.___3495(planeIndex); break; default: ___476(___1303); break; } ___1851 ___2476(planeMin.i(), planeMin.___2103(), planeMin.___2132()); ___1851 ___2370(planeMax.i(), planeMax.___2103(), planeMax.___2132()); std::vector<___1862> ___2097; m_partitionTree.query(boost::geometry::index::intersects(___1853(___2476, ___2370)), std::back_inserter(___2097));
std::vector<___2088::___2978> ___3356; ___3356.reserve(___2097.size()); for (std::vector<___1862>::const_iterator it = ___2097.begin(); it != ___2097.end(); ++it) ___3356.push_back(it->second); std::sort(___3356.begin(), ___3356.end()); return ___3356; } } inline std::vector<___2088::___2978> getPartitionsForIndexLine(IJKLines_e whichLine, ___2716 mIndex, ___2716 nIndex) const { if (m_numPartitions == 1) { return std::vector<___2088::___2978>(1, 0); } else { ___1842 lineMin(0, 0, 0); ___1842 lineMax(getZoneIJK() - 1); switch (whichLine) { case ___1855: lineMin.setJ(mIndex); lineMin.___3495(nIndex); lineMax.setJ(mIndex); lineMax.___3495(nIndex); break; case ___1857: lineMin.setI(mIndex); lineMin.___3495(nIndex); lineMax.setI(mIndex); lineMax.___3495(nIndex); break; case ___1858: lineMin.setI(mIndex); lineMin.setJ(nIndex); lineMax.setI(mIndex); lineMax.setJ(nIndex); break; default: ___476(___1303); break; } ___1851 ___2476(lineMin.i(), lineMin.___2103(), lineMin.___2132()); ___1851 ___2370(lineMax.i(), lineMax.___2103(), lineMax.___2132()); std::vector<___1862> ___2097; m_partitionTree.query(boost::geometry::index::intersects(___1853(___2476, ___2370)), std::back_inserter(___2097)); std::vector<___2088::___2978> ___3356; ___3356.reserve(___2097.size()); for (std::vector<___1862>::const_iterator it = ___2097.begin(); it != ___2097.end(); ++it) ___3356.push_back(it->second); std::sort(___3356.begin(), ___3356.end()); return ___3356; } } inline bool ijkPartitionMetadataIsLoaded(___2088::___2978 ___2975) const { return ___2975 < m_ijkZoneInfos.size() && m_ijkZoneInfos[___2975].___2065(); } inline ___2088 cellAddressAtIJKPaddedCellIndex(___463 paddedCellIndex) const { REQUIRE(paddedCellIndex < getZoneIJK().getNumPaddedCells()); ___2088 ___449; if (getNumPartitions() == 1) { ___449 = m_ijkZoneInfos[0].cellAddressAtPaddedCellIndex(paddedCellIndex); } else { ___1842 const ___4630 = getZoneIJK().ijkAtOffset(paddedCellIndex); ___2088::___2978 const ___2975 = getPartitionForIJK(___4630); ___476(ijkPartitionMetadataIsLoaded(___2975)); ___1842 partitionIJK = ___4630 - m_ptnNodeMinIJKs[___2975]; if (partitionIJK.i() == m_ijkZoneInfos[___2975].___2893().i() - 1) partitionIJK.setI(partitionIJK.i() - 1); if (partitionIJK.___2103() == m_ijkZoneInfos[___2975].___2893().___2103() - 1) partitionIJK.setJ(partitionIJK.___2103() - 1); ___449 = m_ijkZoneInfos[___2975].cellAddressAtCellIJK(partitionIJK); ENSURE(___449.___2975() == ___2975); } return ___449; } inline ___2088 nodeAddressAtIJKNodeIndex(___2716 ___2714) const { ___2088 nodeAddress; if (getNumPartitions() == 1) { nodeAddress = m_ijkZoneInfos[0].nodeAddressAtNodeIndex(___2714); } else { ___1842 const ___4630 = getZoneIJK().ijkAtOffset(___2714); ___2088::___2978 const ___2975 = getPartitionForIJK(___4630); ___476(ijkPartitionMetadataIsLoaded(___2975)); ___1842 const partitionIJK = ___4630 - m_ptnNodeMinIJKs[___2975];
nodeAddress = m_ijkZoneInfos[___2975].nodeAddressAtNodeIJK(partitionIJK); ENSURE(nodeAddress.___2975() == ___2975); } return nodeAddress; } inline void findPartitionContainingIndex( ___81&                          ptnItemIndex, ___2088::___2978&            ___2975, ___2238<___81> const& ptnNumItems) const { ___2088::___2978 numPartitions = getNumPartitions(); if ( numPartitions > 1 ) { while (true) { ___2716 const numPtnItems = ptnNumItems[___2975]; if ( ptnItemIndex < numPtnItems ) break; ptnItemIndex -= numPtnItems; ++___2975; ___476(___2975 < numPartitions); } } } inline ___2088 itemAddressAtFEIndex( ___81                           itemIndex, ___2238<___81> const& ptnNumItems) const { ___81 ptnItemIndex = itemIndex; ___2088::___2978 ___2975 = 0; findPartitionContainingIndex(ptnItemIndex, ___2975, ptnNumItems); ___2088::SubzoneOffset_t  const ___2761 = ___2088::SubzoneOffset_t(ptnItemIndex >> ___2088::ItemOffsetBitSize); ___2088::ItemOffset_t const itemOffset = ___2088::ItemOffset_t(ptnItemIndex & ___2088::MAX_ITEM_OFFSET); return ___2088(___2975, ___2761, itemOffset); } inline ___81 indexAtFEItemAddress( ___2088                          ___2087, ___2238<___81> const& ptnNumItems) const { ___81 itemIndex = (___81(___2087.subzoneOffset())<<___2088::ItemOffsetBitSize) | ___2087.itemOffset(); ___2088::___2978 ___2975 = ___2087.___2975(); while ( ___2975 > 0 ) { --___2975; itemIndex += ptnNumItems[___2975]; } return itemIndex; } ___2088 cellAddressAtFECellIndex(___463 zoneCellIndex) const { REQUIRE(zoneCellIndex < ___1764()); return itemAddressAtFEIndex(zoneCellIndex, m_ptnNumCells); } ___463 cellIndexAtFECellAddress(___2088 ___449) const { REQUIRE(VALID_ITEM_ADDRESS(___449)); return indexAtFEItemAddress(___449, m_ptnNumCells); } ___2088 nodeAddressAtFENodeIndex(___2716 zoneNodeIndex) const { REQUIRE(zoneNodeIndex < ___1766()); return itemAddressAtFEIndex(zoneNodeIndex, m_ptnNumNodes); } ___2716 nodeIndexAtFENodeAddress(___2088 nodeAddress) const { REQUIRE(m_isSZL); REQUIRE(VALID_ITEM_ADDRESS(nodeAddress)); return indexAtFEItemAddress(nodeAddress, m_ptnNumNodes); } ___463 paddedCellIndexAtIJKCellAddress(___2088 ___449) const { ___463 paddedCellIndex; if (getNumPartitions() == 1) { paddedCellIndex = m_ijkZoneInfos[0].paddedCellIndexAtCellAddress(___449); } else { ___2088::___2978 const ___2975 = ___449.___2975(); ___476(ijkPartitionMetadataIsLoaded(___2975)); ___1842 const cellIJK = m_ptnNodeMinIJKs[___2975] + m_ijkZoneInfos[___2975].cellIJKAtCellAddress(___449); paddedCellIndex = getZoneIJK().offsetAtIJK(cellIJK); } ENSURE(paddedCellIndex < getZoneIJK().getNumPaddedCells()); return paddedCellIndex; } ___2716 nodeIndexAtIJKNodeAddress(___2088 nodeAddress) const
{ REQUIRE(getZoneType() == ___4702); ___2716 ___2714; if (getNumPartitions() == 1) { ___2714 = m_ijkZoneInfos[0].nodeIndexAtNodeAddress(nodeAddress); } else { ___2088::___2978 const ___2975 = nodeAddress.___2975(); ___476(ijkPartitionMetadataIsLoaded(___2975)); ___1842 const nodeIJK = m_ptnNodeMinIJKs[___2975] + m_ijkZoneInfos[___2975].nodeIJKAtNodeAddress(nodeAddress); ___2714 = getZoneIJK().offsetAtIJK(nodeIJK); } ENSURE(___2714 < ___1766()); return ___2714; } ___463 getNumIJKFaceNeighbors( ___2088 ___449, FaceIndex_t ___455) const { REQUIRE(m_isSZL); REQUIRE(___455 < NUM_IJK_CELL_FACES); ___2088::___2978 const ___2975 = ___449.___2975(); ___476(ijkPartitionMetadataIsLoaded(___2975)); return m_ijkZoneInfos[___2975].getNumIJKFaceNeighbors(___449, ___455); } void getIJKFaceNeighbor( ___2088  ___449, FaceIndex_t  ___455, ___463  neighborOffset, ___2088& fnCoord, ___4634& fnZone) const { REQUIRE(___449.isSzlItem()); REQUIRE(m_isSZL); REQUIRE(___455 < NUM_IJK_CELL_FACES); REQUIRE(neighborOffset < getNumIJKFaceNeighbors(___449, ___455)); ___2088::___2978 const ___2975 = ___449.___2975(); ___476(ijkPartitionMetadataIsLoaded(___2975)); m_ijkZoneInfos[___2975].getIJKFaceNeighbor(___449, ___455, neighborOffset, fnCoord, fnZone); if (fnCoord == ___2088(___2747) && getNumPartitions() > 1) { ___1842 neighborCellIJK = m_ijkZoneInfos[___2975].cellIJKAtCellAddress(___449) + m_ptnNodeMinIJKs[___2975] + ___1879::ijkFaceNeighborOffset[___455]; if (0 <= neighborCellIJK && neighborCellIJK < getZoneIJK()) { ___2088::___2978 neighborPartition = getPartitionForIJK(neighborCellIJK); neighborCellIJK -= m_ptnNodeMinIJKs[neighborPartition]; if (neighborCellIJK <= m_ijkZoneInfos[neighborPartition].___2196()) fnCoord = m_ijkZoneInfos[neighborPartition].cellAddressAtCellIJK(neighborCellIJK); } } } void getIJKFaceNeighbors( ___2088            ___449, FaceIndex_t            ___455, ___3267<___2088>& cellNeighbors, ___3267<___4634>& zoneNeighbors, bool&                  isFaceCompletelyObscured) const { REQUIRE(VALID_ITEM_ADDRESS(___449)); REQUIRE(___455 < NUM_IJK_CELL_FACES); REQUIRE(cellNeighbors.empty()); REQUIRE(zoneNeighbors.empty()); ___2088 szlCellAddr; bool const isCellAddressUniform = ___449.___2063(); if (isCellAddressUniform) { ___463 const paddedCellIndex = ___463(___449.___4256()); szlCellAddr = cellAddressAtIJKPaddedCellIndex(paddedCellIndex); } else { szlCellAddr = ___449; } ___463 const numNeighbors = getNumIJKFaceNeighbors(szlCellAddr, ___455); ___476(numNeighbors != 0); isFaceCompletelyObscured = true; cellNeighbors.reserve(numNeighbors); cellNeighbors.___3501(numNeighbors); zoneNeighbors.reserve(numNeighbors); zoneNeighbors.___3501(numNeighbors); for (___463 n = 0; n < numNeighbors; ++n) { ___2088 fnCoord;
___4634 fnZone; getIJKFaceNeighbor(szlCellAddr, ___455, n, fnCoord, fnZone); if (fnCoord.___2063() && fnCoord.___4256() == ___2747) { ___476(fnZone == ___2748); cellNeighbors[n] = ___2088(___2747); zoneNeighbors[n] = ___2748; } else if (isCellAddressUniform) { cellNeighbors[n] = ___2088(paddedCellIndexAtIJKCellAddress(fnCoord)); zoneNeighbors[n] = fnZone; } else { cellNeighbors[n] = fnCoord; zoneNeighbors[n] = fnZone; } } ENSURE(!cellNeighbors.empty()); ENSURE(cellNeighbors.size() == zoneNeighbors.size()); } }; }}
