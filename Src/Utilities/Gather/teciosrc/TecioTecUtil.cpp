#include "TecioTecUtil.h"
#include "ThirdPartyHeadersBegin.h"
#include <algorithm>
#include <cfloat>
#include <cstring>
#include <limits>
#include <map>
#include <set>
#include <sstream>
#include <boost/shared_ptr.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "MASTER.h"
#include "GLOBAL.h"
#include "FieldData_s.h"
#include "NodeMap_s.h"
#include "NodeToElemMap_s.h"
 #if defined TECIOMPI
struct ___2120 {}; struct ___2663 {};
 #else
#include "JobControl_s.h"
#include "Mutex_s.h"
 #endif
using namespace tecplot::___3931; namespace { tecplot::tecioszl::___1360* toSzlioFieldData(___1359 ___1349) { return reinterpret_cast<tecplot::tecioszl::___1360*>(___1349); } ___1359 toTecUtilFieldData(tecplot::tecioszl::___1360* ___1349) { return reinterpret_cast<___1359>(___1349); } } namespace { tecplot::tecioszl::___2728* toSzlioNodeMap(___2725 ___2721) { return reinterpret_cast<tecplot::tecioszl::___2728*>(___2721); } ___2725 toTecUtilNodeMap(tecplot::tecioszl::___2728* ___2721) { return reinterpret_cast<___2725>(___2721); } } namespace { tecplot::tecioszl::___2741* toSzlioNodeToElemMap(___2740 nodeToElem) { return reinterpret_cast<tecplot::tecioszl::___2741*>(nodeToElem); } ___2740 toTecUtilNodeToElemMap(tecplot::tecioszl::___2741* nodeToElem) { return reinterpret_cast<___2740>(nodeToElem); } } struct StringList_s { std::vector<std::string> m_strings; }; namespace tecplot { namespace tecioszl { namespace { char* copyString(std::string const& str) { char* ___3356 = new char[strlen(str.c_str()) + 1]; strcpy(___3356, str.c_str()); return ___3356; } } ___4014::___4014(___3968& tecioData) : m_tecioData(tecioData) {} ___4014::~___4014() {} void ___4014::___3815(char** ___3853) const { delete[] *___3853; *___3853 = 0; } void ___4014::___3825(___3837* ___3817) const { delete *___3817; *___3817 = 0; } ___2225 ___4014::___3830(___3837 ___3817) const { return (___2225)___3817->m_strings.size(); } char* ___4014::___3831(___3837 ___3817, ___2225 ___3851) const { REQUIRE(0 < ___3851 && ___3851 <= ___3830(___3817)); return copyString(___3817->m_strings[___3851 - 1]); } ___264 ___4014::___235() const { return m_tecioData.dataSetAuxData().get(); } ___264 ___4014::___274(___4634 zone) const { REQUIRE(m_tecioData.validZoneNum(zone)); Zone_s const* zonePtr = m_tecioData.zonePtr(zone); return zonePtr->___2343.get(); } ___264 ___4014::___273(___4350 ___4334) const { REQUIRE(0 < ___4334 && ___4334 <= static_cast<___1170>(m_tecioData.variableNames().size())); return m_tecioData.varAuxData()[___4334 - 1].get(); } int32_t ___4014::___247(___264 ___265) const { return static_cast<int32_t>(___265->m_auxDataItems.size()); } void ___4014::___243(___264 ___265, int32_t index, char** ___2683, ___90* ___4312, AuxDataType_e* type, ___372* ___3359) const { REQUIRE(VALID_REF(___265)); REQUIRE(0 < index && (size_t)index <= ___265->m_auxDataItems.size()); REQUIRE(VALID_REF(___2683) && *___2683 == 0); REQUIRE(VALID_REF(___4312) && *___4312 == 0); REQUIRE(VALID_REF(type)); REQUIRE(VALID_REF(___3359)); AuxData_s::AuxDataItem const& auxDataItem = ___265->m_auxDataItems[index - 1]; *___2683 = copyString(auxDataItem.___2493);
*___4312 = reinterpret_cast<___90>(copyString(auxDataItem.___2665)); *type = ___270; *___3359 = auxDataItem.m_retain; } ___372 ___4014::___894() const { return static_cast<___372>(m_tecioData.___894()); } ___372 ___4014::datasetGetTitle(char** datasetTitle) const { *datasetTitle = copyString(m_tecioData.___4175()); return ___4224; } int32_t ___4014::___887() const { return 0; } ___3499 ___4014::datasetGetRelevantZones(double  , double /*solutionTimeMax*/, ___372 /*ignoreStaticZones*/) const { ___476(___1303); return ___3499(0); } ___4634 ___4014::___889() const { REQUIRE(___894()); return static_cast<___4634>(m_tecioData.___2844()); } ___4350 ___4014::___888() const { REQUIRE(___894()); return static_cast<___4350>(m_tecioData.variableNames().size()); } ___4350 ___4014::___4343(char ___214) const { REQUIRE('X' <= ___214 && ___214 <= 'Z'); return static_cast<___4350>(___214 - 'X' + 1); } ___372 ___4014::___4342(___4350 ___4366, char** ___4360) const { REQUIRE(0 < ___4366 && ___4366 <= static_cast<___4350>(m_tecioData.variableNames().size())); REQUIRE(VALID_REF(___4360) && !*___4360); *___4360 = copyString(m_tecioData.variableNames()[___4366 - 1]); return ___4224; } int32_t ___4014::___4341(___4350 ___4366) const { REQUIRE(0 < ___4366 && ___4366 <= static_cast<___4350>(m_tecioData.variableNames().size())); return static_cast<int32_t>(m_tecioData.varAuxData()[___4366]->m_auxDataItems.size()); } ___372 ___4014::___4636(___4634 ___4656) const { return (m_tecioData.zonePtr(___4656) != NULL) ? ___4224 : ___1303; } ___372 ___4014::___4612(___3499* ___1151) const { try { std::set<___3491>* ___3356 = new std::set<___3491>(m_tecioData.unflushedZoneSet()); *___1151 = reinterpret_cast<___3499>(___3356); return ___4224; } catch (...) { return ___1303; } } ZoneType_e ___4014::___4618(___4634 ___4656) const { REQUIRE(m_tecioData.validZoneNum(___4656)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4656); return zonePtr->___2682; } void ___4014::___4613(___4634 ___4656, ___1842& ___2713) const { REQUIRE(m_tecioData.validZoneNum(___4656)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4656); ___2713 = zonePtr->___2680; } ___372 ___4014::___4614(___4634 ___4656, char** ___4650) const { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(VALID_REF(___4650) && !*___4650); Zone_s const* zonePtr = m_tecioData.zonePtr(___4656); *___4650 = copyString(zonePtr->___2681); return ___4224; } ___4634 ___4014::___4615(___4634 ___4656) const { REQUIRE(m_tecioData.validZoneNum(___4656)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4656); return zonePtr->___2612; } double ___4014::___4616(___4634 ___4656) const
{ REQUIRE(m_tecioData.validZoneNum(___4656)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4656); return zonePtr->___2619; } ___1170 ___4014::___4617(___4634 ___4656) const { REQUIRE(m_tecioData.validZoneNum(___4656)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4656); return zonePtr->___2620; } int32_t ___4014::___4611(___4634 ___4656) const { REQUIRE(m_tecioData.validZoneNum(___4656)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4656); return static_cast<int32_t>(zonePtr->___2343->m_auxDataItems.size()); } ___372 ___4014::___4638(___4634 ___4656) const { REQUIRE(m_tecioData.validZoneNum(___4656)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4656); return static_cast<___372>(zonePtr->___2682 != ___4702); } ___372 ___4014::___4639(tecplot::___3931::___4634 ___4656) const { REQUIRE(m_tecioData.validZoneNum(___4656)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4656); return static_cast<___372>(zonePtr->___2682 == ___4702); } ___372 ___4014::___4351(___4350 ASSERT_ONLY(___4366)) const { REQUIRE(0 < ___4366 && ___4366 <= static_cast<___4350>(m_tecioData.variableNames().size())); return ___4224; } ___372 ___4014::varGetEnabled(___3499* enabledVars) const { ___476(___1303); *enabledVars = ___3499(0); return ___4224; } int32_t ___4014::solutionTimeGetNumTimeSteps() const { ___476(___1303); return 0; } double ___4014::solutionTimeGetMinTime() const { ___476(___1303); return 0.0; } double ___4014::solutionTimeGetMaxTime() const { ___476(___1303); return 0.0; } ___372 ___4014::___3766() const { return ___4224; } GeomID_t ___4014::___1590(void) { if (!m_tecioData.geoms().empty()) return reinterpret_cast<GeomID_t>(&m_tecioData.geoms()[0]); return ___4033; } TextID_t ___4014::___4085(void) { if (!m_tecioData.texts().empty()) return reinterpret_cast<TextID_t>(&m_tecioData.texts()[0]); return ___4033; } int32_t ___4014::___795(void) { return (int32_t)m_tecioData.customLabels().size(); } ___372 ___4014::___794(___3837* ___2169, int32_t ___4451) { REQUIRE(0 < ___4451 && ___4451 <= (int32_t)m_tecioData.customLabels().size()); try { *___2169 = new StringList_s; (*___2169)->m_strings = m_tecioData.customLabels()[___4451 - 1]; return ___4224; } catch(...) { return ___1303; } } void ___4014::___856() { } void ___4014::___857() { } void ___4014::___3777(char const* ___2999, ___372 ___3582, ___372 ___3577) const { ___4276(___2999); ___4276(___3582); ___4276(___3577); } void ___4014::___3776(char const* ___2999) const { ___4276(___2999); } ___372 ___4014::___3767(int percentDone) const { ___4276(percentDone); return ___4224; } void ___4014::___3768(void) const
{ } ___372 ___4014::___1981(void) const { return ___1303; } ___4634 ___4014::___542(___3499 ___4682, ___4634 ___4656) const { REQUIRE(m_tecioData.validZoneNum(___4656)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4656); std::set<___3491>* ___4669 = reinterpret_cast<std::set<___3491>*>(___4682); if (!zonePtr->m_shareConnectivityFromZone) return ___4033; else if (!___4669 || ___4669->find(zonePtr->m_shareConnectivityFromZone) != ___4669->end()) return zonePtr->m_shareConnectivityFromZone; return ___4033; } ___3499 ___4014::___543(___4634 zone) const { REQUIRE(m_tecioData.validZoneNum(zone)); Zone_s const* zonePtr = m_tecioData.zonePtr(zone); try { std::set<___3491>* ___3356 = new std::set<___3491>; if (zonePtr->___2495) { ___4634 const ___341 = m_tecioData.baseZoneForConnectivity(zone); std::set<___3491> const zoneSet = m_tecioData.zoneSet(); for (std::set<___3491>::const_iterator ___4656 = zoneSet.begin(); ___4656 != zoneSet.end(); ++___4656) { if (m_tecioData.baseZoneForConnectivity(static_cast<___4634>(*___4656)) == ___341) ___3356->insert(*___4656); } } return reinterpret_cast<___3499>(___3356); } catch (...) { return NULL; } } ValueLocation_e ___4014::___908(___4634 ___4656, ___4350 ___4366) const { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(0 < ___4366 && ___4366 <= static_cast<___4350>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtr(___4656); return zonePtr->___2668[___4366 - 1]; } ValueLocation_e ___4014::___909(___1359 ___1349) const { REQUIRE(VALID_REF(___1349)); return toSzlioFieldData(___1349)->___2667; } ___372 ___4014::___911( ___4634 ___4656, ___4350 ___4334, double* minVal, double* maxVal) const { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(0 < ___4334 && ___4334 <= static_cast<___4350>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4656, ___4334); if (zoneIsPartitioned(___4656)) { if (zonePtr->m_partitionMap.empty()) { *minVal = 0.0; *maxVal = 0.0; } else { *minVal = std::numeric_limits<double>::max(); *maxVal = -std::numeric_limits<double>::max(); for (Zone_s::ZoneMap::const_iterator valuePair = zonePtr->m_partitionMap.begin(); valuePair != zonePtr->m_partitionMap.end(); ++valuePair) { double partitionMinVal = 0.0; double partitionMaxVal = 0.0; valuePair->second->___2494[___4334 - 1]->___1757(partitionMinVal, partitionMaxVal); *minVal = std::min(*minVal, partitionMinVal); *maxVal = std::max(*maxVal, partitionMaxVal); } } } else if (zonePtr->___2494[___4334 - 1]) { zonePtr->___2494[___4334 - 1]->___1757(*minVal, *maxVal); } else { ___476(zonePtr->m_shareVarFromZone[___4334 - 1] != 0); *minVal = 0.0; *maxVal = 0.0; } ENSURE(*minVal <= *maxVal); return ___4224; } ___372 ___4014::___910(
___1359 ___1349, double* minVal, double* maxVal) const { toSzlioFieldData(___1349)->___1757(*minVal, *maxVal); return ___4224; } FieldDataType_e ___4014::___921(___4634 ___4656, ___4350 ___4366) { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(0 < ___4366 && ___4366 <= static_cast<___4350>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtr(___4656); return zonePtr->___2458[___4366 - 1]; } ___1170 ___4014::___919(___4634 ___4656, ___4350 ___4366) { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(0 < ___4366 && ___4366 <= static_cast<___4350>(m_tecioData.variableNames().size())); ___1170 shareCount = 0; ___3499 shareSet = ___920(___4656, ___4366); if (shareSet) { shareCount = checked_numeric_cast<___1170>(setGetMemberCount(shareSet)); ___3482(&shareSet); } return shareCount; } ___1359 ___4014::___916(___4634 ___4656, ___4350 ___4366) { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(0 < ___4366 && ___4366 <= static_cast<___4350>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4656, ___4366); if (zonePtr->___2494[___4366 - 1]->___2667 == ___4328) return ___915(___4656, ___4366); else return ___914(___4656, ___4366); } ___1359 ___4014::___913(___4634 ___4656, ___4350 ___4366) { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(0 < ___4366 && ___4366 <= static_cast<___4350>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4656, ___4366); if (zonePtr->___2494[___4366 - 1]->___2667 == ___4326) return ___915(___4656, ___4366); else return ___914(___4656, ___4366); } ___1359 ___4014::___915(___4634 ___4656, ___4350 ___4366) { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(0 < ___4366 && ___4366 <= static_cast<___4350>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4656, ___4366); return toTecUtilFieldData(zonePtr->___2494[___4366 - 1].get()); } ___1359 ___4014::___914(___4634 ___4656, ___4350 ___4366) { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(0 < ___4366 && ___4366 <= static_cast<___4350>(m_tecioData.variableNames().size())); Zone_s* zonePtr = m_tecioData.zonePtrForVar(___4656, ___4366); try { if (zonePtr->___2398[___4366 - 1]->storedValueCount() == 0) { Zone_s* connectivityZonePtr = m_tecioData.zonePtrForConnectivity(___4656); if (zonePtr->___2494[___4366 - 1]->___2667 == ___4326) zonePtr->___963(___4366, connectivityZonePtr->___2495.get()); else zonePtr->deriveCCValues(___4366, connectivityZonePtr->___2495.get());
} } catch (std::exception const&) { } return toTecUtilFieldData(zonePtr->___2398[___4366 - 1].get()); } ___1359 ___4014::___922(___4634 ___4656, ___4350 ___4366) { return ___915(___4656, ___4366); } namespace { double fieldValueGetFunction(___1359 ___1349, ___2225 ___2731) { REQUIRE(VALID_REF(___1349)); REQUIRE(0 <= ___2731); tecplot::tecioszl::___1360* const szlioFD = toSzlioFieldData(___1349); size_t index = static_cast<size_t>(___2731); REQUIRE(szlioFD->___2666 == 0 || index < szlioFD->___2666); if (index < szlioFD->___2666) return szlioFD->___1778(index); return 0.0; } void fieldValueSetFunction(___1359 ___1349, ___2225 ___2731, double ___4296) { REQUIRE(VALID_REF(___1349)); REQUIRE(0 <= ___2731); tecplot::tecioszl::___1360* const szlioFD = toSzlioFieldData(___1349); size_t index = static_cast<size_t>(___2731); REQUIRE(szlioFD->___2666 == 0 || index < szlioFD->___2666); if (index < szlioFD->___2666) szlioFD->___3502(index, ___4296); } } double ___4014::___907(___1359 ___1349, ___81 ___2731) { REQUIRE(VALID_REF(___1349)); REQUIRE(0 < ___2731); return fieldValueGetFunction(___1349, ___2731 - 1); } void ___4014::dataValueSetByRef(___1359 ___1349, ___81 ___2731, double ___4296) { REQUIRE(VALID_REF(___1349)); REQUIRE(0 < ___2731); fieldValueSetFunction(___1349, ___2731 - 1, ___4296); } void ___4014::___917(___4634 ___4656, ___4350 ___4366, void** ___878, FieldDataType_e* ___1361) { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(0 < ___4366 && ___4366 <= static_cast<___4350>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4656, ___4366); *___878 = zonePtr->___2494[___4366 - 1]->getRawPointer(); *___1361 = zonePtr->___2494[___4366 - 1]->___2457; } void ___4014::___923(___4634 ___4656, ___4350 ___4366, void** ___878, FieldDataType_e* ___1361) { ___917(___4656, ___4366, ___878, ___1361); } ___4634 ___4014::___912(___3499 ___4682, ___4634 ___4656, ___4350 ___4334) const { REQUIRE(m_tecioData.validZoneNum(___4656)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4656); std::set<___3491>* ___4669 = reinterpret_cast<std::set<___3491>*>(___4682); if (zonePtr->m_shareVarFromZone.empty() || zonePtr->m_shareVarFromZone[___4334 - 1] == 0) return ___4033; else if (___4669 == NULL || ___4669->find(zonePtr->m_shareVarFromZone[___4334 - 1]) != ___4669->end()) return zonePtr->m_shareVarFromZone[___4334 - 1]; return ___4033; } ___3499 ___4014::___920(___4634 ___4656, ___4350 ___4366) const { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(0 < ___4366 && ___4366 <= static_cast<___4350>(m_tecioData.variableNames().size()));
___4634 const ___341 = m_tecioData.baseZoneForVar(___4656, ___4366); try { std::set<___3491>* ___3356 = new std::set<___3491>; std::set<___3491> const zoneSet = m_tecioData.zoneSet(); for (std::set<___3491>::const_iterator zoneNumber = zoneSet.begin(); zoneNumber != zoneSet.end(); ++zoneNumber) { if (m_tecioData.baseZoneForVar(checked_numeric_cast<___4634>(*zoneNumber), ___4366) == ___341) ___3356->insert(*zoneNumber); } return reinterpret_cast<___3499>(___3356); } catch (...) { return NULL; } } ___372 ___4014::___924(___4634 ___4656, ___4350 ___4366) const { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(0 < ___4366 && ___4366 <= static_cast<___4350>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtr(___4656); return (zonePtr->m_passiveVars[___4366 - 1] != 0); } ___1381 ___4014::___925(___1359 ___1307) { ___4276(___1307); return fieldValueGetFunction; } ___1382 ___4014::___926(___1359 ___1307) { ___4276(___1307); return fieldValueSetFunction; } FieldDataType_e ___4014::___918(___1359 ___1349) { return toSzlioFieldData(___1349)->___2457; } ___2725 ___4014::___865(___4634 ___4656) { REQUIRE(m_tecioData.validZoneNum(___4656)); Zone_s const* zonePtr = m_tecioData.zonePtrForConnectivity(___4656); return toTecUtilNodeMap(zonePtr->___2495.get()); } ___2725 ___4014::___867(___4634 ___4656) { REQUIRE(m_tecioData.validZoneNum(___4656)); Zone_s const* zonePtr = m_tecioData.zonePtrForConnectivity(___4656); return toTecUtilNodeMap(zonePtr->___2495.get()); } ___2716 ___4014::___863( ___2725 ___2721, ___463 ___466, ___680 ___681) { tecplot::tecioszl::___2728* const szlioNM = toSzlioNodeMap(___2721); REQUIRE(VALID_REF(szlioNM)); REQUIRE(0 < ___466 && ___466 <= static_cast<___463>(szlioNM->___2390)); REQUIRE(0 < ___681 && ___681 <= szlioNM->___2498); ___463 ___460 = ___466 - 1; int64_t ___2714 = szlioNM->___4312(___460 * szlioNM->___2498 + ___681 - 1); return (___2716)___2714 + 1; } void ___4014::___868(___2725 ___2721, ___463 ___466, ___680 ___681, ___2716 ___2714) { tecplot::tecioszl::___2728* const szlioNM = toSzlioNodeMap(___2721); REQUIRE(VALID_REF(szlioNM)); REQUIRE(0 < ___466 && ___466 <= static_cast<___463>(szlioNM->___2390)); REQUIRE(0 < ___681 && ___681 <= szlioNM->___2498); szlioNM->___3502((___466 - 1) * szlioNM->___2498 + ___681 - 1, ___2714 - 1); } OffsetDataType_e ___4014::dataNodeGetRawItemType(___2725 ___2721) { REQUIRE(VALID_REF(___2721)); return toSzlioNodeMap(___2721)->getRawItemType(); } int32_t* ___4014::dataNodeGetRawPtrByRef(___2725 ___2721) { REQUIRE(VALID_REF(___2721)); return reinterpret_cast<int32_t*>(toSzlioNodeMap(___2721)->getRawPtr());
} int64_t* ___4014::dataNodeGetRawPtrByRef64(___2725 ___2721) { REQUIRE(VALID_REF(___2721)); return reinterpret_cast<int64_t*>(toSzlioNodeMap(___2721)->getRawPtr()); } ___2740 ___4014::dataNodeToElemMapGetReadableRef(___4634 ___4656) const { REQUIRE(m_tecioData.validZoneNum(___4656)); Zone_s* zonePtr = m_tecioData.zonePtrForConnectivity(___4656); if (!zonePtr->m_nodeToElemMap) zonePtr->m_nodeToElemMap.reset(new ___2741(*zonePtr->___2495, zonePtr->___2680.___1668())); return toTecUtilNodeToElemMap(zonePtr->m_nodeToElemMap.get()); } ___463 ___4014::dataNodeToElemMapGetNumElems(___2740 nodeToElemMap, ___2716 ___2707) const { tecplot::tecioszl::___2741* const szlioNEM = toSzlioNodeToElemMap(nodeToElemMap); REQUIRE(VALID_REF(szlioNEM)); REQUIRE(0 < ___2707 && ___2707 <= szlioNEM->m_nodeCount); return szlioNEM->m_elemIndex[___2707] - szlioNEM->m_elemIndex[___2707 - 1]; } ___463 ___4014::dataNodeToElemMapGetElem(___2740 nodeToElemMap, ___2716 ___2707, ___463 elemOffset) const { tecplot::tecioszl::___2741* const szlioNEM = toSzlioNodeToElemMap(nodeToElemMap); REQUIRE(VALID_REF(szlioNEM)); REQUIRE(0 < ___2707 && ___2707 <= szlioNEM->m_nodeCount); REQUIRE(0 < elemOffset && elemOffset <= szlioNEM->m_elemIndex[___2707] - szlioNEM->m_elemIndex[___2707 - 1]); return szlioNEM->m_elem[szlioNEM->m_elemIndex[___2707 - 1] + elemOffset - 1] + 1; } FaceNeighborMode_e ___4014::___834(___4634 ___4656) const { REQUIRE(m_tecioData.validZoneNum(___4656)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4656); return zonePtr->___2456; } void ___4014::___835( ___1290 ___1272, ___2225 ___1142, int32_t face, int32_t ___2690, ___2225* ___2689, ___4634* ___2693) const { Zone_s const* zonePtr = reinterpret_cast<Zone_s const*>(___1272); REQUIRE(VALID_REF(zonePtr)); Zone_s::___456 ___455; ___455.first = static_cast<int32_t>(___1142); ___455.second = face; Zone_s::___1274::const_iterator iter = zonePtr->___2455.find(___455); ___476(iter != zonePtr->___2455.end()); ___476(0 < ___2690 && ___2690 <= (___2225)iter->second.___2676.size()); *___2689 = iter->second.___2676[___2690 - 1].second; *___2693 = iter->second.___2676[___2690 - 1].first; } ___372 ___4014::___833( ___1290 ___1272, ___2225 ___1142, int32_t face, ___3499 ___4) const { ___4276(___4); Zone_s const* zonePtr = reinterpret_cast<Zone_s const*>(___1272); REQUIRE(VALID_REF(zonePtr)); Zone_s::___456 ___455; ___455.first = static_cast<int32_t>(___1142); ___455.second = face; Zone_s::___1274::const_iterator iter = zonePtr->___2455.find(___455); if (iter == zonePtr->___2455.end()) return ___1303; else return iter->second.___2486; } int32_t ___4014::___836(___1290 ___1272, ___2225 ___1142, int32_t face, ___372*  ) const
{ Zone_s const* zonePtr = reinterpret_cast<Zone_s const*>(___1272); REQUIRE(VALID_REF(zonePtr)); Zone_s::___456 ___455; ___455.first = static_cast<int32_t>(___1142); ___455.second = face; Zone_s::___1274::const_iterator iter = zonePtr->___2455.find(___455); if (iter == zonePtr->___2455.end()) return 0; else return (int32_t)iter->second.___2676.size(); } ___1290 ___4014::___837(___4634 ___4656) const { REQUIRE(m_tecioData.validZoneNum(___4656)); Zone_s* zonePtr = m_tecioData.zonePtrForConnectivity(___4656); return reinterpret_cast<___1290>(zonePtr); } ___372 ___4014::setAddMember(___3499 set, ___3491 ___2399, ___372 showErr) const { std::set<___3491>* setPtr = reinterpret_cast<std::set<___3491>*>(set); REQUIRE(VALID_REF(setPtr)); try { setPtr->insert(___2399); } catch (std::bad_alloc const&) { if (showErr) std::cerr << "Allocation failure adding member to set." << std::endl; return ___1303; } return ___4224; } ___3499 ___4014::setAlloc(___372 showErr) const { std::set<___3491>* ___3356 = NULL; try { ___3356 = new std::set<___3491>(); } catch (std::bad_alloc const&) { if (showErr) std::cerr << "Allocation failure allocating set." << std::endl; } return reinterpret_cast<___3499>(___3356); } void ___4014::___3482(___3499* set) const { REQUIRE(VALID_REF(set)); std::set<___3491>* setPtr = *(reinterpret_cast<std::set<___3491>**>(set)); REQUIRE(VALID_REF_OR_NULL(setPtr)); delete setPtr; *set = NULL; } ___3491 ___4014::___3489(___3499 set, ___3491 ___2399) const { std::set<___3491>* setPtr = reinterpret_cast<std::set<___3491>*>(set); REQUIRE(VALID_REF(setPtr)); std::set<___3491>::iterator it; if (___2399 == ___4037) { it = setPtr->begin(); } else { it = setPtr->find(___2399); if (it != setPtr->end()) ++it; } if (it == setPtr->end()) return ___4037; else return *it; } ___3491 ___4014::setGetPrevMember(___3499 set, ___3491 ___2399) const { std::set<___3491>* setPtr = reinterpret_cast<std::set<___3491>*>(set); REQUIRE(VALID_REF(setPtr)); std::set<___3491>::reverse_iterator it; if (___2399 == ___4037) { it = setPtr->rbegin(); } else { it = setPtr->rbegin(); while (it != setPtr->rend() && *it != ___2399) ++it; if (it != setPtr->rend()) ++it; } if (it == setPtr->rend()) return ___4037; else return *it; } ___3491 ___4014::setGetMemberCount(___3499 set) const { std::set<___3491>* setPtr = reinterpret_cast<std::set<___3491>*>(set); REQUIRE(VALID_REF(setPtr)); return static_cast<___3491>(setPtr->size()); } ___372 ___4014::___3493(___3499 set, ___3491 ___2399) const { std::set<___3491>* setPtr = reinterpret_cast<std::set<___3491>*>(set); REQUIRE(VALID_REF(setPtr)); return setPtr->find(___2399) != setPtr->end(); } ___372 ___4014::setIsEqual(___3499 ___3475, ___3499 ___3476) const { std::set<___3491>* set1Ptr = reinterpret_cast<std::set<___3491>*>(___3475);
std::set<___3491>* set2Ptr = reinterpret_cast<std::set<___3491>*>(___3476); REQUIRE(VALID_REF(set1Ptr) && VALID_REF(set2Ptr)); return *set1Ptr == *set2Ptr; } void ___4014::setRemoveMember(___3499 set, ___3491 ___2399) const { std::set<___3491>* setPtr = reinterpret_cast<std::set<___3491>*>(set); REQUIRE(VALID_REF(setPtr)); setPtr->erase(___2399); } void ___4014::___1555(GeomID_t ___1803, int32_t ___3155, ___2225 ___3139, double* x, double* ___4581) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2464 == GeomType_LineSegs); REQUIRE(0 < ___3155 && ___3155 <= (int32_t)___1553->___2462.size()); REQUIRE(0 < ___3139 && ___3139 <= (___2225)___1553->___2462[___3155 - 1].size()); *x = ___1553->___2462[___3155 - 1][___3139 - 1].x(); *___4581 = ___1553->___2462[___3155 - 1][___3139 - 1].___4581(); } void ___4014::___1556(GeomID_t ___1803, ___2225 ___3139, double* x, double* ___4581) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2464 == GeomType_LineSegs); REQUIRE(0 < ___3139 && ___3139 < (___2225)___1553->___2462[0].size()); *x = ___1553->___2462[0][___3139 - 1].x(); *___4581 = ___1553->___2462[0][___3139 - 1].___4581(); } void ___4014::___1558(GeomID_t ___1803, int32_t ___3155, ___2225 ___3139, double* x, double* ___4581, double* z) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2464 == GeomType_LineSegs && ___1553->___2614 == CoordSys_Grid3D); REQUIRE(0 < ___3155 && ___3155 <= (int32_t)___1553->___2462.size()); REQUIRE(0 < ___3139 && ___3139 <= (___2225)___1553->___2462[___3155 - 1].size()); *x = ___1553->___2462[___3155 - 1][___3139 - 1].x(); *___4581 = ___1553->___2462[___3155 - 1][___3139 - 1].___4581(); *z = ___1553->___2462[___3155 - 1][___3139 - 1].z(); } void ___4014::___1559(GeomID_t ___1803, ___2225 ___3139, double* x, double* ___4581, double* z) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2464 == GeomType_LineSegs && ___1553->___2614 == CoordSys_Grid3D); REQUIRE(0 < ___3139 && ___3139 < (___2225)___1553->___2462[0].size()); *x = ___1553->___2462[0][___3139 - 1].x(); *___4581 = ___1553->___2462[0][___3139 - 1].___4581(); *z = ___1553->___2462[0][___3139 - 1].z(); } double ___4014::___1562(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2338; } ArrowheadAttachment_e ___4014::___1563(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2339; } double ___4014::___1564(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2340; } ArrowheadStyle_e ___4014::___1565(GeomID_t ___1803) const
{ ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2341; } double ___4014::___1568(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2464 == GeomType_Circle); REQUIRE(___1553->___2462.size() == 1); REQUIRE(___1553->___2462[0].size() == 1); return ___1553->___2462[0][0].x(); } int32_t ___4014::___1574(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2464 == GeomType_Ellipse || ___1553->___2464 == GeomType_Circle); return static_cast<int32_t>(___1553->___2500); } void ___4014::___1575(GeomID_t ___1803, double* ___1822, double* ___4392) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2464 == GeomType_Ellipse); REQUIRE(___1553->___2462.size() == 1); REQUIRE(___1553->___2462.size() == 1); *___1822 = ___1553->___2462[0][0].x(); *___4392 = ___1553->___2462[0][0].___4581(); } void ___4014::___1589(GeomID_t ___1803, double* ___4572, double* ___4589, double* ___4713) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); *___4572 = ___1553->___2615[0]; *___4589 = ___1553->___2615[1]; *___4713 = ___1553->___2615[2]; } Clipping_e ___4014::___1591(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2392; } ___514 ___4014::___1592(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2393; } DrawOrder_e ___4014::___1593(GeomID_t  ) const { return ___1112; } ___514 ___4014::___1594(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2460; } ___372 ___4014::___1595(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2484; } LinePattern_e ___4014::___1596(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2487; } double ___4014::___1597(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2488; } ___372 ___4014::___1598(GeomID_t ___1803, char** macroFunctionCmd) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); *macroFunctionCmd = copyString(___1553->___2489); return ___4224; } GeomID_t ___4014::___1599(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); size_t nextIndex = std::distance(&m_tecioData.geoms()[0], ___1553) + 1; if (nextIndex == m_tecioData.geoms().size()) return ___4033; return reinterpret_cast<GeomID_t>(&m_tecioData.geoms()[nextIndex]);
} double ___4014::___1600(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2613; } CoordSys_e ___4014::___1601(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2614; } GeomID_t ___4014::___1602(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); size_t geomIndex = std::distance(&m_tecioData.geoms()[0], ___1553); if (geomIndex == 0) return ___4033; return reinterpret_cast<GeomID_t>(&m_tecioData.geoms()[geomIndex - 1]); } Scope_e ___4014::___1603(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2617; } GeomForm_e ___4014::___1604(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2464; } ___4634 ___4014::___1605(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2675; } ___372 ___4014::___1608(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); return ___1553->___2482; } ___2225 ___4014::___1617(GeomID_t ___1803, int32_t ___3155) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2464 == GeomType_LineSegs); REQUIRE(0 < ___3155 && ___3155 <= (int32_t)___1553->___2462.size()); return (___2225)___1553->___2462[___3155 - 1].size(); } ___2225 ___4014::___1618(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2464 == GeomType_LineSegs); return (___2225)___1553->___2462.size(); } ___2225 ___4014::___1624(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2464 == GeomType_LineSegs); REQUIRE(___1553->___2462.size() == 1); return (___2225)___1553->___2462[0].size(); } void ___4014::___1626(GeomID_t ___1803, double* ___4456, double* ___1824) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2464 == GeomType_Rectangle); REQUIRE(___1553->___2462.size() == 1); *___4456 = ___1553->___2462[0][0].x(); *___1824 = ___1553->___2462[0][0].___4581(); } double ___4014::___1646(GeomID_t ___1803) const { ___1554 const* ___1553 = reinterpret_cast<___1554*>(___1803); REQUIRE(VALID_REF(___1553)); REQUIRE(___1553->___2464 == GeomType_Square); REQUIRE(___1553->___2462.size() == 1); return ___1553->___2462[0][0].x(); } ___514 ___4014::___4062(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2626; } ___514 ___4014::___4063(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169);
REQUIRE(VALID_REF(___4040)); return ___4040->___2627; } double ___4014::___4064(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2628; } double ___4014::___4065(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2629; } TextBox_e ___4014::___4066(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2630; } TextAnchor_e ___4014::___4082(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2623; } void ___4014::___4083(TextID_t ___4169, double* ___4572, double* ___4589, double* ___4713) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); REQUIRE(VALID_REF(___4572)); REQUIRE(VALID_REF(___4589)); REQUIRE(VALID_REF(___4713)); *___4572 = ___4040->___2624[0]; *___4589 = ___4040->___2624[1]; *___4713 = ___4040->___2624[2]; } double ___4014::___4084(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2625; } Clipping_e ___4014::___4086(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2631; } ___514 ___4014::___4087(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2632; } double ___4014::___4088(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2633; } double ___4014::___4089(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2635; } ___372 ___4014::___4090(TextID_t ___4169, char** ___2328) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); REQUIRE(VALID_REF(___2328)); if (!___4040->___2636.empty()) { *___2328 = copyString(___4040->___2636); return ___4224; } return ___1303; } TextID_t ___4014::___4091(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); size_t nextIndex = std::distance(&m_tecioData.texts()[0], ___4040) + 1; if (nextIndex == m_tecioData.texts().size()) return ___4033; return reinterpret_cast<TextID_t>(&m_tecioData.texts()[nextIndex]); } CoordSys_e ___4014::___4092(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2637; } TextID_t ___4014::___4093(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); size_t textIndex = std::distance(&m_tecioData.texts()[0], ___4040);
if (textIndex == 0) return ___4033; return reinterpret_cast<TextID_t>(&m_tecioData.texts()[textIndex - 1]); } Scope_e ___4014::___4094(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2639; } Units_e ___4014::___4095(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2640; } ___372 ___4014::___4096(TextID_t ___4169, char** ___4124) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); REQUIRE(VALID_REF(___4124)); if (!___4040->___2641.empty()) { *___4124 = copyString(___4040->___2641); return ___4224; } return ___1303; } char* ___4014::___4097(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return copyString(___4040->___2642); } ___372 ___4014::___4098(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2643; } ___372 ___4014::___4099(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2644; } ___4634 ___4014::___4100(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2645; } ___372 ___4014::___4103(TextID_t ___4169) const { Text const* ___4040 = reinterpret_cast<Text*>(___4169); REQUIRE(VALID_REF(___4040)); return ___4040->___2634; } ___372 ___4014::___4302(___1359 ASSERT_ONLY(___1349)) const { REQUIRE(VALID_REF(___1349)); return ___4224; } ___372 ___4014::___4307(___2725 ASSERT_ONLY(___2721)) const { REQUIRE(VALID_REF(___2721)); return ___4224; } PlotType_e ___4014::___1511() const { return ___3113; } ___2662 ___4014::___4150() { return new ___2663; } void ___4014::___4151(___2662* mutex) { delete *mutex; *mutex = NULL; } void ___4014::___4152(___2662 mutex) {
 #if defined TECIOMPI
___476(___1303); ___4276(mutex);
 #else
mutex->lock();
 #endif
} void ___4014::___4153(___2662 mutex) {
 #if defined TECIOMPI
___4276(mutex);
 #else
mutex->unlock();
 #endif
} void ___4014::___4154(___4158 ___2116, ___90 ___2121, ___2118 ___2117) {
 #if defined TECIOMPI
___4276(___2117); ___2116(___2121);
 #else
___2117->addJob(___2116, ___2121);
 #endif
} int ___4014::___4155() {
 #if defined TECIOMPI
return 1;
 #else
return ___2120::___2825();
 #endif
} ___2118 ___4014::___4156() { return new ___2120; } void ___4014::___4157(___2118* ___2117) { delete *___2117; *___2117 = NULL; } void ___4014::___4159(___2118 ___2117) {
 #if defined TECIOMPI
___4276(___2117);
 #else
___2117->wait();
 #endif
} int32_t ___4014::datasetGetNumPartitionFiles() const { return 0; } int32_t ___4014::zoneGetOwnerProcess(tecplot::___3931::___4634 ___4656) const { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(!zoneIsPartitioned(___4656)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4656); ___476(IMPLICATION(!zonePtr->m_partitionOwners.empty(), zonePtr->m_partitionOwners.size() == 1)); if (zonePtr->m_partitionOwners.empty()) return 0; return zonePtr->m_partitionOwners[0]; } int32_t ___4014::zonePartitionGetOwnerProcess(tecplot::___3931::___4634 ___4656, tecplot::___3931::___4634 partitionNum) const { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(zoneIsPartitioned(___4656)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4656); ___476(IMPLICATION(!zonePtr->m_partitionOwners.empty(), static_cast<size_t>(partitionNum) <= zonePtr->m_partitionOwners.size())); if (zonePtr->m_partitionOwners.empty()) return 0; return zonePtr->m_partitionOwners[partitionNum - 1]; } ___372 ___4014::zoneIsPartitioned(___4634 ___4656) const { REQUIRE(m_tecioData.validZoneNum(___4656)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4656); if (zonePtr->m_partitionOwners.empty()) return zonePtr->m_partitionMap.empty() ? ___1303 : ___4224; return (zonePtr->m_partitionOwners.size() > 1); } ___4634 ___4014::zoneGetNumPartitions(___4634 ___4656) const { REQUIRE(m_tecioData.validZoneNum(___4656)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4656); if (zonePtr->m_partitionOwners.empty()) return static_cast<___4634>(zonePtr->m_partitionMap.size()); return static_cast<___4634>(zonePtr->m_partitionOwners.size()); } namespace { Zone_s* getPartitionPtr(Zone_s::ZoneMap const& partitionMap, ___4634 partitionNum) { REQUIRE(partitionNum > 0); Zone_s::ZoneMap::const_iterator it = partitionMap.find(partitionNum - 1); if (it == partitionMap.end()) return NULL; else return it->second.get(); } } void ___4014::zonePartitionGetIJK(___4634 ___4656, ___4634 partitionNum, ___1842& ___1859) const { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(zoneIsPartitioned(___4656)); REQUIRE(m_tecioData.validPartitionNum(___4656, partitionNum)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4656); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); ___1859 = partitionPtr->___2680; } void ___4014::zonePartitionGetIJKOffset(tecplot::___3931::___4634 ___4656, tecplot::___3931::___4634 partitionNum, tecplot::___3931::___1842& ___1860) const { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(zoneIsPartitioned(___4656)); REQUIRE(___4639(___4656)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4656); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); ___476(partitionPtr != NULL); ___1860 = partitionPtr->m_partitionOffset; } ___372 ___4014::dataValueGetMinMaxByZonePartitionVar( ___4634 ___4656, ___4634 partitionNum, ___4350 ___4334, double* minVal, double* maxVal) const
{ REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(zoneIsPartitioned(___4656)); REQUIRE(m_tecioData.validPartitionNum(___4656, partitionNum)); REQUIRE(0 < ___4334 && ___4334 <= static_cast<___4350>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4656, ___4334); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); partitionPtr->___2494[___4334 - 1]->___1757(*minVal, *maxVal); return ___4224; } ___1359 ___4014::dataValuePartitionGetReadableNLRef( ___4634 ___4656, ___4634 partitionNum, ___4350 ___4366) const { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(zoneIsPartitioned(___4656)); REQUIRE(m_tecioData.validPartitionNum(___4656, partitionNum)); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4656, ___4366); REQUIRE(zonePtr != NULL); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); ___476(partitionPtr != NULL); REQUIRE(0 < ___4366 && ___4366 <= static_cast<___4350>(m_tecioData.variableNames().size())); if (partitionPtr->___2494[___4366 - 1]->___2667 == ___4328) return dataValuePartitionGetReadableNativeRef(___4656, partitionNum, ___4366); else return dataValuePartitionGetReadableDerivedRef(___4656, partitionNum, ___4366); } ___1359 ___4014::dataValuePartitionGetReadableCCRef( ___4634 ___4656, ___4634 partitionNum, ___4350 ___4366) const { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(zoneIsPartitioned(___4656)); REQUIRE(m_tecioData.validPartitionNum(___4656, partitionNum)); REQUIRE(0 < ___4366 && ___4366 <= static_cast<___4350>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4656, ___4366); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); if (partitionPtr->___2494[___4366 - 1]->___2667 == ___4326) return dataValuePartitionGetReadableNativeRef(___4656, partitionNum, ___4366); else return dataValuePartitionGetReadableDerivedRef(___4656, partitionNum, ___4366); } ___1359 ___4014::dataValuePartitionGetReadableNativeRef( ___4634 ___4656, ___4634 partitionNum, ___4350 ___4366) const { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(zoneIsPartitioned(___4656)); REQUIRE(m_tecioData.validPartitionNum(___4656, partitionNum)); REQUIRE(0 < ___4366 && ___4366 <= static_cast<___4350>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4656, ___4366); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); return toTecUtilFieldData(partitionPtr->___2494[___4366 - 1].get()); } ___1359 ___4014::dataValuePartitionGetReadableDerivedRef( ___4634 ___4656, ___4634 partitionNum, ___4350 ___4366) const { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(zoneIsPartitioned(___4656)); REQUIRE(m_tecioData.validPartitionNum(___4656, partitionNum));
REQUIRE(0 < ___4366 && ___4366 <= static_cast<___4350>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4656, ___4366); Zone_s* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); try { if (partitionPtr->___2398[___4366 - 1]->storedValueCount() == 0) { Zone_s* connectivityZonePtr = m_tecioData.zonePtrForConnectivity(___4656); Zone_s* connectivityPartitionPtr = getPartitionPtr(connectivityZonePtr->m_partitionMap, partitionNum); if (partitionPtr->___2494[___4366 - 1]->___2667 == ___4326) partitionPtr->___963(___4366, connectivityPartitionPtr->___2495.get()); else partitionPtr->deriveCCValues(___4366, connectivityPartitionPtr->___2495.get()); } } catch (std::exception const&) { } return toTecUtilFieldData(partitionPtr->___2398[___4366 - 1].get()); } ___1359 ___4014::dataValuePartitionGetWritableNativeRef( ___4634 ___4656, ___4634 partitionNum, ___4350 ___4366) const { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(zoneIsPartitioned(___4656)); REQUIRE(m_tecioData.validPartitionNum(___4656, partitionNum)); REQUIRE(0 < ___4366 && ___4366 <= static_cast<___4350>(m_tecioData.variableNames().size())); return dataValuePartitionGetReadableNativeRef(___4656, partitionNum, ___4366); } void ___4014::dataValuePartitionGetReadableRawPtr( ___4634 ___4656, ___4634 partitionNum, ___4350 ___4366, void** ___878, FieldDataType_e* ___1361) const { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(zoneIsPartitioned(___4656)); REQUIRE(m_tecioData.validPartitionNum(___4656, partitionNum)); REQUIRE(0 < ___4366 && ___4366 <= static_cast<___4350>(m_tecioData.variableNames().size())); Zone_s const* zonePtr = m_tecioData.zonePtrForVar(___4656, ___4366); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); *___878 = partitionPtr->___2494[___4366 - 1]->getRawPointer(); *___1361 = partitionPtr->___2494[___4366 - 1]->___2457; } void ___4014::dataValuePartitionGetWritableRawPtr( ___4634 ___4656, ___4634 partitionNum, ___4350 ___4366, void** ___878, FieldDataType_e* ___1361) const { dataValuePartitionGetReadableRawPtr(___4656, partitionNum, ___4366, ___878, ___1361); } ___2725 ___4014::dataNodePartitionGetReadableRef( ___4634 ___4656, ___4634 partitionNum) const { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(zoneIsPartitioned(___4656)); REQUIRE(m_tecioData.validPartitionNum(___4656, partitionNum)); Zone_s const* zonePtr = m_tecioData.zonePtrForConnectivity(___4656); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); return toTecUtilNodeMap(partitionPtr->___2495.get()); } ___2725 ___4014::dataNodePartitionGetWritableRef( ___4634 ___4656, ___4634 partitionNum) const { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(zoneIsPartitioned(___4656));
REQUIRE(m_tecioData.validPartitionNum(___4656, partitionNum)); return dataNodePartitionGetReadableRef(___4656, partitionNum); } ___2740 ___4014::dataNodeToElemMapPartitionGetReadableRef( tecplot::___3931::___4634 ___4656, tecplot::___3931::___4634 partitionNum ) const { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(zoneIsPartitioned(___4656)); REQUIRE(m_tecioData.validPartitionNum(___4656, partitionNum)); Zone_s const* zonePtr = m_tecioData.zonePtrForConnectivity(___4656); Zone_s* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); if (!partitionPtr->m_nodeToElemMap) partitionPtr->m_nodeToElemMap.reset(new ___2741(*partitionPtr->___2495, partitionPtr->___2680.___1668())); return toTecUtilNodeToElemMap(partitionPtr->m_nodeToElemMap.get()); } GhostInfo_pa ___4014::zoneGhostNodeInfoGetRef(___4634 ___4656) const { REQUIRE(m_tecioData.validZoneNum(___4656)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4656); return &zonePtr->m_ghostNodeInfo; } GhostInfo_pa ___4014::zoneGhostCellInfoGetRef(___4634 ___4656) const { REQUIRE(m_tecioData.validZoneNum(___4656)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4656); return &zonePtr->m_ghostCellInfo; } GhostInfo_pa ___4014::zonePartitionGhostNodeInfoGetRef( tecplot::___3931::___4634 ___4656, tecplot::___3931::___4634 partitionNum) const { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(zoneIsPartitioned(___4656)); REQUIRE(m_tecioData.validPartitionNum(___4656, partitionNum)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4656); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); return &partitionPtr->m_ghostNodeInfo; } GhostInfo_pa ___4014::zonePartitionGhostCellInfoGetRef(tecplot::___3931::___4634 ___4656, tecplot::___3931::___4634 partitionNum) const { REQUIRE(m_tecioData.validZoneNum(___4656)); REQUIRE(zoneIsPartitioned(___4656)); REQUIRE(m_tecioData.validPartitionNum(___4656, partitionNum)); Zone_s const* zonePtr = m_tecioData.zonePtr(___4656); Zone_s const* partitionPtr = getPartitionPtr(zonePtr->m_partitionMap, partitionNum); return &partitionPtr->m_ghostCellInfo; } ___81 ___4014::ghostInfoGetNumItemsByRef(GhostInfo_pa ghostInfo) const { REQUIRE(VALID_REF(ghostInfo)); return static_cast<___81>(ghostInfo->m_items.size()); } ___81 ___4014::ghostInfoGetItemByRef( GhostInfo_pa ghostInfo, ___81 itemNum) const { REQUIRE(VALID_REF(ghostInfo)); REQUIRE(0 < itemNum && itemNum <= static_cast<___81>(ghostInfo->m_items.size())); return static_cast<___81>(ghostInfo->m_items[itemNum - 1]); } ___2088::___2978 ___4014::ghostInfoGetNeighborByRef( GhostInfo_pa ghostInfo, ___81 itemNum) const { REQUIRE(VALID_REF(ghostInfo)); REQUIRE(0 < itemNum && itemNum <= static_cast<___81>(ghostInfo->m_neighbors.size())); return ghostInfo->m_neighbors[itemNum - 1]; } ___81 ___4014::ghostInfoGetNeighborItemByRef( GhostInfo_pa ghostInfo,
___81 itemNum) const { REQUIRE(VALID_REF(ghostInfo)); REQUIRE(0 < itemNum && itemNum <= static_cast<___81>(ghostInfo->m_neighborItems.size())); return static_cast<___81>(ghostInfo->m_neighborItems[itemNum - 1]); } }}
