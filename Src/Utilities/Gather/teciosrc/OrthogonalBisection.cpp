#include "SzlFileLoader.h"
#include "OrthogonalBisection.h"
#include "AltTecUtil.h"
#include "ThirdPartyHeadersBegin.h"
#include <algorithm>
#include <cmath>
#include <fstream>
#include <boost/bind/bind.hpp>
#include <boost/function.hpp>
#include <boost/make_shared.hpp>
#include <boost/unordered_set.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "zoneUtil.h"
using namespace std; namespace tecplot { namespace ___3931 { OrthogonalBisection::OrthogonalBisection( ___4634               zone, BisectionType_e           bisectionType, ___2088::ItemOffset_t maxDomainSize) : ___2675(zone) , m_bisectionType(bisectionType) , m_maxDomainSize(maxDomainSize) , m_numItems(0) , m_numGhostItems(0) , m_numRecursionDepths(0) { REQUIRE(bisectionType == BisectionType_ZoneCells || bisectionType == BisectionType_ZoneNodes); ___935(); } OrthogonalBisection::~OrthogonalBisection(void) { } void OrthogonalBisection::___935(void) { m_numItems = 0; m_numGhostItems = 0; m_numRecursionDepths = 0; m_numDomains = 0; m_itemList.___935(); m_nodalFieldDataPtrs.___935(); m_ccFieldDataPtrs.___935(); m_reducedPrecisionSortDataArrays.___935(); } namespace {
 #ifdef WIN32
 #pragma warning(disable:4512) 
 #endif
class ZoneCellOrNodeSorter { private: ___1350&        m_fieldData; UInt8Array const& m_reducedPrecisionSortData; public: ZoneCellOrNodeSorter(___1350&        ___1349, UInt8Array const& reducedPrecisionSortData) : m_fieldData(___1349) , m_reducedPrecisionSortData(reducedPrecisionSortData) { } bool operator()(___81 aIndex, ___81 bIndex) const { if ( m_reducedPrecisionSortData[aIndex] != m_reducedPrecisionSortData[bIndex] ) { return m_reducedPrecisionSortData[aIndex] < m_reducedPrecisionSortData[bIndex]; } else { double const aVal = m_fieldData.___1778(aIndex+1); double const bVal = m_fieldData.___1778(bIndex+1); if ( aVal == bVal ) return aIndex < bIndex; else return aVal < bVal; } } }; } namespace { void executeBoostFunction(___90 ___2121) { boost::function<void(void)> *___1436 = reinterpret_cast<boost::function<void(void)>* >(___2121); (*___1436)(); delete ___1436; } } ___372 OrthogonalBisection::splitDomain( ___37&                  ___36, ___81                   domainStart, ___81                   domainSize, ___4350                   axisDirToSplit, ___2088::SubzoneOffset_t recursionDepth, ___2118                ___2117) { ___372 ___2037 = ___4224; REQUIRE(domainStart < m_numItems); REQUIRE(domainStart+domainSize <= m_numItems); REQUIRE(axisDirToSplit < NUM_BISECTION_DIRECTIONS); REQUIRE(recursionDepth <= m_numRecursionDepths); REQUIRE(VALID_REF(___2117)); if ( domainSize > m_maxDomainSize ) { ___2037 = calcReducedPrecisionValues(___36, domainStart, domainSize, axisDirToSplit, recursionDepth); ___81 leftOffset; ___81 leftSize; ___81 rightOffset; ___81 rightSize; getSubdomainInfo(domainStart, domainSize, leftOffset, leftSize, rightOffset, rightSize); if ( m_bisectionType == BisectionType_ZoneCells ) { ZoneCellOrNodeSorter zoneCellSorter(*m_ccFieldDataPtrs[axisDirToSplit], m_reducedPrecisionSortDataArrays[axisDirToSplit]); std::nth_element(m_itemList.begin()+domainStart, m_itemList.begin()+domainStart+leftSize, m_itemList.begin()+domainStart+domainSize, zoneCellSorter); } else { ___476(m_bisectionType == BisectionType_ZoneNodes); ZoneCellOrNodeSorter zoneNodeSorter(*m_nodalFieldDataPtrs[axisDirToSplit], m_reducedPrecisionSortDataArrays[axisDirToSplit]); std::nth_element(m_itemList.begin()+domainStart, m_itemList.begin()+domainStart+leftSize, m_itemList.begin()+domainStart+domainSize, zoneNodeSorter); } ___4350 const nextDirection = (axisDirToSplit+1) % NUM_BISECTION_DIRECTIONS; ___2088::SubzoneOffset_t const nextRecursionDepth = recursionDepth+1; if ( recursionDepth < m_maxRecursion && leftSize > m_maxDomainSize ) { boost::function<void(void)>* leftFunction = new boost::function<void(void)>( boost::bind(&OrthogonalBisection::splitDomain, this, boost::ref(___36), leftOffset, leftSize, nextDirection, nextRecursionDepth, ___2117)); ___36.___4154( executeBoostFunction, reinterpret_cast<___90>(leftFunction), ___2117); boost::function<void(void)>* rightFunction = new boost::function<void(void)>(
boost::bind(&OrthogonalBisection::splitDomain, this, boost::ref(___36), rightOffset, rightSize, nextDirection, nextRecursionDepth, ___2117)); ___36.___4154( executeBoostFunction, reinterpret_cast<___90>(rightFunction), ___2117); } else { ___2037 = ___2037 && splitDomain(___36, leftOffset, leftSize, nextDirection, nextRecursionDepth, ___2117); ___2037 = ___2037 && splitDomain(___36, rightOffset, rightSize, nextDirection, nextRecursionDepth, ___2117); }
 #if 0 
if ( rightOffset+rightSize == m_numItems ) { boost::function<void(void)>* updateStatusLineFunction = new boost::function<void(void)>( boost::bind(&OrthogonalBisection::updateStatusLine, this, nextRecursionDepth)); TecUtilMainlineInvoke( executeBoostFunction, reinterpret_cast<___90>(updateStatusLineFunction)); }
 #endif
} else { std::sort(m_itemList.begin()+domainStart, m_itemList.begin()+domainStart+domainSize); } return ___2037; } ___372 OrthogonalBisection::updateStatusLine(___37& ___36, ___2088::SubzoneOffset_t recursionDepth) { REQUIRE(m_numRecursionDepths>0); ___372 ___2037 = ___36.___3767(100*recursionDepth/m_numRecursionDepths); return ___2037; } ___372 OrthogonalBisection::loadCoordinateVarZoneFieldData(___37& ___36, char axis) { REQUIRE(axis=='X' || axis=='Y' || axis=='Z'); REQUIRE(m_nodalFieldDataPtrs.size() == size_t(NUM_BISECTION_DIRECTIONS) && m_ccFieldDataPtrs.size() == size_t(NUM_BISECTION_DIRECTIONS)); ___4350 dir = ___4350(axis - 'X'); ___476(dir < NUM_BISECTION_DIRECTIONS); if (___36.___908(___2675 + 1, dir + 1) == ___4328) { m_nodalFieldDataPtrs[dir] = boost::make_shared<___1350>(&___36, ___2675 + 1, dir + 1); m_ccFieldDataPtrs[dir] = boost::make_shared<___1350>(&___36, ___2675 + 1, dir + 1, false  , true /* ___962 */); } else { m_ccFieldDataPtrs[dir] = boost::make_shared<___1350>(&___36, ___2675 + 1, dir + 1); m_nodalFieldDataPtrs[dir] = boost::make_shared<___1350>(&___36, ___2675 + 1, dir + 1, false  , true /* ___962 */); } ___372 ___2037 = (m_nodalFieldDataPtrs[dir] != NULL && m_nodalFieldDataPtrs[dir]->___2065() && m_ccFieldDataPtrs[dir] != NULL && m_ccFieldDataPtrs[dir]->___2065()); return ___2037; } void OrthogonalBisection::getMinMaxWeightOverRange( ___81                   rangeStart, ___81                   ___3266, ___2088::SubzoneOffset_t ___2116, ___2088::SubzoneOffset_t numJobs, ___4350                   axisDirToSplit, ___2477&                      weightMinMax) { REQUIRE(rangeStart < m_numItems); REQUIRE(___3266 > 0 && rangeStart+___3266 <= m_numItems); REQUIRE(___2116 < numJobs); REQUIRE(numJobs > 0); REQUIRE(axisDirToSplit < NUM_BISECTION_DIRECTIONS); REQUIRE("weightMinMax isn't required to be initialized"); ___81 jobStart; ___81 jobEnd; getJobStartEndForRange(rangeStart, ___3266, ___2116, numJobs, jobStart, jobEnd); FieldDataPtr fieldDataPtr; if (m_bisectionType == BisectionType_ZoneCells) fieldDataPtr = m_ccFieldDataPtrs[axisDirToSplit]; else fieldDataPtr = m_nodalFieldDataPtrs[axisDirToSplit]; ___1350& ___1349 = *fieldDataPtr; ___2477 minMax; for (___81 ___2083 = jobStart; ___2083 < jobEnd; ___2083++) { double const weight = ___1349.___1778(m_itemList[___2083] + 1); minMax.include(weight); } weightMinMax = minMax; } void OrthogonalBisection::rescaleWeightsOverRange( ___81                   rangeStart, ___81                   ___3266, ___2088::SubzoneOffset_t ___2116, ___2088::SubzoneOffset_t numJobs, ___4350                   axisDirToSplit, double                       scale, double                       ___2863) { REQUIRE(rangeStart < m_numItems); REQUIRE(___3266 > 0 && rangeStart+___3266 <= m_numItems); REQUIRE(___2116 < numJobs); REQUIRE(numJobs > 0); REQUIRE(axisDirToSplit < NUM_BISECTION_DIRECTIONS);
REQUIRE(scale >= 0.0); ___81 jobStart; ___81 jobEnd; getJobStartEndForRange(rangeStart, ___3266, ___2116, numJobs, jobStart, jobEnd); FieldDataPtr fieldDataPtr; if (m_bisectionType == BisectionType_ZoneCells) fieldDataPtr = m_ccFieldDataPtrs[axisDirToSplit]; else fieldDataPtr = m_nodalFieldDataPtrs[axisDirToSplit]; ___1350& ___1349 = *fieldDataPtr; UInt8Array& reducedPrecisionSortData = m_reducedPrecisionSortDataArrays[axisDirToSplit]; ___476(static_cast<___81>(reducedPrecisionSortData.size()) == m_numItems + m_numGhostItems); for (___81 ___2083 = jobStart; ___2083 < jobEnd; ___2083++) { ___2716 const index = ___2716( m_itemList[___2083] ); double const weight = ___1349.___1778(index + 1); double const scaledVal = scale*(weight + ___2863); ___476(0.0 <= scaledVal && scaledVal < 256.0); uint8_t const int8Val = int8_t(scaledVal); reducedPrecisionSortData[index] = int8Val; } } ___372 OrthogonalBisection::calcReducedPrecisionValues( ___37&                  ___36, ___81                   rangeStart, ___81                   ___3266, ___4350                   axisDirToSplit, ___2088::SubzoneOffset_t recursionDepth) { ___372 ___2037 = ___4224; REQUIRE(rangeStart < m_numItems); REQUIRE(___3266 > 0 && rangeStart+___3266 <= m_numItems); REQUIRE(axisDirToSplit < NUM_BISECTION_DIRECTIONS); REQUIRE(recursionDepth < m_numRecursionDepths); static ___2088::SubzoneOffset_t const REDUCED_PRECISION_RECALC_FREQUENCY = 3; if ( recursionDepth % (REDUCED_PRECISION_RECALC_FREQUENCY*NUM_BISECTION_DIRECTIONS) == ___2088::SubzoneOffset_t(axisDirToSplit) ) { ___1350& ___1349 = *m_nodalFieldDataPtrs[axisDirToSplit]; static double const maxNewRange = 255.99; ___476(uint8_t(maxNewRange)==255); ___2477 itemWeightMinMax; if ( recursionDepth < ___2088::SubzoneOffset_t(NUM_BISECTION_DIRECTIONS) ) { double minVal; double maxVal; ___1349.___1757(&minVal, &maxVal); itemWeightMinMax.___3497(minVal, maxVal); } else { ___81 const maxThreadsAvailable = (m_maxThreadedJobs >> recursionDepth); ___81 const maxPossibleJobs = ___3266/MIN_THREADED_ITEM_RANGE_SIZE; ___2088::SubzoneOffset_t const numJobs = ___2088::SubzoneOffset_t( std::min(maxThreadsAvailable, maxPossibleJobs) ); if ( numJobs > 1 ) { ___2118 ___2117 = ___36.___4156(); ___2479 jobMinMaxes; if ( ___2117 && jobMinMaxes.alloc(numJobs) ) { try { for ( ___2088::SubzoneOffset_t ___2116 = 0; ___2116 < numJobs; ___2116++ ) { boost::function<void(void)>* getMinMaxFunction = new boost::function<void(void)>( boost::bind(&OrthogonalBisection::getMinMaxWeightOverRange, this, rangeStart, ___3266, ___2116, numJobs, axisDirToSplit, boost::ref(jobMinMaxes[___2116]))); ___36.___4154( executeBoostFunction, reinterpret_cast<___90>(getMinMaxFunction), ___2117); } } catch (...) { ___2037 = ___1303; } ___36.___4159(___2117); ___36.___4157(&___2117); } if ( ___2037 ) { for ( ___2088::SubzoneOffset_t ___2116 = 0; ___2116 < numJobs; ___2116++ )
itemWeightMinMax.include(jobMinMaxes[___2116]); } } else { getMinMaxWeightOverRange(rangeStart, ___3266, 0 , 1/*numJobs*/, axisDirToSplit, itemWeightMinMax); } } if ( ___2037 ) { double const ___2863 = -itemWeightMinMax.minValue(); double const scale = (itemWeightMinMax.maxValue() > itemWeightMinMax.minValue()+___3626) ? maxNewRange / ( itemWeightMinMax.maxValue() - itemWeightMinMax.minValue() ) : 0.; ___81 const maxThreadsAvailable = (m_maxThreadedJobs >> recursionDepth); ___81 const maxPossibleJobs = ___3266/MIN_THREADED_ITEM_RANGE_SIZE; ___2088::SubzoneOffset_t const numJobs = ___2088::SubzoneOffset_t( std::min(maxThreadsAvailable, maxPossibleJobs) ); if ( numJobs > 1 ) { ___2118 ___2117 = ___36.___4156(); if ( ___2117 ) { try { for ( ___2088::SubzoneOffset_t ___2116 = 0; ___2116 < numJobs; ___2116++ ) { boost::function<void(void)>* rescaleFunction = new boost::function<void(void)>( boost::bind(&OrthogonalBisection::rescaleWeightsOverRange, this, rangeStart, ___3266, ___2116, numJobs, axisDirToSplit, scale, ___2863)); ___36.___4154( executeBoostFunction, reinterpret_cast<___90>(rescaleFunction), ___2117); } } catch (...) { ___2037 = ___1303; } ___36.___4159(___2117); ___36.___4157(&___2117); } } else { rescaleWeightsOverRange(rangeStart, ___3266, 0 , 1/*numJobs*/, axisDirToSplit, scale, ___2863); } } } ENSURE(VALID_BOOLEAN(___2037)); return ___2037; } ___372 OrthogonalBisection::performBisection(___37& ___36) { ___372 ___2037 = ___4224; ___36.___856(); double maxThreads = ___36.___4155() * MAX_THREADS_PER_CORE; m_maxRecursion = static_cast<___2088::SubzoneOffset_t>(std::max(1.0, log(maxThreads) / log(2.0))); m_maxThreadedJobs = 1 << m_maxRecursion; ___1842 ___4630; ___36.___4613(___2675 + 1, ___4630); GhostInfo_pa ghostInfo = NULL; if ( m_bisectionType == BisectionType_ZoneCells ) { m_numItems = ___4630.___1666(); ghostInfo = ___36.zoneGhostCellInfoGetRef(___2675 + 1); ___2682 = ___36.___4618(___2675 + 1); ___476(___3892(___2682)); } else { ___476(m_bisectionType == BisectionType_ZoneNodes); m_numItems = ___4630.___1668(); ghostInfo = ___36.zoneGhostNodeInfoGetRef(___2675 + 1); ___2682 = ___4701; } if (ghostInfo) m_numGhostItems = ___36.ghostInfoGetNumItemsByRef(ghostInfo); else m_numGhostItems = 0; m_numItems -= m_numGhostItems; m_numRecursionDepths = calcNumRecursionDepths(); m_numDomains = calcNumDomains(); ___2037 = ___2037 && m_nodalFieldDataPtrs.alloc(NUM_BISECTION_DIRECTIONS); ___2037 = ___2037 && m_ccFieldDataPtrs.alloc(NUM_BISECTION_DIRECTIONS); ___2037 = ___2037 && loadCoordinateVarZoneFieldData(___36, 'X'); ___2037 = ___2037 && loadCoordinateVarZoneFieldData(___36, 'Y'); ___2037 = ___2037 && loadCoordinateVarZoneFieldData(___36, 'Z'); ___2037 = ___2037 && m_itemList.alloc(m_numItems + m_numGhostItems); if ( ___2037 ) { if ( m_numGhostItems > 0 )
{ boost::unordered_set<___81> ghostItemSet; for(___81 ___1839 = 0; ___1839 < m_numGhostItems; ++___1839) ghostItemSet.insert(___36.ghostInfoGetItemByRef(ghostInfo, ___1839 + 1) - 1); ___81 realIndex = 0; ___81 ghostIndex = m_numItems; for (___81 ___1839 = 0; ___1839 < m_numItems + m_numGhostItems; ___1839++) { if (ghostItemSet.find(___1839) != ghostItemSet.end()) m_itemList[ghostIndex++] = ___1839; else m_itemList[realIndex++] = ___1839; } ___476(realIndex == static_cast<___81>(m_numItems)); ___476(ghostIndex == m_numItems + m_numGhostItems); } else { for (___81 ___1839 = 0; ___1839 < m_numItems; ___1839++) m_itemList[___1839] = ___1839; } } ___2037 = ___2037 && m_reducedPrecisionSortDataArrays.alloc(NUM_BISECTION_DIRECTIONS); for ( ___4350 dir = 0; ___2037 && dir < NUM_BISECTION_DIRECTIONS; dir++ ) ___2037 = ___2037 && m_reducedPrecisionSortDataArrays[dir].alloc(m_numItems + m_numGhostItems); if ( ___2037 ) { ___2118 ___2117 = ___36.___4156(); if ( ___2117 ) { try { boost::function<void(void)>* splitFunction = new boost::function<void(void)>( boost::bind(&OrthogonalBisection::splitDomain, this, boost::ref(___36), 0 , m_numItems/*size*/, 0/*axisDir*/, 0/*recursionDepth*/, ___2117)); ___36.___4154( executeBoostFunction, reinterpret_cast<___90>(splitFunction), ___2117); } catch (...) { ___2037 = ___1303; } } ___36.___4159(___2117); ___36.___4157(&___2117); } m_reducedPrecisionSortDataArrays.___935(); ___36.___857(); m_nodalFieldDataPtrs.___935(); m_ccFieldDataPtrs.___935(); return ___2037; } void OrthogonalBisection::getSzCoordsByRange( ___81                   rangeStart, ___81                   ___3266, ___2088::SubzoneOffset_t ___2116, ___2088::SubzoneOffset_t numJobs, ItemAddressArray&            szCoordArray) { REQUIRE(rangeStart < m_numItems); REQUIRE(___3266 > 0 && rangeStart+___3266 <= m_numItems); REQUIRE(___2116 < numJobs); REQUIRE(numJobs > 0); REQUIRE(szCoordArray.size()==size_t(m_numItems + m_numGhostItems)); ___81 jobStart; ___81 jobEnd; getJobStartEndForRange(rangeStart, ___3266, ___2116, numJobs, jobStart, jobEnd); ___2088::SubzoneOffset_t const szStart = ___2088::SubzoneOffset_t(jobStart); ___2088::SubzoneOffset_t const szEnd = ___2088::SubzoneOffset_t(jobEnd); ___81 newItem = jobStart*___81(m_maxDomainSize); for ( ___2088::SubzoneOffset_t ___3878 = szStart; ___3878 < szEnd; ___3878++ ) { ___2088::ItemOffset_t subzoneSize = getDomainSize(___3878); for ( ___2088::ItemOffset_t ___2863 = 0; ___2863 < subzoneSize; ___2863++ ) { ___81 const orgItem = queryPositionbyOffset(newItem); szCoordArray[orgItem] = ___2088(___2675, ___3878, ___2863); newItem++; } } } ___372 OrthogonalBisection::getSzCoordByOriginalItemArray(___37& ___36, ItemAddressArray& szCoordByOriginalItem) { REQUIRE(szCoordByOriginalItem.empty()); REQUIRE(m_numItems>0); ___372 ___2037 = szCoordByOriginalItem.alloc(m_numItems + m_numGhostItems);
if ( ___2037 ) { ___81 const maxThreadsAvailable = m_maxThreadedJobs; ___81 const maxPossibleJobs = m_numDomains/MIN_THREADED_SUBZONE_RANGE_SIZE; ___2088::SubzoneOffset_t const numJobs = ___2088::SubzoneOffset_t( std::min(maxThreadsAvailable, maxPossibleJobs) ); if ( numJobs > 1 ) { ___2118 ___2117 = ___36.___4156(); if ( ___2117 ) { try { for ( ___2088::SubzoneOffset_t ___2116 = 0; ___2116 < numJobs; ___2116++ ) { boost::function<void(void)>* updateFunction = new boost::function<void(void)>( boost::bind(&OrthogonalBisection::getSzCoordsByRange, this, 0 , m_numDomains/*size*/, ___2116, numJobs, boost::ref(szCoordByOriginalItem))); ___36.___4154( executeBoostFunction, reinterpret_cast<___90>(updateFunction), ___2117); } } catch (...) { ___2037 = ___1303; } ___36.___4159(___2117); ___36.___4157(&___2117); } } else { getSzCoordsByRange(0 , m_numDomains/*___3266*/, 0/*___2116*/, 1/*numJobs*/, szCoordByOriginalItem); } } return ___2037; } }}
