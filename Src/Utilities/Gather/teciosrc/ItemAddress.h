 #pragma once
#include "CodeContract.h"
#include "StandardIntegralTypes.h"
namespace tecplot {
 #define SIZE_IN_BITS(___1835) (sizeof(___1835)*8)
 #define VALID_ITEM_ADDRESS_PARTITION(itemAddressPartition) \
 ((itemAddressPartition) != tecplot::___2088::INVALID_PARTITION && \
 (SIZE_IN_BITS(tecplot::___2088::___2978) == tecplot::___2088::PartitionBitSize || \
 (SIZE_IN_BITS(tecplot::___2088::___2978) > tecplot::___2088::PartitionBitSize && \
 uint64_t(itemAddressPartition) >> tecplot::___2088::PartitionBitSize == uint64_t(0))))
 #define VALID_ITEM_ADDRESS_SUBZONE_OFFSET(itemAddressSubzoneOffset) \
 ((itemAddressSubzoneOffset) != tecplot::___2088::INVALID_SUBZONE_OFFSET && \
 (SIZE_IN_BITS(tecplot::___2088::SubzoneOffset_t) == tecplot::___2088::SubzoneOffsetBitSize || \
 (SIZE_IN_BITS(tecplot::___2088::SubzoneOffset_t) > tecplot::___2088::SubzoneOffsetBitSize && \
 uint64_t(itemAddressSubzoneOffset) >> tecplot::___2088::SubzoneOffsetBitSize == uint64_t(0))))
 #define VALID_ITEM_ADDRESS_ITEM_OFFSET(itemAddressItemOffset) \
 ((itemAddressItemOffset) != tecplot::___2088::INVALID_ITEM_OFFSET && \
 (SIZE_IN_BITS(tecplot::___2088::ItemOffset_t) == tecplot::___2088::ItemOffsetBitSize || \
 (SIZE_IN_BITS(tecplot::___2088::ItemOffset_t) > tecplot::___2088::ItemOffsetBitSize && \
 uint64_t(itemAddressItemOffset) >> tecplot::___2088::ItemOffsetBitSize == uint64_t(0))))
 #define VALID_UNIFORM_ITEM_ADDRESS(___2087) \
 ((___2087).___14() == tecplot::___2088::UniformAddressType)
 #define VALID_SZL_ITEM_ADDRESS(___2087) \
 ((___2087).___14() == tecplot::___2088::SzlAddressType && \
 VALID_ITEM_ADDRESS_PARTITION((___2087).___2975()) && \
 VALID_ITEM_ADDRESS_SUBZONE_OFFSET((___2087).subzoneOffset()) && \
 VALID_ITEM_ADDRESS_ITEM_OFFSET((___2087).itemOffset()))
 #define VALID_ITEM_ADDRESS(___2087) \
 (VALID_UNIFORM_ITEM_ADDRESS(___2087) || \
 VALID_SZL_ITEM_ADDRESS(___2087))
 #define VALID_ITEM_ADDRESS_SUBZONE_ADDRESS(subzoneAddress) \
 (VALID_ITEM_ADDRESS_PARTITION((subzoneAddress).___2975()) && \
 VALID_ITEM_ADDRESS_SUBZONE_OFFSET((subzoneAddress).subzoneOffset()))
class ___2088 { public: typedef uint32_t ___2978; typedef uint64_t SubzoneIndex_t; typedef uint32_t SubzoneOffset_t; typedef uint16_t ItemOffset_t; typedef int64_t ___4259; static uint32_t const ___15 = 1U; static uint32_t const PartitionBitSize = 23U; static uint32_t const SubzoneOffsetBitSize = 32U; static uint32_t const ItemOffsetBitSize = 8U; static uint32_t const ___4257 = 63U; static uint32_t const SzlAddressType     = 0U; static uint32_t const UniformAddressType = 1U; static ___2978 const INVALID_PARTITION = static_cast<___2978>((uint64_t(1) << PartitionBitSize) - uint64_t(1)); static ___2978 const UNKNOWN_PARTITION = 0; static ___2978 const MAX_PARTITION = INVALID_PARTITION - static_cast<___2978>(1); static SubzoneOffset_t const INVALID_SUBZONE_OFFSET = static_cast<SubzoneOffset_t>((uint64_t(1) << SubzoneOffsetBitSize) - uint64_t(1)); static SubzoneOffset_t const MAX_SUBZONE_OFFSET = INVALID_SUBZONE_OFFSET - static_cast<SubzoneOffset_t>(1); static ItemOffset_t const INVALID_ITEM_OFFSET = static_cast<ItemOffset_t>((uint64_t(1) << ItemOffsetBitSize)); static ItemOffset_t const MAX_ITEM_OFFSET = INVALID_ITEM_OFFSET - static_cast<ItemOffset_t>(1); class SubzoneAddress { public: inline SubzoneAddress() { INVARIANT(SIZE_IN_BITS(*this) == 64U); } inline SubzoneAddress( ___2978     ___2975, SubzoneOffset_t subzoneOffset) : m_partition(___2975) , m_subzoneOffset(subzoneOffset) { INVARIANT(SIZE_IN_BITS(*this) == 64U); REQUIRE(VALID_ITEM_ADDRESS_PARTITION(m_partition)); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(m_subzoneOffset)); } inline ___2978 ___2975() const { REQUIRE(VALID_ITEM_ADDRESS_PARTITION(m_partition)); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(m_subzoneOffset)); return m_partition; } inline SubzoneOffset_t subzoneOffset() const { REQUIRE(VALID_ITEM_ADDRESS_PARTITION(m_partition)); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(m_subzoneOffset)); return m_subzoneOffset; } inline bool operator==(SubzoneAddress const& ___2886) const { REQUIRE(VALID_ITEM_ADDRESS_PARTITION(m_partition)); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(m_subzoneOffset)); return m_partition == ___2886.m_partition && m_subzoneOffset == ___2886.m_subzoneOffset; } private: ___2978     m_partition; SubzoneOffset_t m_subzoneOffset; }; inline ___2088() { INVARIANT(___4304()); } inline ___2088( ___2978     ___2975, SubzoneOffset_t subzoneOffset, ItemOffset_t    itemOffset) { INVARIANT(___4304()); REQUIRE(VALID_ITEM_ADDRESS_PARTITION(___2975)); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(subzoneOffset)); REQUIRE(VALID_ITEM_ADDRESS_ITEM_OFFSET(itemOffset)); ___476(___15 + ___4257 == SIZE_IN_BITS(___2088)); ___476(___15 + PartitionBitSize + SubzoneOffsetBitSize + ItemOffsetBitSize == SIZE_IN_BITS(___2088)); m.___14                  = SzlAddressType; m.szlItemAddress.___2975     = ___2975; m.szlItemAddress.subzoneOffset = subzoneOffset;
m.szlItemAddress.itemOffset    = itemOffset; } inline ___2088( SubzoneAddress subzoneAddress, ItemOffset_t   itemOffset) { INVARIANT(___4304()); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_ADDRESS(subzoneAddress)); REQUIRE(VALID_ITEM_ADDRESS_ITEM_OFFSET(itemOffset)); ___476(___15 + ___4257 == SIZE_IN_BITS(___2088)); ___476(___15 + PartitionBitSize + SubzoneOffsetBitSize + ItemOffsetBitSize == SIZE_IN_BITS(___2088)); m.___14                  = SzlAddressType; m.szlItemAddress.___2975     = subzoneAddress.___2975(); m.szlItemAddress.subzoneOffset = subzoneAddress.subzoneOffset(); m.szlItemAddress.itemOffset    = itemOffset; } inline explicit ___2088(___4259 ___4256) { INVARIANT(___4304()); ___476(___15 + ___4257 == SIZE_IN_BITS(___2088)); ___476(___15 + PartitionBitSize + SubzoneOffsetBitSize + ItemOffsetBitSize == SIZE_IN_BITS(___2088)); m.___14           = UniformAddressType; m.___4254.___2863 = ___4256; } inline bool ___2063() const { ENSURE(m.___14 == SzlAddressType || m.___14 == UniformAddressType); return m.___14 == UniformAddressType; } inline bool isSzlItem() const { ENSURE(m.___14 == SzlAddressType || m.___14 == UniformAddressType); return m.___14 == SzlAddressType; } inline uint32_t ___14() const { ENSURE(m.___14 == SzlAddressType || m.___14 == UniformAddressType); return m.___14; } inline SubzoneAddress subzoneAddress() const { REQUIRE(m.___14 == SzlAddressType); return SubzoneAddress(m.szlItemAddress.___2975, m.szlItemAddress.subzoneOffset); } inline ___2978 ___2975() const { REQUIRE(m.___14 == SzlAddressType); ENSURE(VALID_ITEM_ADDRESS_PARTITION(m.szlItemAddress.___2975)); return m.szlItemAddress.___2975; } inline SubzoneOffset_t subzoneOffset() const { REQUIRE(m.___14 == SzlAddressType); ENSURE(VALID_ITEM_ADDRESS_SUBZONE_OFFSET(m.szlItemAddress.subzoneOffset)); return m.szlItemAddress.subzoneOffset; } inline ItemOffset_t itemOffset() const { REQUIRE(m.___14 == SzlAddressType); ENSURE(VALID_ITEM_ADDRESS_ITEM_OFFSET(m.szlItemAddress.itemOffset)); return m.szlItemAddress.itemOffset; } inline ___4259 ___4256() const { REQUIRE(___2063()); return m.___4254.___2863; } inline uint64_t toRawBits() const { return m.___3268; } static ___2088 fromRawBits(uint64_t ___3268) { ___2088 ___3356; ___3356.m.___3268 = ___3268; ENSURE(VALID_ITEM_ADDRESS(___3356)); return ___3356; } inline bool operator==(___2088 const& ___2886) const { REQUIRE(VALID_ITEM_ADDRESS(___2886));
 #if defined LINUX
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
 #endif
return m.___3268 == ___2886.m.___3268;
 #if defined LINUX
 #pragma GCC diagnostic pop
 #endif
} private:
 #if !defined NO_ASSERTS
static bool ___4304() { return (SIZE_IN_BITS(___2088) <= 64U && SIZE_IN_BITS(___2978)     >= PartitionBitSize     && SIZE_IN_BITS(SubzoneOffset_t) >= SubzoneOffsetBitSize && SIZE_IN_BITS(ItemOffset_t)    >  ItemOffsetBitSize    && SIZE_IN_BITS(___4259) >= ___4257 && ___15 + ___4257 == SIZE_IN_BITS(___2088) && ___15 + PartitionBitSize + SubzoneOffsetBitSize + ItemOffsetBitSize == SIZE_IN_BITS(___2088)); }
 #endif
struct SzlItemAddress_s { uint64_t ___14:___15; uint64_t ___2975:PartitionBitSize; uint64_t subzoneOffset:SubzoneOffsetBitSize; uint64_t itemOffset:ItemOffsetBitSize; }; struct ___4255 { int64_t ___14:___15; int64_t ___2863:___4257; }; union { uint64_t         ___14:___15; SzlItemAddress_s szlItemAddress; ___4255 ___4254; uint64_t         ___3268; } m; }; inline bool operator<( ___2088 const& ___2227, ___2088 const& ___3390) { REQUIRE(VALID_ITEM_ADDRESS(___2227)); REQUIRE(VALID_ITEM_ADDRESS(___3390)); uint32_t const ___2228 = ___2227.___14(); uint32_t const ___3391 = ___3390.___14(); if (___2228 != ___3391) { return ___2228 < ___3391; } else if (___2228 == tecplot::___2088::UniformAddressType) { return ___2227.___4256() < ___3390.___4256(); } else if (___2227.___2975() == ___3390.___2975()) { if (___2227.subzoneOffset() == ___3390.subzoneOffset()) return ___2227.itemOffset() < ___3390.itemOffset(); else return ___2227.subzoneOffset() < ___3390.subzoneOffset(); } else { return ___2227.___2975() < ___3390.___2975(); } } inline bool operator!=( ___2088 const& ___2227, ___2088 const& ___3390) { REQUIRE(VALID_ITEM_ADDRESS(___2227)); REQUIRE(VALID_ITEM_ADDRESS(___3390)); return !(___2227 == ___3390); } inline bool operator<=( ___2088 const& ___2227, ___2088 const& ___3390) { REQUIRE(VALID_ITEM_ADDRESS(___2227)); REQUIRE(VALID_ITEM_ADDRESS(___3390)); return ___2227 < ___3390 || ___2227 == ___3390; } inline bool operator>( ___2088 const& ___2227, ___2088 const& ___3390) { REQUIRE(VALID_ITEM_ADDRESS(___2227)); REQUIRE(VALID_ITEM_ADDRESS(___3390)); return !(___2227 < ___3390) && !(___2227 == ___3390); } inline bool operator>=( ___2088 const& ___2227, ___2088 const& ___3390) { REQUIRE(VALID_ITEM_ADDRESS(___2227)); REQUIRE(VALID_ITEM_ADDRESS(___3390)); return !(___2227 < ___3390); } inline bool operator<( ___2088::SubzoneAddress const& ___2227, ___2088::SubzoneAddress const& ___3390) { REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_ADDRESS(___2227)); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_ADDRESS(___3390)); if (___2227.___2975() == ___3390.___2975()) return ___2227.subzoneOffset() < ___3390.subzoneOffset(); else return ___2227.___2975() < ___3390.___2975(); } inline bool operator!=( ___2088::SubzoneAddress const& ___2227, ___2088::SubzoneAddress const& ___3390) { REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_ADDRESS(___2227)); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_ADDRESS(___3390)); return !(___2227 == ___3390); } inline bool operator<=( ___2088::SubzoneAddress const& ___2227, ___2088::SubzoneAddress const& ___3390) { REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_ADDRESS(___2227)); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_ADDRESS(___3390)); return ___2227 < ___3390 || ___2227 == ___3390; } inline bool operator>( ___2088::SubzoneAddress const& ___2227, ___2088::SubzoneAddress const& ___3390) { REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_ADDRESS(___2227)); REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_ADDRESS(___3390)); return !(___2227 < ___3390) && !(___2227 == ___3390); } inline bool operator>=( ___2088::SubzoneAddress const& ___2227, ___2088::SubzoneAddress const& ___3390) { REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_ADDRESS(___2227));
REQUIRE(VALID_ITEM_ADDRESS_SUBZONE_ADDRESS(___3390)); return !(___2227 < ___3390); } }
