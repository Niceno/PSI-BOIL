 #pragma once
#include "ThirdPartyHeadersBegin.h"
#  include <string>
#include "ThirdPartyHeadersEnd.h"
#include "SzlFileLoader.h"
#include "stringformat.h"
namespace tecplot { namespace ___3931 { class IODescription { public: typedef uint32_t SegmentIndex_t; static ___4350 const               NO_VAR = BAD_VAR_INDEX; static ___4634 const              NO_ZONE = BAD_ZONE_INDEX; static ___2088::___2978 const NO_PARTITION = ___2088::INVALID_PARTITION; static SegmentIndex_t const           NO_SEGMENT = SegmentIndex_t(-1); private: char const*              ___2493; ___4350               m_var; ___4634              ___2675; ___2088::___2978 m_partition; SegmentIndex_t           m_segment; char const*              m_suffix; public: explicit IODescription( char const*              ___2683 = NULL, ___4350               ___4334 = NO_VAR, ___4634              zone = NO_ZONE, ___2088::___2978 ___2975 = NO_PARTITION, SegmentIndex_t           segment = NO_SEGMENT, char const*              suffix = NULL) : ___2493(___2683) , m_var(___4334) , ___2675(zone) , m_partition(___2975) , m_segment(segment) , m_suffix(suffix) {} char const* ___2683() const { return ___2493; } ___4350 ___4334() const { return m_var; } ___4634 zone() const { return ___2675; } ___2088::___2978 ___2975() const { return m_partition; } SegmentIndex_t segment() const { return m_segment; } char const* suffix() const { return m_suffix; } ___372 ___2065() const { return ___4224; } ___372 isEmpty() const { return ___2493==NULL; } void getFormattedDescription( char*  formattedDescription, size_t formattedDescriptionSize) const { ___372 isAsciiOnly = ___1303; size_t ___2863; if ( ___2493 != NULL ) { ___2863 = snprintf(formattedDescription, formattedDescriptionSize, "%s", ___2493); if ( ___2863 > 0 && formattedDescription[___2863-1] == '*' ) { ___2863--; formattedDescription[___2863] = '\0'; isAsciiOnly = ___4224; } } else ___2863 = snprintf(formattedDescription, formattedDescriptionSize, "unspecified"); if ( m_var != NO_VAR && ___2863 < formattedDescriptionSize ) ___2863 += snprintf(formattedDescription+___2863, formattedDescriptionSize-___2863, "%sVar%" PRIu64, ___2493 != NULL ? "For" : "", uint64_t(m_var+1)); if ( ___2675 != NO_ZONE && ___2863 < formattedDescriptionSize ) ___2863 += snprintf(formattedDescription+___2863, formattedDescriptionSize-___2863, "%sZone%" PRIu64, ___2493 != NULL && m_var == NO_VAR ? "For" : "", uint64_t(___2675+1)); if ( m_partition != NO_PARTITION && ___2863 < formattedDescriptionSize ) ___2863 += snprintf(formattedDescription+___2863, formattedDescriptionSize-___2863, "%sPartition%" PRIu64, ___2493 != NULL && m_var == NO_VAR && ___2675 == NO_ZONE ? "For" : "", uint64_t(m_partition+1)); if ( m_segment != NO_SEGMENT && ___2863 < formattedDescriptionSize ) ___2863 += snprintf(formattedDescription+___2863, formattedDescriptionSize-___2863, "%sSegment%" PRIu64, ___2493 != NULL && m_var == NO_VAR && ___2675 == NO_ZONE && m_partition == NO_PARTITION ? "For" : "", uint64_t(m_segment+1)); if ( m_suffix != NULL && ___2863 < formattedDescriptionSize ) ___2863 += snprintf(formattedDescription+___2863, formattedDescriptionSize-___2863, "%s", m_suffix);
if ( isAsciiOnly && ___2863 < formattedDescriptionSize ) { formattedDescription[___2863] = '*'; if ( ___2863 < formattedDescriptionSize ) ___2863++; formattedDescription[___2863] = '\0'; } } }; }}
