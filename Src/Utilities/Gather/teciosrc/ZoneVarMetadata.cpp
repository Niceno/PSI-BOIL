#include "ZoneVarMetadata.h"
#include "ThirdPartyHeadersBegin.h"
#include <cctype>
#include <new>
#include <sstream>
#include <boost/assign.hpp>
#include <boost/static_assert.hpp>
#include "ThirdPartyHeadersEnd.h"
#include "AltTecUtil.h"
#include "fileStuff.h"
#include "ItemSetIterator.h"
#include "zoneUtil.h"
namespace tecplot { namespace ___3931 { namespace { ___4634 varGetPrevSharedZone( ___4634           zone, ___4634           ___341, ___4350            ___4334, ___37&           ___36, ___4633 const& zoneShareConnectivityWithZone) { ___4634 prevSharedZone = ___36.___912(NULL, zone + 1, ___4334 + 1) - 1; if (prevSharedZone != NOT_SHARED) { if (___36.___4618(zone + 1) == ___4702) {
 #if !defined TECIOMPI 
if (___36.___4618((___4634)prevSharedZone + 1) == ___4702) { ___1842 ___4630; ___1842 sharedZoneIJK; ___36.___4613((___4634)(zone + 1), ___4630); ___36.___4613((___4634)(prevSharedZone + 1), sharedZoneIJK); if (___4630 != sharedZoneIJK) prevSharedZone = NOT_SHARED; }
 #endif
} else if (zoneShareConnectivityWithZone[zone - ___341] == NOT_SHARED) { prevSharedZone = NOT_SHARED; } } return prevSharedZone; } } ___4705::___4705() {} ___4705::___4705( ___37&      ___36, ItemSetIterator& varIter, ItemSetIterator& zoneIter, bool             allowSharingBetweenFiles  ) { BOOST_STATIC_ASSERT(static_cast<size_t>(END_ValueLocation_e) <= uint8_t(-1)); BOOST_STATIC_ASSERT(static_cast<size_t>(END_FieldDataType_e) <= uint8_t(-1)); if (!___36.___894()) return; m_numVars = varIter.___2810(); m_numZones = zoneIter.___2810(); if (!m_zoneNames.alloc(m_numZones) || !m_zoneTypes.alloc(m_numZones) || !m_zoneFaceNeighborModes.alloc(m_numZones) || !m_zoneSolutionTimes.alloc(m_numZones) || !m_zoneStrandIDs.alloc(m_numZones) || !m_zoneParentZones.alloc(m_numZones) || !m_zoneIMaxOrNumNodes.alloc(m_numZones) || !m_zoneJMaxOrNumCells.alloc(m_numZones) || !m_zoneKMaxOrNumCorners.alloc(m_numZones) || !m_zoneShareConnectivityWithZone.alloc(m_numZones) || !m_varNames.alloc(m_numVars) || !___3354(m_vzMinMaxes, m_numVars, m_numZones) || !___3354(m_vzValueLocations, m_numVars, m_numZones) || !___3354(m_vzFieldDataTypes, m_numVars, m_numZones) || !___3354(m_vzIsPassive, m_numVars, m_numZones) || !___3354(m_vzShareVarWithZone, m_numVars, m_numZones)) { throw std::bad_alloc(); } std::map<ZoneType_e, char> zoneTypeMap = boost::assign::map_list_of<ZoneType_e, char> (___4702, ___4703) (___4700, ZONETYPE_FETRIANGLE_CHAR) (___4698, ZONETYPE_FEQUAD_CHAR) (___4699, ZONETYPE_FETETRA_CHAR) (___4693, ZONETYPE_FEBRICK_CHAR) (___4694, ZONETYPE_FELINESEG_CHAR) (___4696, ZONETYPE_FEPOLYGON_CHAR) (___4697, ZONETYPE_FEPOLYHEDRON_CHAR) (___4695, ZONETYPE_FEMIXEDVOLUME_CHAR); zoneIter.reset(); ___4634 ___341 = zoneIter.baseItem(); while (zoneIter.hasNext()) { ___4634 const ___902 = zoneIter.next(); ___4634 const fileZone = ___902 - ___341; if (!___36.___4636(___902 + 1)) continue; char *zoneName = NULL; if (___36.___4614(___902 + 1, &zoneName)) { m_zoneNames[fileZone] = zoneName; ___36.___3815(&zoneName); } else { throw std::bad_alloc(); } m_zoneFaceNeighborModes[fileZone] = static_cast<uint8_t>(___36.___834(___902 + 1)); ___1842 ___4630; ___36.___4613(___902 + 1, ___4630); ZoneType_e const ___4690 = ___36.___4618(___902 + 1); m_zoneTypes[fileZone] = zoneTypeMap[___4690]; if (___3893(___4690, ___4630)) m_zoneTypes[fileZone] = static_cast<char>(std::toupper(m_zoneTypes[fileZone])); m_zoneSolutionTimes[fileZone] = ___36.___4616(___902 + 1); m_zoneStrandIDs[fileZone] = ___36.___4617(___902 + 1); ___4634 ___2972 = ___36.___4615(___902 + 1) - 1; ___476(___2972 == -1 || ___2972 >= ___341);
m_zoneParentZones[fileZone] = ___2972 == -1 ? ___2972 : ___2972 - ___341; if (___4690 == ___4702) { m_zoneIMaxOrNumNodes[fileZone]   = ___4630.i(); m_zoneJMaxOrNumCells[fileZone]   = ___4630.___2103(); m_zoneKMaxOrNumCorners[fileZone] = ___4630.___2132(); } else { m_zoneIMaxOrNumNodes[fileZone] = ___4630.___1668(); m_zoneJMaxOrNumCells[fileZone] = ___4630.___1666(); if (___3156(___4690)) m_zoneKMaxOrNumCorners[fileZone] = ___4630.___2132(); else m_zoneKMaxOrNumCorners[fileZone] = ___4630.___1667(); } ___4634 const prevSharedZone = ___36.___542(NULL, ___902 + 1) - 1; if (prevSharedZone == NOT_SHARED) m_zoneShareConnectivityWithZone[fileZone] = NOT_SHARED; else if (prevSharedZone < ___341) m_zoneShareConnectivityWithZone[fileZone] = (allowSharingBetweenFiles ? prevSharedZone : NOT_SHARED); else if (m_zoneShareConnectivityWithZone[prevSharedZone - ___341] == NOT_SHARED) m_zoneShareConnectivityWithZone[fileZone] = prevSharedZone - ___341; else m_zoneShareConnectivityWithZone[fileZone] = m_zoneShareConnectivityWithZone[prevSharedZone - ___341]; ___476(IMPLICATION(!allowSharingBetweenFiles, m_zoneShareConnectivityWithZone[fileZone] == NOT_SHARED || m_zoneShareConnectivityWithZone[m_zoneShareConnectivityWithZone[fileZone]] == NOT_SHARED)); } varIter.reset(); ___4350 const baseVar = varIter.baseItem(); while (varIter.hasNext()) { ___4350 const datasetVar = varIter.next(); ___4350 const fileVar = datasetVar - baseVar; char* ___4360 = NULL; if (___36.___4342(datasetVar+1, &___4360)) { m_varNames[fileVar] = ___4360; ___36.___3815(&___4360); } else { throw std::bad_alloc(); } } varIter.reset(); while (varIter.hasNext()) { ___4350 const datasetVar = varIter.next(); ___4350 const fileVar = datasetVar - baseVar; zoneIter.reset(); ___341 = zoneIter.baseItem(); while (zoneIter.hasNext()) { ___4634 const ___902 = zoneIter.next(); ___4634 const fileZone = ___902 - ___341; if (!___36.___4636(___902 + 1)) continue; ValueLocation_e ___4324 = ___36.___908(___902 + 1, datasetVar + 1); m_vzValueLocations[fileVar][fileZone] = static_cast<uint8_t>(___4324); FieldDataType_e ___1361 = ___36.___921(___902+1,datasetVar+1); m_vzFieldDataTypes[fileVar][fileZone] = static_cast<uint8_t>(___1361); ___372 varIsPassive = ___36.___924(___902 + 1, datasetVar + 1); m_vzIsPassive[fileVar][fileZone] = (varIsPassive ? 1 : 0); ___4634 const prevSharedZone = varGetPrevSharedZone( ___902, ___341, datasetVar, ___36, m_zoneShareConnectivityWithZone); if (prevSharedZone == NOT_SHARED) m_vzShareVarWithZone[fileVar][fileZone] = NOT_SHARED; else if (prevSharedZone < ___341) m_vzShareVarWithZone[fileVar][fileZone] = (allowSharingBetweenFiles ? prevSharedZone : NOT_SHARED); else if (m_vzShareVarWithZone[fileVar][prevSharedZone - ___341] == NOT_SHARED) m_vzShareVarWithZone[fileVar][fileZone] = prevSharedZone - ___341;
else m_vzShareVarWithZone[fileVar][fileZone] = m_vzShareVarWithZone[fileVar][prevSharedZone - ___341]; if (prevSharedZone >= ___341) { m_vzMinMaxes[fileVar][fileZone] = m_vzMinMaxes[fileVar][prevSharedZone - ___341]; } else { double minValue; double maxValue; ___36.___911(___902 + 1, datasetVar + 1, &minValue, &maxValue); m_vzMinMaxes[fileVar][fileZone] = ___2477(minValue, maxValue); }
 #if !defined TECIOMPI 
___476(IMPLICATION(!allowSharingBetweenFiles, m_vzShareVarWithZone[fileVar][fileZone] == NOT_SHARED || m_vzShareVarWithZone[fileVar][m_vzShareVarWithZone[fileVar][fileZone]] == NOT_SHARED));
 #endif
} } } bool ___4705::alloc(size_t ___2844, size_t ___2841) { REQUIRE(___2844 > 0); REQUIRE(___2841 > 0); m_numZones = ___2844; m_numVars = ___2841; bool ___3356 = m_zoneNames.alloc(___2844) && m_zoneTypes.alloc(___2844) && m_zoneFaceNeighborModes.alloc(___2844) && m_zoneSolutionTimes.alloc(___2844) && m_zoneStrandIDs.alloc(___2844) && m_zoneParentZones.alloc(___2844) && m_zoneIMaxOrNumNodes.alloc(___2844) && m_zoneJMaxOrNumCells.alloc(___2844) && m_zoneKMaxOrNumCorners.alloc(___2844) && m_zoneShareConnectivityWithZone.alloc(___2844) && m_varNames.alloc(___2841) && m_vzMinMaxes.alloc(___2841) && m_vzValueLocations.alloc(___2841) && m_vzFieldDataTypes.alloc(___2841) && m_vzIsPassive.alloc(___2841) && m_vzShareVarWithZone.alloc(___2841); for (size_t ___4334 = 0; ___3356 && ___4334 < ___2841; ++___4334) { ___3356 = m_vzMinMaxes[___4334].alloc(___2844) && m_vzValueLocations[___4334].alloc(___2844) && m_vzFieldDataTypes[___4334].alloc(___2844) && m_vzIsPassive[___4334].alloc(___2844) && m_vzShareVarWithZone[___4334].alloc(___2844); } return ___3356; } bool ___4705::assign(___4705 const& ___2886, size_t zoneOffset, size_t varOffset) { REQUIRE(___2886.m_numZones + zoneOffset <= m_numZones); REQUIRE(___2886.m_numVars + varOffset <= m_numVars); try { for (size_t ___4334 = 0; ___4334 < ___2886.m_numVars; ++___4334) m_varNames[varOffset + ___4334] = ___2886.m_varNames[___4334]; for (size_t zone = 0; zone < ___2886.m_numZones; ++zone) { m_zoneNames                    [zoneOffset + zone] = ___2886.m_zoneNames[zone]; m_zoneTypes                    [zoneOffset + zone] = ___2886.m_zoneTypes[zone]; m_zoneFaceNeighborModes        [zoneOffset + zone] = ___2886.m_zoneFaceNeighborModes[zone]; m_zoneSolutionTimes            [zoneOffset + zone] = ___2886.m_zoneSolutionTimes[zone]; m_zoneStrandIDs                [zoneOffset + zone] = ___2886.m_zoneStrandIDs[zone]; m_zoneParentZones              [zoneOffset + zone] = ___2886.m_zoneParentZones[zone]; m_zoneIMaxOrNumNodes           [zoneOffset + zone] = ___2886.m_zoneIMaxOrNumNodes[zone]; m_zoneJMaxOrNumCells           [zoneOffset + zone] = ___2886.m_zoneJMaxOrNumCells[zone]; m_zoneKMaxOrNumCorners         [zoneOffset + zone] = ___2886.m_zoneKMaxOrNumCorners[zone]; m_zoneShareConnectivityWithZone[zoneOffset + zone] = ___2886.m_zoneShareConnectivityWithZone[zone]; for (size_t ___4334 = 0; ___4334 < ___2886.m_numVars; ++___4334) { m_vzMinMaxes        [varOffset + ___4334][zoneOffset + zone] = ___2886.m_vzMinMaxes[___4334][zone]; m_vzValueLocations  [varOffset + ___4334][zoneOffset + zone] = ___2886.m_vzValueLocations[___4334][zone]; m_vzFieldDataTypes  [varOffset + ___4334][zoneOffset + zone] = ___2886.m_vzFieldDataTypes[___4334][zone]; m_vzIsPassive       [varOffset + ___4334][zoneOffset + zone] = ___2886.m_vzIsPassive[___4334][zone]; m_vzShareVarWithZone[varOffset + ___4334][zoneOffset + zone] = ___2886.m_vzShareVarWithZone[___4334][zone]; } } } catch (std::bad_alloc const&) { return false; } return true; } }}
