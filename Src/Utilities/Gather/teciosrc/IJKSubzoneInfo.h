 #pragma once
#include "ThirdPartyHeadersBegin.h"
#   include <algorithm>
#include "ThirdPartyHeadersEnd.h"
#include "SzlFileLoader.h"
#include "IJK.h"
namespace tecplot { namespace ___3931 { class IJKSubzoneInfo { private: ___1842 m_zoneIJKDim; ___1842 m_zoneLastIJKIndex; ___1842 m_subzoneItemsMaxIJKDim; ___2088::___2978 m_partition; ___1842 m_subzoneTilingIJKDim; ___1842 m_subzoneTilingIJKShift; ___2088::SubzoneOffset_t m_numSubzones;
 #if !defined NO_ASSERTS
bool ___2490;
 #endif
public: IJKSubzoneInfo( ___1842 const&               zoneIJKDim, ___1842 const&               subzoneMaxIJKDim, ___2088::___2978 ___2975, bool                     minimizeNumSubzones) : m_zoneIJKDim(zoneIJKDim) , m_zoneLastIJKIndex(zoneIJKDim.maxOp(1)-1) , m_subzoneItemsMaxIJKDim(subzoneMaxIJKDim) , m_partition(___2975) , m_subzoneTilingIJKDim(numSubzonesForDirection(zoneIJKDim.i(), ___2088::ItemOffset_t(subzoneMaxIJKDim.i()), minimizeNumSubzones), numSubzonesForDirection(zoneIJKDim.___2103(), ___2088::ItemOffset_t(subzoneMaxIJKDim.___2103()), minimizeNumSubzones), numSubzonesForDirection(zoneIJKDim.___2132(), ___2088::ItemOffset_t(subzoneMaxIJKDim.___2132()), minimizeNumSubzones)) , m_subzoneTilingIJKShift(subzoneShiftForDirection(zoneIJKDim.i(), ___2088::ItemOffset_t(subzoneMaxIJKDim.i()), minimizeNumSubzones), subzoneShiftForDirection(zoneIJKDim.___2103(), ___2088::ItemOffset_t(subzoneMaxIJKDim.___2103()), minimizeNumSubzones), subzoneShiftForDirection(zoneIJKDim.___2132(), ___2088::ItemOffset_t(subzoneMaxIJKDim.___2132()), minimizeNumSubzones)) , m_numSubzones( ___2088::SubzoneOffset_t(m_subzoneTilingIJKDim.blockSize()) )
 #if !defined NO_ASSERTS
, ___2490(minimizeNumSubzones)
 #endif
{ REQUIRE(zoneIJKDim>0); REQUIRE(subzoneMaxIJKDim>0); } IJKSubzoneInfo() : m_zoneIJKDim(0,0,0) , m_zoneLastIJKIndex(0,0,0) , m_subzoneItemsMaxIJKDim(0,0,0) , m_partition(0) , m_subzoneTilingIJKDim(0,0,0) , m_subzoneTilingIJKShift(0,0,0) , m_numSubzones(0)
 #if !defined NO_ASSERTS
, ___2490(0)
 #endif
{} ~IJKSubzoneInfo() {} inline void swap(IJKSubzoneInfo& ___2886) { using std::swap; swap(m_zoneIJKDim, ___2886.m_zoneIJKDim); swap(m_zoneLastIJKIndex, ___2886.m_zoneLastIJKIndex); swap(m_subzoneItemsMaxIJKDim, ___2886.m_subzoneItemsMaxIJKDim); swap(m_subzoneTilingIJKDim, ___2886.m_subzoneTilingIJKDim); swap(m_subzoneTilingIJKShift, ___2886.m_subzoneTilingIJKShift); swap(m_numSubzones, ___2886.m_numSubzones); } inline void reset( ___1842 const& zoneIJKSize, ___1842 const& subzoneIJKMax, bool       minimizeNumSubzones = DEFAULT_MINIMIZE_IJK_NUM_SUBZONES) { REQUIRE(zoneIJKSize>0); REQUIRE(subzoneIJKMax>0); REQUIRE(minimizeNumSubzones==DEFAULT_MINIMIZE_IJK_NUM_SUBZONES); m_zoneIJKDim = zoneIJKSize; m_zoneLastIJKIndex = zoneIJKSize.maxOp(1)-1; m_subzoneItemsMaxIJKDim = subzoneIJKMax; m_subzoneTilingIJKDim = ___1842( numSubzonesForDirection(zoneIJKSize.i(), ___2088::ItemOffset_t(subzoneIJKMax.i()), minimizeNumSubzones), numSubzonesForDirection(zoneIJKSize.___2103(), ___2088::ItemOffset_t(subzoneIJKMax.___2103()), minimizeNumSubzones), numSubzonesForDirection(zoneIJKSize.___2132(), ___2088::ItemOffset_t(subzoneIJKMax.___2132()), minimizeNumSubzones) ); m_subzoneTilingIJKShift = ___1842( subzoneShiftForDirection(zoneIJKSize.i(), ___2088::ItemOffset_t(subzoneIJKMax.i()), minimizeNumSubzones), subzoneShiftForDirection(zoneIJKSize.___2103(), ___2088::ItemOffset_t(subzoneIJKMax.___2103()), minimizeNumSubzones), subzoneShiftForDirection(zoneIJKSize.___2132(), ___2088::ItemOffset_t(subzoneIJKMax.___2132()), minimizeNumSubzones) ); m_numSubzones = ___2088::SubzoneOffset_t(m_subzoneTilingIJKDim.blockSize()); } inline bool ___2065() const { return m_zoneIJKDim > 0 && m_subzoneItemsMaxIJKDim > 0; } inline bool validSubzone(___2088::SubzoneOffset_t ___3878) const { return ___3878 < getNumSzs(); } inline bool validSzAddress(___2088::SubzoneAddress szAddress) const { return validSubzone(szAddress.subzoneOffset()) && szAddress.___2975() == m_partition; } inline bool validItemAddress(___2088 ___2087) const { return validSzAddress(___2087.subzoneAddress()) && ___2087.itemOffset() < numItemsInSz(___2087.subzoneOffset()); } ___81 getNumItems(void) const { return m_zoneIJKDim.blockSize(); } ___1842 const& ijkDim(void) const { return m_zoneIJKDim; } ___1842 const& ijkLastIndex(void) const { ___476(m_zoneLastIJKIndex == m_zoneIJKDim.maxOp(1)-1); return m_zoneLastIJKIndex; } ___2088::SubzoneOffset_t getNumSzs(void) const { ENSURE(m_numSubzones == ___2088::SubzoneOffset_t(m_subzoneTilingIJKDim.blockSize())); ENSURE(m_numSubzones == calcNumSubzones(m_zoneIJKDim, m_subzoneItemsMaxIJKDim, ___2490)); return m_numSubzones; } static inline ___2088::SubzoneOffset_t numSubzonesForDirection( ___81                itemIndexDim, ___2088::ItemOffset_t subzoneIndexMax, bool                      minimizeNumSubzones = DEFAULT_MINIMIZE_IJK_NUM_SUBZONES) { REQUIRE(itemIndexDim>0); REQUIRE(subzoneIndexMax<=___2088::MAX_ITEM_OFFSET+1); ___2088::SubzoneOffset_t numSubzonesForDir;
if ( minimizeNumSubzones ) { numSubzonesForDir = ___2088::SubzoneOffset_t( (itemIndexDim+subzoneIndexMax-1)/subzoneIndexMax ); } else { numSubzonesForDir = ___2088::SubzoneOffset_t( 1+(itemIndexDim/subzoneIndexMax) ); } ENSURE(numSubzonesForDir>0); ENSURE((___81)numSubzonesForDir*subzoneIndexMax>=itemIndexDim); ENSURE( IMPLICATION(minimizeNumSubzones, ___81(numSubzonesForDir-1)*subzoneIndexMax<itemIndexDim) ); return numSubzonesForDir; } static ___2088::SubzoneOffset_t calcNumSubzones( ___1842 const& zoneIJKDim, ___1842 const& subzoneIJKMax, bool       minimizeIJKNumSubzones) { REQUIRE(zoneIJKDim>0); REQUIRE(subzoneIJKMax>0); ___1842 const subzoneTilingIJK( numSubzonesForDirection(zoneIJKDim.i(), ___2088::ItemOffset_t(subzoneIJKMax.i()), minimizeIJKNumSubzones), numSubzonesForDirection(zoneIJKDim.___2103(), ___2088::ItemOffset_t(subzoneIJKMax.___2103()), minimizeIJKNumSubzones), numSubzonesForDirection(zoneIJKDim.___2132(), ___2088::ItemOffset_t(subzoneIJKMax.___2132()), minimizeIJKNumSubzones)); ___2088::SubzoneOffset_t const numSubzones = ___2088::SubzoneOffset_t(subzoneTilingIJK.blockSize()); ENSURE(numSubzones>0 && numSubzones <= zoneIJKDim.blockSize()); return numSubzones; } static inline ___2088::ItemOffset_t subzoneShiftForDirection( ___81                itemIndexDim, ___2088::ItemOffset_t subzoneIndexMax, bool                      minimizeNumSubzones = DEFAULT_MINIMIZE_IJK_NUM_SUBZONES) { REQUIRE(itemIndexDim>0); REQUIRE(subzoneIndexMax>=3 && subzoneIndexMax<=___2088::MAX_ITEM_OFFSET+1); ___2088::ItemOffset_t const remainder = ___2088::ItemOffset_t(itemIndexDim % subzoneIndexMax); ___2088::ItemOffset_t subzoneShift = (subzoneIndexMax-remainder)/2; if ( minimizeNumSubzones && remainder == 0 ) subzoneShift = 0; ENSURE(subzoneShift<subzoneIndexMax); return subzoneShift; } ___1842 itemIJKStart(___1842 const& szIJK) const { INVARIANT(m_subzoneTilingIJKShift<m_subzoneItemsMaxIJKDim); ___1842 const indexStart = m_subzoneTilingIJKShift.maxOp(szIJK*m_subzoneItemsMaxIJKDim) - m_subzoneTilingIJKShift; ENSURE(indexStart >= 0); return indexStart; } ___1842 itemIJKEnd(___1842 const& szIJK) const { INVARIANT(m_subzoneTilingIJKShift < m_subzoneItemsMaxIJKDim); ___1842 const indexEnd = m_zoneIJKDim.minOp((szIJK + 1)*m_subzoneItemsMaxIJKDim - m_subzoneTilingIJKShift) - 1; ENSURE(indexEnd<m_zoneIJKDim); return indexEnd; } ___1842 szIJKAtSzIndex(___2088::SubzoneOffset_t ___3878) const { REQUIRE(validSubzone(___3878)); ___1842 const subzoneIJK = m_subzoneTilingIJKDim.ijkAtOffset(___3878); ENSURE(subzoneIJK<m_subzoneTilingIJKDim); return subzoneIJK; } ___2088::SubzoneAddress szAddressAtSzIJK(___1842 const& szIJK) const { REQUIRE(szIJK<m_subzoneTilingIJKDim); ___2088::SubzoneAddress const szAddress(m_partition, static_cast<___2088::SubzoneOffset_t>(m_subzoneTilingIJKDim.offsetAtIJK(szIJK))); ENSURE(validSzAddress(szAddress)); ENSURE(szIJKAtSzIndex(szAddress.subzoneOffset())==szIJK); return szAddress; } void subzoneIJKStartAndEnd( ___2088::SubzoneOffset_t ___3878,
___1842&                         ___1878, ___1842&                         ___1850) const { REQUIRE(___3878 < getNumSzs()); ___1842 const szIJK = szIJKAtSzIndex(___3878); ___1878 = itemIJKStart(szIJK); ___1850 = itemIJKEnd(szIJK); ENSURE(___1878<m_zoneIJKDim); ENSURE(___1850<m_zoneIJKDim); ENSURE(szAddressAtItemIJK(___1878).subzoneOffset() == ___3878); ENSURE(szAddressAtItemIJK(___1850).subzoneOffset()==___3878); } ___1842 subzoneIJKStart(___2088::SubzoneOffset_t ___3878) const { REQUIRE(___3878 < getNumSzs()); ___1842 const szIJK = szIJKAtSzIndex(___3878); ___1842 const ___1878 = itemIJKStart(szIJK); ENSURE(___1878<m_zoneIJKDim); ENSURE(szAddressAtItemIJK(___1878).subzoneOffset() == ___3878); return ___1878; } ___1842 subzoneIJKEnd(___2088::SubzoneOffset_t ___3878) const { REQUIRE(___3878 < getNumSzs()); ___1842 const szIJK = szIJKAtSzIndex(___3878); ___1842 const ___1850 = itemIJKEnd(szIJK); ENSURE(___1850 < m_zoneIJKDim); ENSURE(szAddressAtItemIJK(___1850).subzoneOffset() == ___3878); return ___1850; } ___1842 szIJKAtItemIJK(___1842 const& itemIJK) const { REQUIRE(itemIJK < m_zoneIJKDim); ___1842 const szIJK = (itemIJK+m_subzoneTilingIJKShift) / m_subzoneItemsMaxIJKDim; ENSURE(szIJK < m_subzoneTilingIJKDim); return szIJK; } ___2088::SubzoneAddress szAddressAtItemIJK(___1842 const& itemIJK) const { REQUIRE(itemIJK<m_zoneIJKDim); ___1842 const subzoneIJK = szIJKAtItemIJK(itemIJK); ___2088::SubzoneAddress const szAddress(m_partition, static_cast<___2088::SubzoneOffset_t>(m_subzoneTilingIJKDim.offsetAtIJK(subzoneIJK))); ENSURE(validSzAddress(szAddress)); return szAddress; } ___2088::SubzoneAddress szAddressAtItemIndex(___81 itemIndex) const { REQUIRE(itemIndex<getNumItems()); ___1842 const itemIJK = m_zoneIJKDim.ijkAtOffset(itemIndex); ___2088::SubzoneAddress const szAddress = szAddressAtItemIJK(itemIJK); ENSURE(validSzAddress(szAddress)); return szAddress; } ___2088 itemAddressAtItemIJK( ___1842 const& itemIJK, ___1842 const& szIJK) const { REQUIRE(itemIJK<m_zoneIJKDim); REQUIRE(szIJK<m_subzoneTilingIJKDim); ___2088::SubzoneOffset_t const szOffset = static_cast<___2088::SubzoneOffset_t>(m_subzoneTilingIJKDim.offsetAtIJK(szIJK)); ___1842 const ___1878 = itemIJKStart(szIJK); ___1842 const ___1850   = itemIJKEnd(szIJK); ___1842 const localMax = ___1850-___1878+1; ___1842 const localIJK = itemIJK-___1878; ___476(localIJK<=localMax); ___2088::ItemOffset_t const itemOffset = ___2088::ItemOffset_t(localMax.offsetAtIJK(localIJK)); ENSURE(itemOffset<localMax.blockSize()); return ___2088(m_partition,szOffset,itemOffset); } ___1842 subzoneIJKDim(___2088::SubzoneOffset_t ___3878) const { REQUIRE(validSubzone(___3878)); ___1842 szIJKStart, szIJKEnd; subzoneIJKStartAndEnd(___3878, szIJKStart, szIJKEnd); ___1842 const szIJKDim = szIJKEnd-szIJKStart+1; return szIJKDim; } ___2088::ItemOffset_t numItemsInSz(___2088::SubzoneOffset_t ___3878) const { REQUIRE(validSubzone(___3878)); return ___2088::ItemOffset_t(subzoneIJKDim(___3878).blockSize()); } ___2088 itemAddressAtItemIJK(___1842 const& itemIJK) const
{ REQUIRE(itemIJK<m_zoneIJKDim); ___1842 const szIJK = szIJKAtItemIJK(itemIJK); return itemAddressAtItemIJK(itemIJK, szIJK); } ___1842 itemIJKAtItemAddress(___2088 ___2087) const { REQUIRE(validItemAddress(___2087)); ___2088::SubzoneOffset_t const ___3878 = ___2087.subzoneOffset(); ___1842 ___1878, ___1850; subzoneIJKStartAndEnd(___3878, ___1878, ___1850); ___2088::ItemOffset_t const ___2863 = ___2087.itemOffset(); ___1842 const ijkRange = ___1850-___1878+1; ___1842 const ___1860 = ijkRange.ijkAtOffset(___2863); ___1842 const itemIJK = ___1878 + ___1860; ENSURE(itemIJK<m_zoneIJKDim); ENSURE(itemAddressAtItemIJK(itemIJK)==___2087); return itemIJK; } inline ___2088 itemAddressAtItemIndex(___81 itemIndex) const { REQUIRE(itemIndex<getNumItems()); ___1842 const itemIJK = itemIJKAtItemIndex(itemIndex); ___2088 const ___2087 = itemAddressAtItemIJK(itemIJK); return ___2087; } inline ___81 itemIndexAtItemAddress(___2088 ___2087) const { REQUIRE(validItemAddress(___2087)); ___1842 const itemIJK = itemIJKAtItemAddress(___2087); ___81 const itemIndex = itemIndexAtItemIJK(itemIJK); ENSURE(itemIndex<getNumItems()); ENSURE(itemAddressAtItemIndex(itemIndex)==___2087); return itemIndex; } inline ___81 itemIndexAtItemIJK(___1842 const& itemIJK) const { REQUIRE(itemIJK < m_zoneIJKDim); ___81 const itemIndex = m_zoneIJKDim.offsetAtIJK(itemIJK); ENSURE(itemIndex<getNumItems()); return itemIndex; } ___1842 itemIJKAtItemIndex(___81 itemIndex) const { REQUIRE(itemIndex<getNumItems()); ___1842 const itemIJK = m_zoneIJKDim.ijkAtOffset(itemIndex); ENSURE(itemIJK < m_zoneIJKDim); ENSURE(itemIndexAtItemIJK(itemIJK)==itemIndex); return itemIJK; } ___2088::SubzoneOffset_t subzoneOffsetAtItemIndex(___81 itemIndex) const { REQUIRE(itemIndex < getNumItems()); ___1842 const itemIJK = itemIJKAtItemIndex(itemIndex); ___1842 const szIJK = szIJKAtItemIJK(itemIJK); ___2088::SubzoneOffset_t const szOffset = static_cast<___2088::SubzoneOffset_t>(m_subzoneTilingIJKDim.offsetAtIJK(szIJK)); ENSURE(validSubzone(szOffset)); return szOffset; } ___372 getSubzonesOnIndexPlane( IJKPlanes_e                            whichPlane, ___81                             planeIndex, ___3267<___2088::SubzoneAddress>& szAddresses) const; ___372 getSubzonesOnIndexLine( IJKLines_e                             whichLine, ___81                             mIndex, ___81                             nIndex, ___3267<___2088::SubzoneAddress>& szAddresses) const; }; }}
