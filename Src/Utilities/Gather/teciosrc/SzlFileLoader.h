 #pragma once
#include "ThirdPartyHeadersBegin.h"
#include <algorithm>
#include <cfloat>
 #define _USE_MATH_DEFINES
#include <cmath> 
 #if defined MSWIN
 #define _CRTDBG_MAP_ALLOC
#include <crtdbg.h>
 #pragma warning (disable:4996) 
 #endif
#include <cstdarg>
#include <cstdlib>
#include <cstring>
#include <set>
#include <string>
#include <utility>
#include <vector>
#include "ThirdPartyHeadersEnd.h"
#include "MASTER.h"
#include "GLOBAL.h"
#include "ClassMacros.h"
#include "MinMax.h"
#include "basicTypes.h"
#include "IJK.h"
#include "ItemAddress.h"
#include "LightweightVector.h"
#include "AnyTypeLightweightVector.h"
#include "RawArray.h"
#include "showMessage.h"
#include "xyz.h"
namespace tecplot { namespace ___3931 { class CszConnectivity;
 #define MAX_ERROR_MESSAGE_SIZE 500
 #define countOf(staticArray) ( sizeof((staticArray))/sizeof((staticArray)[0]) )
 #define numItemsOf(someArray) ( sizeof((someArray))/sizeof(*(someArray)) )
static ___2088::ItemOffset_t const DEFAULT_SUBZONE_MAX_I_DIM = 6; static ___2088::ItemOffset_t const DEFAULT_SUBZONE_MAX_J_DIM = 6; static ___2088::ItemOffset_t const DEFAULT_SUBZONE_MAX_K_DIM = 6;
 #define DEFAULT_SUBZONE_MAX_IJK_DIM ___1842(DEFAULT_SUBZONE_MAX_I_DIM, DEFAULT_SUBZONE_MAX_J_DIM, DEFAULT_SUBZONE_MAX_K_DIM)
static ___2088::ItemOffset_t const DEFAULT_SUBZONE_MAX_FE_SIZE = 256; static bool const DEFAULT_MINIMIZE_IJK_NUM_SUBZONES = false; static bool const DEFAULT_MINIMIZE_SYNTHETIC_FE_NUM_SUBZONES = false; static ___4634 const NOT_SHARED = static_cast<___4634>(-1); typedef ___2238<___2088>                 ItemAddressArray; typedef ___2238<___2088::SubzoneAddress> SubzoneAddressArray; template<typename T> inline bool reserveVectorSpace(std::vector<T>& vectorToReserve, size_t newSize) { REQUIRE(newSize>0); bool ___2037 = false; try { vectorToReserve.reserve(newSize); ___2037 = true; } catch (...) { ___2037 = ___1303; } ENSURE(IMPLICATION(___2037, vectorToReserve.capacity()>=newSize)); return ___2037; } template<typename T> inline bool resizeVector(std::vector<T>& vectorToResize, size_t newSize) { REQUIRE(newSize>0); bool ___2037 = false; try { vectorToResize.resize(newSize); ___2037 = true; } catch (...) { ___2037 = ___1303; } ENSURE(IMPLICATION(___2037, vectorToResize.size()==newSize)); return ___2037; } template<typename T> inline bool resizeVector(std::vector<T>& vectorToSize, size_t newSize, T padValue) { REQUIRE(newSize>0); bool ___2037 = false; try { vectorToSize.resize(newSize, padValue); ___2037 = true; } catch (...) { ___2037 = ___1303; } ENSURE(IMPLICATION(___2037, vectorToSize.size()==newSize)); return ___2037; } template<typename T> inline bool resize2DVector(std::vector<std::vector<T> >& vector2D, size_t newDim1, size_t newDim2) { REQUIRE(newDim1>0); REQUIRE(newDim2>0); bool ___2037 = false; try { vector2D.resize(newDim1); for ( size_t ___1839 = 0; ___1839 < newDim1; ___1839++ ) vector2D[___1839].resize(newDim2); ___2037 = true; } catch (...) { ___2037 = ___1303; } ENSURE(IMPLICATION(___2037, vector2D.size()==newDim1)); ENSURE(IMPLICATION(___2037, vector2D[0].size()==newDim2)); ENSURE(IMPLICATION(___2037, vector2D[newDim1/2].size()==newDim2)); ENSURE(IMPLICATION(___2037, vector2D[newDim1-1].size()==newDim2)); return ___2037; } template<typename T> inline bool resize2DVector(std::vector<std::vector<T> >& vector2D, size_t newDim1, size_t newDim2, T padValue) { REQUIRE(newDim1>0); REQUIRE(newDim2>0); bool ___2037 = false; try { vector2D.resize(newDim1); for ( size_t ___1839 = 0; ___1839 < newDim1; ___1839++ ) vector2D[___1839].resize(newDim2, padValue); ___2037 = true; } catch (...) { ___2037 = ___1303; } ENSURE(IMPLICATION(___2037, vector2D.size()==newDim1)); ENSURE(IMPLICATION(___2037, vector2D[0].size()==newDim2)); ENSURE(IMPLICATION(___2037, vector2D[newDim1/2].size()==newDim2)); ENSURE(IMPLICATION(___2037, vector2D[newDim1-1].size()==newDim2)); return ___2037; } template<typename T> inline void clearAndDeallocStdSet(std::set<T>& setToClear) { std::set<T>().swap(setToClear); } template <class ForwardIterator> bool isSorted(ForwardIterator first, ForwardIterator last) { if ( first!=last ) { ForwardIterator next = first; while (++next!=last) { if (*next<*first) return false; ++first; } } return true; } typedef ___2238<char>     ___471; typedef ___2238<uint8_t>  UInt8Array; typedef ___2238<uint16_t> UInt16Array;
typedef ___2238<uint32_t> UInt32Array; typedef ___2238<uint64_t> UInt64Array; typedef ___2238<int32_t>  ___1963; typedef ___2238<double>   ___1103; typedef ___2238<float>    ___1433; typedef ___2238<___463>                  ___462; typedef ___2238<___2716>                  ___2715; typedef ___2238<___4634>                  ___4633; typedef ___2238<___2088::SubzoneOffset_t> SubzoneOffsetArray; typedef ___2238<___2088::ItemOffset_t>    ItemOffsetArray; typedef ___2238<___372>                    BooleanArray; typedef ___2238<std::string>                  ___3814; typedef ___2238<___2088::___2978>                       PartitionArray; typedef std::pair<___2088::___2978, ___2088::SubzoneOffset_t> PartitionSubzone; typedef ___2238<PartitionSubzone>                               PartitionSubzoneArray; typedef std::set<PartitionSubzone>                                        PartitionSubzoneSet; typedef ___2238<PartitionSubzoneSet>                            PartitionSubzoneSetArray; typedef std::set<___2088::SubzoneOffset_t> SubzoneOffsetSet; typedef ___2238<SubzoneOffsetSet>    SubzoneOffsetSetArray; typedef ___2238<UInt8Array>       VarZoneUInt8Array; typedef ___2238<___1391>        ___1390; typedef ___2238<___1390>     FileLoc2DArray; typedef ___2238<FileLoc2DArray>   FileLoc3DArray; typedef ___2238<FileLoc3DArray>   FileLoc4DArray;
 #if 0
typedef ___1390                             SzFileLocArray; typedef ___2238<SzFileLocArray>        PtnSzFileLocArray; typedef ___2238<PtnSzFileLocArray>     ZonePtnSzFileLocArray; typedef ___2238<ZonePtnSzFileLocArray> VarZonePtnSzFileLocArray; typedef ___1390                             PtnFileLocArray; typedef ___2238<PtnFileLocArray>       ZnPtnFileLocArray; typedef ___1390                             VarFileLocArray; typedef ___2238<VarFileLocArray>       PtnVarFileLocArray; typedef ___2238<PtnVarFileLocArray>    ZonePtnVarFileLocArray; typedef ___1390                             ZoneFileLocArray; typedef ___2238<ZoneFileLocArray>      VarZoneFileLocArray;
 #endif
typedef AnyTypeLightweightVector              FieldDataArray; typedef ___2238<FieldDataArray>     SzFieldData; typedef ___2238<SzFieldData>        PtnSzFieldData; typedef ___2238<PtnSzFieldData>     ZonePtnSzFieldData; typedef ___2238<ZonePtnSzFieldData> VarZonePtnSzFieldData; typedef uint16_t InterpCount_t; static InterpCount_t const MAX_INTERP_COUNT = InterpCount_t(-1); typedef ___2238<InterpCount_t>             InterpCountArray; typedef ___2238<InterpCountArray>          SzInterpCountArray; typedef ___2238<SzInterpCountArray>        PtnSzInterpCountArray; typedef ___2238<PtnSzInterpCountArray>     ZonePtnSzInterpCountArray; typedef ___2238<ZonePtnSzInterpCountArray> VarZonePtnSzInterpCountArray; typedef ___2238<BooleanArray>         PtnBooleanArray; typedef ___2238<PtnBooleanArray>      ZonePtnBooleanArray; typedef ___2238<ZonePtnBooleanArray>  VarZonePtnBooleanArray; typedef ___2238<uint8_t>                ValueLocationArray; typedef ___2238<ValueLocationArray>     ___4389; typedef ___2238<uint8_t>                FieldDataTypeArray; typedef ___2238<FieldDataTypeArray>     ___4380; typedef ___2238<uint8_t>        IsPassiveArray; typedef ___2238<IsPassiveArray> ___4383; typedef ___2238<___4633> ___4386; typedef ___2238<___1103> VarZoneDoubleArray; typedef ___2238<___2088::___2978> PartitionArray; struct ___230 { std::string ___2493; std::string ___2665; AuxDataLocation_e m_location; ___1170 m_entity; AuxDataType_e m_type; ___230() {} ___230( std::string const& ___2683, std::string const& ___4312, AuxDataLocation_e location, ___1170 entity, AuxDataType_e type) : ___2493(___2683) , ___2665(___4312) , m_location(location) , m_entity(entity) , m_type(type) {} }; struct ___1554 { double ___2615[3]; CoordSys_e ___2614; ___372 ___2482; ___1170 ___2675; ___514 ___2393; ___514 ___2460; ___372 ___2484; GeomType_e ___2464; LinePattern_e ___2487; double ___2613; double ___2488; uint16_t ___2500; ArrowheadStyle_e ___2341; ArrowheadAttachment_e ___2339; double ___2340; double ___2338; Scope_e ___2617; Clipping_e ___2392; std::vector<std::vector<class ___4578> > ___2462; std::string ___2489; ___1554() {} ___1554( double ___4572, double ___4589, double ___4713, CoordSys_e ___3157, ___372 ___2002, ___1170 zone, ___514 color, ___514 ___1409, ___372 ___2020, GeomType_e ___1649, LinePattern_e ___2261, double ___2984, double ___2287, uint16_t ___2791, ArrowheadStyle_e arrowheadStyle, ArrowheadAttachment_e arrowheadAttachment, double arrowheadSize, double arrowheadAngle, Scope_e ___3440, Clipping_e ___493, std::vector<std::vector<___4578> > const& ___1570,
std::string const& ___2328) : ___2614(___3157) , ___2482(___2002) , ___2675(zone) , ___2393(color) , ___2460(___1409) , ___2484(___2020) , ___2464(___1649) , ___2487(___2261) , ___2613(___2984) , ___2488(___2287) , ___2500(___2791) , ___2341(arrowheadStyle) , ___2339(arrowheadAttachment) , ___2340(arrowheadSize) , ___2338(arrowheadAngle) , ___2617(___3440) , ___2392(___493) , ___2462(___1570) , ___2489(___2328) { ___2615[0] = ___4572; ___2615[1] = ___4589; ___2615[2] = ___4713; } }; struct Text { ___514 ___2626; ___514 ___2627; double ___2628; double ___2629; TextBox_e ___2630; TextAnchor_e ___2623; double ___2624[3]; double ___2625; Clipping_e ___2631; ___514 ___2632; double ___2633; double ___2635; std::string ___2636; CoordSys_e ___2637; Scope_e ___2639; Units_e ___2640; std::string ___2641; std::string ___2642; ___372 ___2643; ___372 ___2644; ___1170 ___2645; ___372 ___2634; Text() {} Text( double ___4572, double ___4589, double ___4711, ___514 ___4057, ___514 ___4059, double ___4069, double ___4071, TextBox_e ___4076, TextAnchor_e ___4041, double ___4054, Clipping_e ___4077, ___514 ___4078, double ___4101, double ___4105, std::string ___4107, CoordSys_e ___4113, Scope_e ___4117, Units_e ___4122, std::string ___4124, std::string ___4127, ___372 ___4130, ___372 ___4132, ___1170 ___4136, ___372 ___4103) : ___2626(___4057) , ___2627(___4059) , ___2628(___4069) , ___2629(___4071) , ___2630(___4076) , ___2623(___4041) , ___2625(___4054) , ___2631(___4077) , ___2632(___4078) , ___2633(___4101) , ___2635(___4105) , ___2636(___4107) , ___2637(___4113) , ___2639(___4117) , ___2640(___4122) , ___2641(___4124) , ___2642(___4127) , ___2643(___4130) , ___2644(___4132) , ___2645(___4136) , ___2634(___4103) { ___2624[0] = ___4572; ___2624[1] = ___4589; ___2624[2] = ___4711; } }; struct CustomLabelSet { uint32_t m_numLabels; ___3814 m_labels; }; typedef ___2238<___230> AuxDataArray; typedef ___2238<___1554> GeomArray; typedef ___2238<Text> TextArray; typedef ___2238<CustomLabelSet> CustomLabelsArray;
typedef ___2238<RefSubzoneOffset_t> RefSubzoneOffsetArray; class NszConnectivity { UNCOPYABLE_CLASS(NszConnectivity); public: SubzoneAddressArray m_refCszs; RefSubzoneOffset_t   m_numRefCszs; NszConnectivity() : m_numRefCszs(0) { } ~NszConnectivity() { ___935(); } uint64_t numBytesAllocated(void) const { return m_refCszs.numBytesAllocated(m_numRefCszs); } void ___935() { m_numRefCszs = 0; m_refCszs.___935(); ENSURE(empty()); } bool setNumRszs(RefSubzoneOffset_t numRszs) { REQUIRE(___2065()); REQUIRE(numRszs != BAD_REFSZ_INDEX); bool ___2037; if ( numRszs == 0 ) { m_numRefCszs = numRszs; ___476(m_refCszs.empty()); ___2037 = true; } else { ___2037 = m_refCszs.alloc(numRszs); if ( ___2037 ) m_numRefCszs = numRszs; else ___935(); } ENSURE(___2065()); return ___2037; } inline bool ___2065() const { ___476(EQUIVALENCE(m_refCszs.empty(), m_numRefCszs == 0)); ___476(IMPLICATION(!m_refCszs.empty(), m_refCszs.size() == size_t(m_numRefCszs))); return true; } inline bool empty() const { REQUIRE(___2065()); return m_numRefCszs==0; } inline RefSubzoneOffset_t getNumRszs() const { REQUIRE(___2065()); return m_numRefCszs; } inline ___2088::SubzoneAddress getRszAddress(RefSubzoneOffset_t refSubzoneOffset) const { REQUIRE(___2065()); REQUIRE(refSubzoneOffset<getNumRszs()); return m_refCszs[refSubzoneOffset]; } inline bool getRszAddresses(___3267<___2088::SubzoneAddress>& rszAddresses) const { REQUIRE(___2065()); REQUIRE(rszAddresses.empty()); bool ___2037 = true; try { ___476(m_numRefCszs>0); rszAddresses.reserve(m_numRefCszs); rszAddresses.___3501(m_numRefCszs); memcpy(&rszAddresses[0], &m_refCszs[0], m_numRefCszs*sizeof(___2088::SubzoneAddress)); } catch (...) { ___2037 = ___1184("Out of memory in getRefCszAddresses"); } return ___2037; } }; typedef ___2238<CszConnectivity>           CszConnectivityArray; typedef ___2238<CszConnectivityArray>      PtnCszConnectivity; typedef ___2238<PtnCszConnectivity>        ZonePtnCszConnectivity; typedef ___2238<RefSubzoneOffsetArray>     PtnRefSubzoneOffsetArray; typedef ___2238<PtnRefSubzoneOffsetArray>  ZonePtnRefSubzoneOffsetArray; typedef ___2238<NszConnectivity>           NszConnectivityArray; typedef ___2238<NszConnectivityArray>      PtnNszConnectivity; typedef ___2238<PtnNszConnectivity>        ZonePtnNszConnectivity; typedef ___2238<ItemOffsetArray>           ZoneSzSizeArray; typedef ___2238<___463>               CellSubzoneFirstItemArray; typedef ___2238<CellSubzoneFirstItemArray> ZoneCszFirstItemArray; typedef ___2238<___2716>               NodeSubzoneFirstItemArray; typedef ___2238<NodeSubzoneFirstItemArray> ZoneNszFirstItemArray; typedef ___2238<___81>                AnySzFirstItemArray; typedef ___2238<AnySzFirstItemArray>       ZoneAnySzFirstItemArray; typedef ___2238<___2477>                 ___2479; typedef ___2238<___2479>            VarZoneMinMaxArray;
}}
