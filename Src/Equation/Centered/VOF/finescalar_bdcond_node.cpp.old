#include "finescalar.h"

/******************************************************************************/
void FineScalar::bdcond_node(const Scalar & sca) {
/***************************************************************************//**
*  \brief Boundary condition for a nodal variable.
*         scalar_exchange(_all) should take account of periodic condition.   
*           1st: scheme_f.bdcond_node();
*           2nd: scheme_f.exchange_all();
******************************************************************************/

  Formula form;

  for( int b=0; b<sca.bc().count(); b++ ) {

    if( sca.bc().type_decomp(b) ) continue;

    /*------------------------+ 
    |  dirichlet (and inlet)  |
    +------------------------*/
    if( sca.bc().type(b) == BndType::dirichlet() ||
        sca.bc().type(b) == BndType::inlet() ) {

      Dir d = sca.bc().direction(b);
      if(d != Dir::undefined()) {   
        int iof=1, jof=1, kof=1;
        if(d == Dir::imin() || d == Dir::imax()) iof=0;
        if(d == Dir::jmin() || d == Dir::jmax()) jof=0;
        if(d == Dir::kmin() || d == Dir::kmax()) kof=0;

        int iof2=0, jof2=0, kof2=0;
        if(d == Dir::imin()) iof2=1;
        if(d == Dir::jmin()) jof2=1;
        if(d == Dir::kmin()) kof2=1;


        /* formula is defined */
        if( sca.bc().formula(b) ) {
          for(int i=sca.bc().at(b).si(); i<=sca.bc().at(b).ei()+iof; i++){
          for(int j=sca.bc().at(b).sj(); j<=sca.bc().at(b).ej()+jof; j++){
          for(int k=sca.bc().at(b).sk(); k<=sca.bc().at(b).ek()+kof; k++){
            std::stringstream x, y, z, fs;
            x << "x=" << sca.xn(i); form.evaluate(x);
            y << "y=" << sca.yn(j); form.evaluate(y);
            z << "z=" << sca.zn(k); form.evaluate(z);
            fs << sca.bc().formula(b);
            nodeval[i][j][k] = form.evaluate(fs);
          }}}
        }
        /* formula is not defined */
        else {
          for(int i=sca.bc().at(b).si(); i<=sca.bc().at(b).ei()+iof; i++){
          for(int j=sca.bc().at(b).sj(); j<=sca.bc().at(b).ej()+jof; j++){
          for(int k=sca.bc().at(b).sk(); k<=sca.bc().at(b).ek()+kof; k++){
            nodeval[i+iof2][j+jof2][k+kof2] = sca.bc().value(b);
          }}}
        }
      }
    }

    /*---------+ 
    |  others  |
    +---------*/
    if( sca.bc().type(b) == BndType::neumann()
      ||sca.bc().type(b) == BndType::symmetry()
      ||sca.bc().type(b) == BndType::wall()
      ||sca.bc().type(b) == BndType::outlet() ) {

      Dir d = sca.bc().direction(b);
      if(d != Dir::undefined()) {
        int iof=1, jof=1, kof=1;
        if(d == Dir::imin() || d == Dir::imax()) iof=0;
        if(d == Dir::jmin() || d == Dir::jmax()) jof=0;
        if(d == Dir::kmin() || d == Dir::kmax()) kof=0;

        int iof2=0, jof2=0, kof2=0;
        if(d == Dir::imin()) iof2=1;
        if(d == Dir::jmin()) jof2=1;
        if(d == Dir::kmin()) kof2=1;

        for(int i=sca.bc().at(b).si(); i<=sca.bc().at(b).ei()+iof; i++){
        for(int j=sca.bc().at(b).sj(); j<=sca.bc().at(b).ej()+jof; j++){
        for(int k=sca.bc().at(b).sk(); k<=sca.bc().at(b).ek()+kof; k++){
         
          real valtmp = jof*kof*(

          valtmp /= 4.0;
          

          real ftmp =
                       jof*kof*0.25*(sca[i][j][k    ]+sca[i][j-jof][k    ]
                                    +sca[i][j][k-kof]+sca[i][j-jof][k-kof])
                      +iof*kof*0.25*(sca[i][j][k    ]+sca[i-iof][j][k    ]
                                    +sca[i][j][k-kof]+sca[i-iof][j][k-kof])
                      +iof*jof*0.25*(sca[i][j    ][k]+sca[i-iof][j    ][k]
                                    +sca[i][j-jof][k]+sca[i-iof][j-jof][k]);
          nodeval[i+iof2][j+jof2][k+kof2] = min(1.0,max(0.0,ftmp));
        }}}
      }
    }
  }

  // insert has the top priority. To overwrite the edge, call last.
  for( int b=0; b<sca.bc().count(); b++ ) {
    if( sca.bc().type_decomp(b) ) continue;
    /*---------+ 
    |  insert  |
    +---------*/
    if( sca.bc().type(b) == BndType::insert() ) {
    #if 1
      boil::oout<<"FineScalar::bdnode_insert_bc: Underdevelopment! Exiting..."<<boil::endl;
      exit(0);
    #else
      Dir d = sca.bc().direction(b);
      if(d != Dir::undefined()) {
        int iof=1, jof=1, kof=1;
        if(d == Dir::imin() || d == Dir::imax()) iof=0;
        if(d == Dir::jmin() || d == Dir::jmax()) jof=0;
        if(d == Dir::kmin() || d == Dir::kmax()) kof=0;

        int iof2=0, jof2=0, kof2=0;
        if(d == Dir::imin()) iof2=1;
        if(d == Dir::jmin()) jof2=1;
        if(d == Dir::kmin()) kof2=1;

        for(int i=sca.bc().at(b).si(); i<=sca.bc().at(b).ei()+iof; i++){
        for(int j=sca.bc().at(b).sj(); j<=sca.bc().at(b).ej()+jof; j++){
        for(int k=sca.bc().at(b).sk(); k<=sca.bc().at(b).ek()+kof; k++){
          real ftmp =
                       jof*kof*0.25*(sca[i][j][k    ]+sca[i][j-jof][k    ]
                                    +sca[i][j][k-kof]+sca[i][j-jof][k-kof])
                      +iof*kof*0.25*(sca[i][j][k    ]+sca[i-iof][j][k    ]
                                    +sca[i][j][k-kof]+sca[i-iof][j][k-kof])
                      +iof*jof*0.25*(sca[i][j    ][k]+sca[i-iof][j    ][k]
                                    +sca[i][j-jof][k]+sca[i-iof][j-jof][k]);
          nodeval[i+iof2][j+jof2][k+kof2] = min(1.0,max(0.0,ftmp));
        }}}
      }
    #endif
    }
  }
}


