diff: ../../../../../../Gitlab/Master/PSI-BOIL/Src/Equation/Centered/CIPCSL2/cipcsl2_adens.cpp: No such file or directory
diff: ../../../../../../Gitlab/Master/PSI-BOIL/Src/Equation/Centered/CIPCSL2/cipcsl2_fs_bnd_nosubgrid.cpp: No such file or directory
diff: ../../../../../../Gitlab/Master/PSI-BOIL/Src/Equation/Centered/CIPCSL2/cipcsl2_fs.cpp: No such file or directory


cipcsl2_adens.cpp
cipcsl2_advance.cpp
cipcsl2_ancillary.cpp
14,15c14,16
<   /*  calculate free surface position */
<   cal_fs();
---
>   /* calculate free surface position,
>      no subgrid interfaces near walls! */
>   topo->cal_fs_interp(phi,fs,0.0,false);
21,22c22,26
<   /* calculate area */
<   cal_adens();
---
>   /* calculate area density */
>   heavi->calculate_adens();
> 
>   /* flag the interface */
>   interfacial_flagging(phi);
cipcsl2_bdcond.cpp
62d61
< 
64,98c63,99
<         for(int cc=0; cc<dom->ibody().nccells(); cc++) {
<           int i,j,k;
<           dom->ibody().ijk(cc,&i,&j,&k); // OPR(i); OPR(j); OPR(k);
< 
<           if( dom->ibody().on(i,j,k) && dom->ibody().off(i-1,j,k) )
<            sca[i-1][j][k] = sca[i][j][k];
<           if( dom->ibody().on(i-1,j,k) && dom->ibody().off(i,j,k) )
<            sca[i][j][k] = sca[i-1][j][k];
< 
<           if( dom->ibody().on(i,j,k) && dom->ibody().off(i+1,j,k) )
<            sca[i+1][j][k] = sca[i][j][k];
<           if( dom->ibody().on(i+1,j,k) && dom->ibody().off(i,j,k) )
<            sca[i][j][k] = sca[i+1][j][k];
< 
< 
<           if( dom->ibody().on(i,j,k) && dom->ibody().off(i,j-1,k) )
<            sca[i][j-1][k] = sca[i][j][k];
<           if( dom->ibody().on(i,j-1,k) && dom->ibody().off(i,j,k) )
<            sca[i][j][k] = sca[i][j-1][k];
< 
<           if( dom->ibody().on(i,j,k) && dom->ibody().off(i,j+1,k) )
<            sca[i][j+1][k] = sca[i][j][k];
<           if( dom->ibody().on(i,j+1,k) && dom->ibody().off(i,j,k) )
<            sca[i][j][k] = sca[i][j+1][k];
< 
< 
<           if( dom->ibody().on(i,j,k) && dom->ibody().off(i,j,k-1) )
<            sca[i][j][k-1] = sca[i][j][k];
<           if( dom->ibody().on(i,j,k-1) && dom->ibody().off(i,j,k) )
<            sca[i][j][k] = sca[i][j][k-1];
< 
<           if( dom->ibody().on(i,j,k) && dom->ibody().off(i,j,k+1) )
<            sca[i][j][k+1] = sca[i][j][k];
<           if( dom->ibody().on(i,j,k+1) && dom->ibody().off(i,j,k) )
<            sca[i][j][k] = sca[i][j][k+1];
---
>         if( extrapolate_ib) {
>           for(int cc=0; cc<dom->ibody().nccells(); cc++) {
>             int i,j,k;
>             dom->ibody().ijk(cc,&i,&j,&k); // OPR(i); OPR(j); OPR(k);
> 
>             if( dom->ibody().on(i,j,k) && dom->ibody().off(i-1,j,k) )
>              sca[i-1][j][k] = sca[i][j][k];
>             if( dom->ibody().on(i-1,j,k) && dom->ibody().off(i,j,k) )
>              sca[i][j][k] = sca[i-1][j][k];
> 
>             if( dom->ibody().on(i,j,k) && dom->ibody().off(i+1,j,k) )
>              sca[i+1][j][k] = sca[i][j][k];
>             if( dom->ibody().on(i+1,j,k) && dom->ibody().off(i,j,k) )
>              sca[i][j][k] = sca[i+1][j][k];
> 
> 
>             if( dom->ibody().on(i,j,k) && dom->ibody().off(i,j-1,k) )
>              sca[i][j-1][k] = sca[i][j][k];
>             if( dom->ibody().on(i,j-1,k) && dom->ibody().off(i,j,k) )
>              sca[i][j][k] = sca[i][j-1][k];
> 
>             if( dom->ibody().on(i,j,k) && dom->ibody().off(i,j+1,k) )
>              sca[i][j+1][k] = sca[i][j][k];
>             if( dom->ibody().on(i,j+1,k) && dom->ibody().off(i,j,k) )
>              sca[i][j][k] = sca[i][j+1][k];
> 
> 
>             if( dom->ibody().on(i,j,k) && dom->ibody().off(i,j,k-1) )
>              sca[i][j][k-1] = sca[i][j][k];
>             if( dom->ibody().on(i,j,k-1) && dom->ibody().off(i,j,k) )
>              sca[i][j][k] = sca[i][j][k-1];
> 
>             if( dom->ibody().on(i,j,k) && dom->ibody().off(i,j,k+1) )
>              sca[i][j][k+1] = sca[i][j][k];
>             if( dom->ibody().on(i,j,k+1) && dom->ibody().off(i,j,k) )
>              sca[i][j][k] = sca[i][j][k+1];
>           }
100d100
< 
101a102
>       //if(d != Dir::undefined()) {
cipcsl2_bdcurv.cpp
cipcsl2_bdcurv_interface.cpp
248c248,250
<   
---
>  
>   if (weight1*k2 + weight2*k1==0.0) harmonic = false;
> 
cipcsl2_bdcurv_interface_ext.cpp
cipcsl2_bdphiface_check.cpp
cipcsl2_bdphiface.cpp
cipcsl2_bnd_extract.cpp
cipcsl2_bnd_insert.cpp
cipcsl2_bnd_wall_kappa.cpp
12a13,14
>   int i,j,k;
> 
cipcsl2_CIPCSLx1.cpp
18a19,24
>   /* EXTENDED BUFFERS HINT:
>      Lines 13-15 could probably be replaced with this:
>   for(int i=u->si(m)-1; i<=u->ei(m)+1; i++) {
>   for(int j=u->sj(m);   j<=u->ej(m)+1; j++) {
>   for(int k=u->sk(m);   k<=u->ek(m)+1; k++) {
>   */
22a29,33
>   /* EXTENDED BUFFERS HINT:
>      Lines 27-29 could probably be replaced with this:
>   for_aijk(i,j,k)
>     delrho[i][j][k]=0.0;
>   */
cipcsl2_CIPCSLx2.cpp
19,29c19,24
< 
< #if 0
<   if(dom->ibody().nccells() > 0) {
<     for(int i=0; i<=u->ni(m)-2; i++) {
<     for(int j=0; j<=u->nj(m)-1; j++) {
<     for(int k=1; k<=u->nk(m)-1; k++) {
<       cout<<i<<" "<<j<<" "<<k<<" "<<u->ni(m)-1<<"\n";
<       if(dom->ibody().off(mc, i, j, k)) vel[i][j][k]=0.0;
<     }}}
<   }
< #endif
---
>   /* EXTENDED BUFFERS HINT:
>      Lines 14-16 could probably be replaced with this:
>   for(int i=u->si(m)-1; i<=u->ei(m)+1; i++) {
>   for(int j=u->sj(m)-1; j<=u->ej(m)+1; j++) {
>   for(int k=u->sk(m);   k<=u->ek(m)+1; k++) {
>   */
33a29,33
>   /* EXTENDED BUFFERS HINT:
>      Lines 27-29 could probably be replaced with this:
>   for_aijk(i,j,k)
>     delrho[i][j][k]=0.0;
>   */
cipcsl2_CIPCSLx3.cpp
18a19,24
>   /* EXTENDED BUFFERS HINT:
>      Lines 14-16 could probably be replaced with this:
>   for(int i=u->si(m)-1; i<=u->ei(m)+1; i++) {
>   for(int j=u->sj(m);   j<=u->ej(m)+1; j++) {
>   for(int k=u->sk(m)-1; k<=u->ek(m)+1; k++) {
>   */
22a29,33
>   /* EXTENDED BUFFERS HINT:
>      Lines 27-29 could probably be replaced with this:
>   for_aijk(i,j,k)
>     delrho[i][j][k]=0.0;
>   */
cipcsl2_CIPCSLx4.cpp
17a18,23
>   /* EXTENDED BUFFERS HINT:
>      Lines 13-15 could probably be replaced with this:
>   for(int i=u->si(m)-1; i<=u->ei(m)+1; i++) {
>   for(int j=u->sj(m)-1; j<=u->ej(m)+1; j++) {
>   for(int k=u->sk(m)-1; k<=u->ek(m)+1; k++) {
>   */
21a28,32
>   /* EXTENDED BUFFERS HINT:
>      Lines 26-28 could probably be replaced with this:
>   for_aijk(i,j,k)
>     delrho[i][j][k]=0.0;
>   */
cipcsl2_CIPCSLy1.cpp
18a19,24
>   /* EXTENDED BUFFERS HINT:
>      Lines 13-15 could probably be replaced with this:
>   for(int i=u->si(m);   i<=u->ei(m)+1; i++) {
>   for(int j=u->sj(m)-1; j<=u->ej(m)+1; j++) {
>   for(int k=u->sk(m);   k<=u->ek(m)+1; k++) {
>   */
22a29,33
>   /* EXTENDED BUFFERS HINT:
>      Lines 27-29 could probably be replaced with this:
>   for_aijk(i,j,k)
>     delrho[i][j][k]=0.0;
>   */
cipcsl2_CIPCSLy2.cpp
18a19,24
>   /* EXTENDED BUFFERS HINT:
>      Lines 14-16 could probably be replaced with this:
>   for(int i=u->si(m)-1; i<=u->ei(m)+1; i++) {
>   for(int j=u->sj(m)-1; j<=u->ej(m)+1; j++) {
>   for(int k=u->sk(m);   k<=u->ek(m)+1; k++) {
>   */
22a29,33
>   /* EXTENDED BUFFERS HINT:
>      Lines 27-29 could probably be replaced with this:
>   for_aijk(i,j,k)
>     delrho[i][j][k]=0.0;
>   */
cipcsl2_CIPCSLy3.cpp
18a19,24
>   /* EXTENDED BUFFERS HINT:
>      Lines 14-16 could probably be replaced with this:
>   for(int i=u->si(m);   i<=u->ei(m)+1; i++) {
>   for(int j=u->sj(m)-1; j<=u->ej(m)+1; j++) {
>   for(int k=u->sk(m)-1; k<=u->ek(m)+1; k++) {
>   */
22a29,33
>   /* EXTENDED BUFFERS HINT:
>      Lines 27-29 could probably be replaced with this:
>   for_aijk(i,j,k)
>     delrho[i][j][k]=0.0;
>   */
cipcsl2_CIPCSLy4.cpp
17a18,23
>   /* EXTENDED BUFFERS HINT:
>      Lines 13-15 could probably be replaced with this:
>   for(int i=u->si(m)-1; i<=u->ei(m)+1; i++) {
>   for(int j=u->sj(m)-1; j<=u->ej(m)+1; j++) {
>   for(int k=u->sk(m)-1; k<=u->ek(m)+1; k++) {
>   */
21a28,32
>   /* EXTENDED BUFFERS HINT:
>      Lines 26-28 could probably be replaced with this:
>   for_aijk(i,j,k)
>     delrho[i][j][k]=0.0;
>   */
cipcsl2_CIPCSLz1.cpp
18a19,24
>   /* EXTENDED BUFFERS HINT:
>      Lines 13-15 could probably be replaced with this:
>   for(int i=u->si(m);   i<=u->ei(m)+1; i++) {
>   for(int j=u->sj(m);   j<=u->ej(m)+1; j++) {
>   for(int k=u->sk(m)-1; k<=u->ek(m)+1; k++) {
>   */
22a29,33
>   /* EXTENDED BUFFERS HINT:
>      Lines 27-29 could probably be replaced with this:
>   for_aijk(i,j,k)
>     delrho[i][j][k]=0.0;
>   */
cipcsl2_CIPCSLz2.cpp
18a19,24
>   /* EXTENDED BUFFERS HINT:
>      Lines 14-16 could probably be replaced with this:
>   for(int i=u->si(m)-1; i<=u->ei(m)+1; i++) {
>   for(int j=u->sj(m);   j<=u->ej(m)+1; j++) {
>   for(int k=u->sk(m)-1; k<=u->ek(m)+1; k++) {
>   */
22a29,33
>   /* EXTENDED BUFFERS HINT:
>      Lines 27-29 could probably be replaced with this:
>   for_aijk(i,j,k)
>     delrho[i][j][k]=0.0;
>   */
cipcsl2_CIPCSLz3.cpp
18a19,24
>   /* EXTENDED BUFFERS HINT:
>      Lines 14-16 could probably be replaced with this:
>   for(int i=u->si(m);   i<=u->ei(m)+1; i++) {
>   for(int j=u->sj(m)-1; j<=u->ej(m)+1; j++) {
>   for(int k=u->sk(m)-1; k<=u->ek(m)+1; k++) {
>   */
22a29,33
>   /* EXTENDED BUFFERS HINT:
>      Lines 27-29 could probably be replaced with this:
>   for_aijk(i,j,k)
>     delrho[i][j][k]=0.0;
>   */
cipcsl2_CIPCSLz4.cpp
17a18,23
>   /* EXTENDED BUFFERS HINT:
>      Lines 13-15 could probably be replaced with this:
>   for(int i=u->si(m)-1; i<=u->ei(m)+1; i++) {
>   for(int j=u->sj(m)-1; j<=u->ej(m)+1; j++) {
>   for(int k=u->sk(m)-1; k<=u->ek(m)+1; k++) {
>   */
21a28,32
>   /* EXTENDED BUFFERS HINT:
>      Lines 26-28 could probably be replaced with this:
>   for_aijk(i,j,k)
>     delrho[i][j][k]=0.0;
>   */
cipcsl2_color_minmax.cpp
cipcsl2_convection.cpp
cipcsl2.cpp
11c11
<                  Krylov * S) :
---
>                  Linear * S) :
25a26
>   intflag( *PHI.domain() ),
33,35c34,36
<   kappa ( &K ),
<   heavi(&phi, NULL, &adens),
<   topo(&nx,&ny,&nz,&adens,&fs)
---
>   kappa ( &K )
>   //heavi(&phi, NULL, &adens),
>   //topo(&phi,&phi,&nx,&ny,&nz,&adens,&fs,&intflag)
49a51
>   intflag = phi.shape();
63d64
<   pi = acos(-1.0);
70a72,75
>   /* runtime polymorphism */
>   heavi = new MarchingCubes(&phi,NULL,&adens);
>   topo = new Topology(&phi,&phi,&nx,&ny,&nz,&adens,&fs,&intflag,phisurf);
> 
78c83
<   cangle=90.0/180.0*pi;
---
>   cangle=90.0/180.0*boil::pi;
85a91
>   extrapolate_ib=true;
98a105,107
> 
>   /* set in init() */
>   is_initialized = false;
cipcsl2_curvature.cpp
cipcsl2_curv.cpp
cipcsl2_curv_interface.cpp
cipcsl2_curv_interface_ext.cpp
cipcsl2_distfunc.cpp
cipcsl2_ext_sca.cpp
54a55,56
>   const real dtau = dxmin;
>   real flux,isgn;
cipcsl2_front_minmax.cpp
22a23
>   bool frontExist=false;
40a42
>            frontExist=true;
71a74
>            frontExist=true;
102a106
>            frontExist=true;
cipcsl2_fs_bnd_nosubgrid.cpp
cipcsl2_fs.cpp
cipcsl2_funclxyz.cpp
cipcsl2_gradphic.cpp
12c12
<     if(fabs(iflag[i][j][k])>real(nlayer-4)){
---
>     if(abs(iflag[i][j][k])>real(nlayer-4)){
97c97
<     if(fabs(iflag[i][j][k])>real(nlayer-4)){
---
>     if(abs(iflag[i][j][k])>real(nlayer-4)){
cipcsl2_gradphi.cpp
10c10
<   real nni,nnj,nnk;
---
>   real ni,nj,nk,magn;
40,46c40,46
<         nni = nx[i][j][k];
<         nnj = ny[i][j][k];
<         nnk = nz[i][j][k];
<         normalize(nni,nnj,nnk);
<         nx[i][j][k] = nni;
<         ny[i][j][k] = nnj;
<         nz[i][j][k] = nnk;
---
>         ni = nx[i][j][k];
>         nj = ny[i][j][k];
>         nk = nz[i][j][k];
>         normalize(ni,nj,nk);
>         nx[i][j][k] = ni;
>         ny[i][j][k] = nj;
>         nz[i][j][k] = nk;
cipcsl2_ib_bdcond.cpp
12c12
<   /* cell to face */
---
>   if(!extrapolate_ib) return;
13a14
>   /* cell to face */
106a108
>     real area;
215d216
< 
cipcsl2_ib_ext_scalar.cpp
11a12
>   if(!extrapolate_ib) return;
90d90
< 
cipcsl2_ib_norm.cpp
cipcsl2_ib_set_iflag.cpp
cipcsl2_init.cpp
11a12,17
> #if 0
>   std::cout<<"cipcsl2_init0: "<<phi[18][3][10]<<" "<<clr[18][3][10]<<"\n";
> #endif
> 
>   is_initialized = true;
> 
37a44,46
> #if 0
>   std::cout<<"cipcsl2_init1: "<<phi[18][3][10]<<" "<<clr[18][3][10]<<"\n";
> #endif
43a53,55
> #if 0
>   std::cout<<"cipcsl2_init2: "<<phi[18][3][10]<<" "<<clr[18][3][10]<<"\n";
> #endif
49a62,64
> #if 0
>   std::cout<<"cipcsl2_init3: "<<phi[18][3][10]<<" "<<clr[18][3][10]<<"\n";
> #endif
125a141,143
> #if 0
>   std::cout<<"cipcsl2_init4: "<<phi[18][3][10]<<" "<<clr[18][3][10]<<"\n";
> #endif
133a152,154
> #if 0
>   std::cout<<"cipcsl2_init5: "<<phi[18][3][10]<<" "<<clr[18][3][10]<<"\n";
> #endif
154a176,184
> #if 0
>   std::cout<<"cipcsl2_init6: "<<phi[18][3][10]<<" "<<clr[18][3][10]<<"\n";
> #endif
>   ancillary();
> 
>   topo->new_time_step(); 
> #if 0
>   std::cout<<"cipcsl2_init7: "<<phi[18][3][10]<<" "<<clr[18][3][10]<<"\n";
> #endif
cipcsl2_insert_bc_alp.cpp
12a13,14
>   //int i,j,k;
> 
19a22
>       ||val.bc().type(b) == BndType::pseudo()
47,49c50,55
<       }
<     }
<   }
---
> 
>       } /* dir not undefined */
>     } /* bc type */
>   } /* bc count */
> 
>   return;
cipcsl2_insert_bc_dist.cpp
12a13,14
>   int i,j,k;
> 
44,53d45
<         if(d == Dir::imin() || d == Dir::imax()){
<           ist=ied=val.bc().at(b).si();
<         }
<         if(d == Dir::jmin() || d == Dir::jmax()){
<           jst=jed=val.bc().at(b).sj();
<         }
<         if(d == Dir::kmin() || d == Dir::kmax()){
<           kst=ked=val.bc().at(b).sk();
<         }
<         //if(ist==si()-1 || jst==sj()-1 || kst ==sk()-1) continue;
55,60c47,68
<         for(int i=ist; i<=ied; i++){
<         for(int j=jst; j<=jed; j++){
<         for(int k=kst; k<=ked; k++){
<           val[i][j][k]=val[i+iof][j+jof][k+kof];
<           //do not use extrapolation. it causes trouble in bdcurv!
<         } } }
---
>         if (val.bc().at(b).si()>val.bc().at(b).ei() ||
>             val.bc().at(b).sj()>val.bc().at(b).ej() ||
>             val.bc().at(b).sk()>val.bc().at(b).ek()) {
>         } else {
>           if(d == Dir::imin() || d == Dir::imax()){
>             ist=ied=val.bc().at(b).si();
>           }
>           if(d == Dir::jmin() || d == Dir::jmax()){
>             jst=jed=val.bc().at(b).sj();
>           }
>           if(d == Dir::kmin() || d == Dir::kmax()){
>             kst=ked=val.bc().at(b).sk();
>           }
>           //if(ist==si()-1 || jst==sj()-1 || kst ==sk()-1) continue;
> 
>           for(int i=ist; i<=ied; i++){
>           for(int j=jst; j<=jed; j++){
>           for(int k=kst; k<=ked; k++){
>             val[i][j][k]=val[i+iof][j+jof][k+kof];
>             //do not use extrapolation. it causes trouble in bdcurv!
>           } } }
>         }
cipcsl2_insert_bc_flag.cpp
9a10,11
>   int i,j,k;
> 
cipcsl2_insert_bc_gradphic.cpp
9a10,11
>   int i,j,k;
> 
cipcsl2_insert_bc_gradphi.cpp
15a16,17
>       int iof=0, jof=0, kof=0;
> 
cipcsl2_insert_bc_kappa.cpp
cipcsl2_insert_bc_norm.cpp
10a11,12
>   int i,j,k;
> 
cipcsl2_load.cpp
4c4
< void CIPCSL2::load(char * nm, const int it) {
---
> void CIPCSL2::load(const char * nm, const int it) {
6c6
< *  \brief Save variables of CIPCSL
---
> *  \brief Load variables of CIPCSL2
cipcsl2_normalize.cpp
cipcsl2_plotTEC.cpp
16a17,22
>   /* EXTENDED BUFFERS HINT:
>      Line 12 should probably be replaced with this:
>   fout<<"ZONE I="<<dom->ei()-dom->si()+1 <<", 
>               J="<<dom->ej()-dom->sj()+1 <<", 
>               K="<<dom->ek()-dom->sk()+1<<"\n";
>   */
43a50,55
>     /* EXTENDED BUFFERS HINT:
>        Lines 47-49 should probably be replaced with this:
>     for(int k=sk(); k<=dom->ek()+1; k++)
>       for(int j=sj(); j<=dom->ej()+1; j++)
>         for(int i=si(); i<=dom->ei()+1; i++) {
>     */
59a72,77
>   /* EXTENDED BUFFERS HINT:
>      Line 71 should probably be replaced with this:
>   fout<<"ZONE I="<<dom->ei()-dom->si()   <<", 
>               J="<<dom->ej()-dom->sj()+1 <<", 
>               K="<<dom->ek()-dom->sk()+1<<"\n";
>   */
77a96,101
>     /* EXTENDED BUFFERS HINT:
>        Lines 86-88 should probably be replaced with this:
>     for(int k=sk(); k<=dom->ek()+1; k++)
>       for(int j=sj(); j<=dom->ej()+1; j++)
>         for(int i=si(); i<=dom->ei(); i++) {
>     */
87a112,117
>     /* EXTENDED BUFFERS HINT:
>        Lines 106-108 should probably be replaced with this:
>     for(int k=sk(); k<=dom->ek()+1; k++)
>       for(int j=sj(); j<=dom->ej()+1; j++)
>         for(int i=si(); i<=dom->ei(); i++) {
>     */
104a135,140
>   /* EXTENDED BUFFERS HINT:
>      Line 132 should probably be replaced with this:
>   fout<<"ZONE I="<<dom->ei()-dom->si()+1 <<", 
>               J="<<dom->ej()-dom->sj()   <<", 
>               K="<<dom->ek()-dom->sk()+1<<"\n";
>   */
122a159,164
>     /* EXTENDED BUFFERS HINT:
>        Lines 150-152 should probably be replaced with this:
>     for(int k=sk(); k<=dom->ek()+1; k++)
>       for(int j=sj(); j<=dom->ej()  ; j++)
>         for(int i=si(); i<=dom->ei()+1; i++) {
>     */
132a175,180
>     /* EXTENDED BUFFERS HINT:
>        Lines 167-169 should probably be replaced with this:
>     for(int k=sk(); k<=dom->ek()+1; k++)
>       for(int j=sj(); j<=dom->ej()  ; j++)
>         for(int i=si(); i<=dom->ei()+1; i++) {
>     */
148a197,202
>   /* EXTENDED BUFFERS HINT:
>      Line 192 should probably be replaced with this:
>   fout<<"ZONE I="<<dom->ei()-dom->si()+1 <<", 
>               J="<<dom->ej()-dom->sj()+1 <<", 
>               K="<<dom->ek()-dom->sk()  <<"\n";
>   */
166a221,226
>     /* EXTENDED BUFFERS HINT:
>        Lines 207-209 should probably be replaced with this:
>     for(int k=sk(); k<=dom->ek();   k++)
>       for(int j=sj(); j<=dom->ej()+1; j++)
>         for(int i=si(); i<=dom->ei()+1; i++) {
>     */
176a237,242
>     /* EXTENDED BUFFERS HINT:
>        Lines 227-229 should probably be replaced with this:
>     for(int k=sk(); k<=dom->ek();   k++)
>       for(int j=sj(); j<=dom->ej()+1; j++)
>         for(int i=si(); i<=dom->ei()+1; i++) {
>     */
191a258,266
>   /* EXTENDED BUFFERS HINT:
>      Lines 249-255 should probably be replaced with this:
>   if(mc==Comp::i()){
>     ir=2*boil::BW-1; jr=2*boil::BW;   kr=2*boil::BW;
>   } else if(mc==Comp::j()){
>     ir=2*boil::BW;   jr=2*boil::BW-1; kr=2*boil::BW;
>   } else if(mc==Comp::k()){
>     ir=2*boil::BW;   jr=2*boil::BW;   kr=2*boil::BW-1;
>   */
222a298,301
>     /* EXTENDED BUFFERS HINT:
>        Lines 281-283 should probably be replaced with this:
>     for_mijk(mc,i,j,k)
>     */
cipcsl2_redist.cpp
cipcsl2_rm.cpp
4c4
< void CIPCSL2::rm(char * nm, const int it) {
---
> void CIPCSL2::rm(const char * nm, const int it) {
6c6
< *  \brief Save variables of CIPCSL
---
> *  \brief Rm variables of CIPCSL2
cipcsl2_save.cpp
4c4
< void CIPCSL2::save(char * nm, const int it) {
---
> void CIPCSL2::save(const char * nm, const int it) {
6c6
< *  \brief Save variables of CIPCSL
---
> *  \brief Save variables of CIPCSL2
cipcsl2_set_alp.cpp
338c338
<         flux=-isgn*nx[i][j][k]*dSx(i,j,k);
---
>         flux=-isgn*nx[i][j][k]*dSx(Sign::neg(),i,j,k);
341c341
<         flux= isgn*nx[i][j][k]*dSx(i,j,k);
---
>         flux= isgn*nx[i][j][k]*dSx(Sign::pos(),i,j,k);
344c344
<         flux=-isgn*ny[i][j][k]*dSy(i,j,k);
---
>         flux=-isgn*ny[i][j][k]*dSy(Sign::neg(),i,j,k);
347c347
<         flux= isgn*ny[i][j][k]*dSy(i,j,k);
---
>         flux= isgn*ny[i][j][k]*dSy(Sign::pos(),i,j,k);
350c350
<         flux= -isgn*nz[i][j][k]*dSz(i,j,k);
---
>         flux=-isgn*nz[i][j][k]*dSz(Sign::neg(),i,j,k);
353c353
<         flux= isgn*nz[i][j][k]*dSz(i,j,k);
---
>         flux= isgn*nz[i][j][k]*dSz(Sign::pos(),i,j,k);
377c377
<           flux= -isgn*nx[i][j][k]*dSx(i,j,k);
---
>           flux=-isgn*nx[i][j][k]*dSx(Sign::neg(),i,j,k);
381c381
<           flux= isgn*nx[i][j][k]*dSx(i,j,k);
---
>           flux= isgn*nx[i][j][k]*dSx(Sign::pos(),i,j,k);
385c385
<           flux=-isgn*ny[i][j][k]*dSy(i,j,k);
---
>           flux=-isgn*ny[i][j][k]*dSy(Sign::neg(),i,j,k);
389c389
<           flux= isgn*ny[i][j][k]*dSy(i,j,k);
---
>           flux= isgn*ny[i][j][k]*dSy(Sign::pos(),i,j,k);
393c393
<           flux=-isgn*nz[i][j][k]*dSz(i,j,k);
---
>           flux=-isgn*nz[i][j][k]*dSz(Sign::neg(),i,j,k);
397c397
<           flux= isgn*nz[i][j][k]*dSz(i,j,k);
---
>           flux= isgn*nz[i][j][k]*dSz(Sign::pos(),i,j,k);
cipcsl2_set_iflag.cpp
37a38,48
>   /* EXTENDED BUFFERS HINT:
>    all lines with: 
>      for(int i=0; i<ni()-1; i++) or ...
>      for(int j=0; i<nj()-1; i++) or ...
>      for(int k=0; i<nk()-1; i++)
>    could probably be replaced with:
>      for(int i=si()-1; i<ei()+1; i++) and ...
>      for(int j=sj()-1; i<ej()+1; i++) and ...
>      for(int k=sk()-1; i<ek()+1; i++)
>   */
> 
cipcsl2_set_wflag2.cpp
36a37
>       int iof=0, jof=0, kof=0;
cipcsl2_set_wflag.cpp
cipcsl2_sharpen.cpp
18d17
< #ifdef DEBUG
22a22,23
> 
> #ifdef DEBUG
119c120
<           fluxc = 0.5 * (tm+tc) * dSx(i,j,k);
---
>           fluxc = 0.5 * (tm+tc) * dSx(Sign::neg(),i,j,k);
124c125
<           fluxd = (sca[i][j][k]-sca[i-1][j][k])*dSx(i,j,k)/sca.dxw(i);
---
>           fluxd = (sca[i][j][k]-sca[i-1][j][k])*dSx(Sign::neg(),i,j,k)/sca.dxw(i);
161c162
<           fluxc = 0.5 * (tm+tc) * dSy(i,j,k);
---
>           fluxc = 0.5 * (tm+tc) * dSy(Sign::neg(),i,j,k);
166c167
<           fluxd = (sca[i][j][k]-sca[i][j-1][k])*dSy(i,j,k)/sca.dys(j);
---
>           fluxd = (sca[i][j][k]-sca[i][j-1][k])*dSy(Sign::neg(),i,j,k)/sca.dys(j);
199c200
<           fluxc = 0.5 * (tm+tc) * dSz(i,j,k);
---
>           fluxc = 0.5 * (tm+tc) * dSz(Sign::neg(),i,j,k);
204c205
<           fluxd = (sca[i][j][k]-sca[i][j][k-1])*dSz(i,j,k)/sca.dzb(k);
---
>           fluxd = (sca[i][j][k]-sca[i][j][k-1])*dSz(Sign::neg(),i,j,k)/sca.dzb(k);
228c229
<     //int imx,jmx,kmx;
---
>     int imx,jmx,kmx;
235,237c236,238
<         //imx=i;
<         //jmx=j;
<         //kmx=k;
---
>         imx=i;
>         jmx=j;
>         kmx=k;
cipcsl2_smear.cpp
13a14
>   real dsca_max=0.0;  // l_infinity for iterative cal.
72c73
<           fluxd = epss * (sca[i][j][k]-sca[i-1][j][k])*dSx(i,j,k)/sca.dxw(i);
---
>           fluxd = epss * (sca[i][j][k]-sca[i-1][j][k])*dSx(Sign::neg(),i,j,k)/sca.dxw(i);
95c96
<           fluxd = epss * (sca[i][j][k]-sca[i][j-1][k])*dSy(i,j,k)/sca.dys(j);
---
>           fluxd = epss * (sca[i][j][k]-sca[i][j-1][k])*dSy(Sign::neg(),i,j,k)/sca.dys(j);
118c119
<           fluxd = epss * (sca[i][j][k]-sca[i][j][k-1])*dSz(i,j,k)/sca.dzb(k);
---
>           fluxd = epss * (sca[i][j][k]-sca[i][j][k-1])*dSz(Sign::neg(),i,j,k)/sca.dzb(k);
cipcsl2_smooth.cpp
cipcsl2_tension.cpp
56c56
<                      + 1.0/(2.0*pi)*sin(pi*dist[i][j][k]/eps);
---
>                      + 1.0/(2.0*boil::pi)*sin(boil::pi*dist[i][j][k]/eps);
cipcsl2_totalvol.cpp
cipcsl2_update_at_walls.cpp
414d413
< 
430d428
< 
438d435
< 
446d442
< 
454d449
< 
466c461
<       ofy = -1;
---
>       ofz = -1;
cipcsl2_update_node.cpp
122a123,125
>   /* ancillary functions */
>   ancillary();
> 
cipcsl2_wall_norm.cpp
scheme_bdcond.cpp
