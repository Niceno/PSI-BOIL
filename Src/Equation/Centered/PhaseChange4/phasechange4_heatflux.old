#include "phasechange4.h"

/******************************************************************************/
void PhaseChange4::heat_flux(const Scalar * diff_eddy) {
/***************************************************************************//**
*  \brief Calculate heat flux in cells.
*******************************************************************************/

  /* these are heat flux */
  txl = tyl = tzl = 0.;
  txv = tyv = tzv = 0.;
  tnl = tnv = 0.;

  /* calculate temperature at solid-fluid boundaries */
  if(solid())
    calculate_node_temperature(diff_eddy);

  /* calculate heat flux */
  cal_hf(diff_eddy);

  txl.bnd_update();
  tyl.bnd_update();
  tzl.bnd_update();
  txv.bnd_update();
  tyv.bnd_update();
  tzv.bnd_update();

  /* insert special boundary conditions */
  insert_bc_hf(diff_eddy);

  txl.exchange_all();
  tyl.exchange_all();
  tzl.exchange_all();
  txv.exchange_all();
  tyv.exchange_all();
  tzv.exchange_all();

#if 0
  boil::plot->plot(clr,txv,tyv,tzv,"clr-txv-tyv-tzv",time->current_step());
  boil::plot->plot(clr,txl,tyl,tzl,"clr-txl-tyl-tzl",time->current_step());
  exit(0);
#endif

#if 0
  for_avijk(phi,i,j,k) {
    if(!interface(i,j,k)) {
      nx[i][j][k] = 0.0;
      ny[i][j][k] = 0.0;
      nz[i][j][k] = 0.0;
    }
  }

  /* extrapolate n */
  tnv  = nx;
  tnl  = 0.;
  for_avijk(phi,i,j,k) {
    tempflag[i][j][k] = interface(i,j,k);
  }

  //if(false) {
  for(int iloop=1; iloop<3; iloop++) { /* 2019.07.09 */
    for_ijk(i,j,k) {
      if(tempflag[i][j][k]==0) {
        /* at this point, the near-wall tempflag must be properly 0 or 1 */
        int inb = std::min(1,tempflag[i-1][j][k]) + std::min(1,tempflag[i+1][j][k])
                + std::min(1,tempflag[i][j-1][k]) + std::min(1,tempflag[i][j+1][k])
                + std::min(1,tempflag[i][j][k-1]) + std::min(1,tempflag[i][j][k+1]);
        if(inb >= 1) {
          tnv[i][j][k] = (real(std::min(1,tempflag[i-1][j][k])) * nx[i-1][j][k]
                        +  real(std::min(1,tempflag[i+1][j][k])) * nx[i+1][j][k]
                        +  real(std::min(1,tempflag[i][j-1][k])) * nx[i][j-1][k]
                        +  real(std::min(1,tempflag[i][j+1][k])) * nx[i][j+1][k]
                        +  real(std::min(1,tempflag[i][j][k-1])) * nx[i][j][k-1]
                        +  real(std::min(1,tempflag[i][j][k+1])) * nx[i][j][k+1])
                        /real(inb);
          tnl[i][j][k] = 2;  /* tempflag=2 for extrapolated */
        }
      }
    }
    tnv.bnd_update_symmetry(); /* copy on symmetry plane */
    tnl.bnd_update_symmetry(); /* copy on symmetry plane */
    tnv.exchange();
    tnl.exchange();
    nx = tnv;
    for_avijk(phi,i,j,k) {
      tempflag[i][j][k] = int(tnl[i][j][k]);
    }
  }

  tnv  = ny;
  tnl  = 0.;
  for_avijk(phi,i,j,k) {
    tempflag[i][j][k] = interface(i,j,k);
  }

  //if(false) {
  for(int iloop=1; iloop<3; iloop++) { /* 2019.07.09 */
    for_ijk(i,j,k) {
      if(tempflag[i][j][k]==0) {
        /* at this point, the near-wall tempflag must be properly 0 or 1 */
        int inb = std::min(1,tempflag[i-1][j][k]) + std::min(1,tempflag[i+1][j][k])
                + std::min(1,tempflag[i][j-1][k]) + std::min(1,tempflag[i][j+1][k])
                + std::min(1,tempflag[i][j][k-1]) + std::min(1,tempflag[i][j][k+1]);
        if(inb >= 1) {
          tnv[i][j][k] = (real(std::min(1,tempflag[i-1][j][k])) * ny[i-1][j][k]
                        +  real(std::min(1,tempflag[i+1][j][k])) * ny[i+1][j][k]
                        +  real(std::min(1,tempflag[i][j-1][k])) * ny[i][j-1][k]
                        +  real(std::min(1,tempflag[i][j+1][k])) * ny[i][j+1][k]
                        +  real(std::min(1,tempflag[i][j][k-1])) * ny[i][j][k-1]
                        +  real(std::min(1,tempflag[i][j][k+1])) * ny[i][j][k+1])
                        /real(inb);
          tnl[i][j][k] = 2;  /* tempflag=2 for extrapolated */
        }
      }
    }
    tnv.bnd_update_symmetry(); /* copy on symmetry plane */
    tnl.bnd_update_symmetry(); /* copy on symmetry plane */
    tnv.exchange();
    tnl.exchange();
    ny = tnv;
    for_avijk(phi,i,j,k) {
      tempflag[i][j][k] = int(tnl[i][j][k]);
    }
  }

  tnv  = nz;
  tnl  = 0.;
  for_avijk(phi,i,j,k) {
    tempflag[i][j][k] = interface(i,j,k);
  }

  //if(false) {
  for(int iloop=1; iloop<3; iloop++) { /* 2019.07.09 */
    for_ijk(i,j,k) {
      if(tempflag[i][j][k]==0) {
        /* at this point, the near-wall tempflag must be properly 0 or 1 */
        int inb = std::min(1,tempflag[i-1][j][k]) + std::min(1,tempflag[i+1][j][k])
                + std::min(1,tempflag[i][j-1][k]) + std::min(1,tempflag[i][j+1][k])
                + std::min(1,tempflag[i][j][k-1]) + std::min(1,tempflag[i][j][k+1]);
        if(inb >= 1) {
          tnv[i][j][k] = (real(std::min(1,tempflag[i-1][j][k])) * nz[i-1][j][k]
                        +  real(std::min(1,tempflag[i+1][j][k])) * nz[i+1][j][k]
                        +  real(std::min(1,tempflag[i][j-1][k])) * nz[i][j-1][k]
                        +  real(std::min(1,tempflag[i][j+1][k])) * nz[i][j+1][k]
                        +  real(std::min(1,tempflag[i][j][k-1])) * nz[i][j][k-1]
                        +  real(std::min(1,tempflag[i][j][k+1])) * nz[i][j][k+1])
                        /real(inb);
          tnl[i][j][k] = 2;  /* tempflag=2 for extrapolated */
        }
      }
    }
    tnv.bnd_update_symmetry(); /* copy on symmetry plane */
    tnl.bnd_update_symmetry(); /* copy on symmetry plane */
    tnv.exchange();
    tnl.exchange();
    nz = tnv;
    for_avijk(phi,i,j,k) {
      tempflag[i][j][k] = int(tnl[i][j][k]);
    }
  }
  for_aijk(i,j,k) {
    tnv[i][j][k] = txv[i][j][k]*nx[i][j][k]
                 + tyv[i][j][k]*ny[i][j][k]
                 + tzv[i][j][k]*nz[i][j][k];
    tnl[i][j][k] = txl[i][j][k]*nx[i][j][k]
                 + tyl[i][j][k]*ny[i][j][k]
                 + tzl[i][j][k]*nz[i][j][k];
  }

#endif

#if 1
  /* extrapolate heat flux, values in brackets indicate
     iflag values for extrapolated cells */

  std::set<int> pos_ext = {1,2};
  std::set<int> neg_ext = {-1,-2};

  if(use_unconditional_extrapolation) {
    pos_ext = {-1,1,2};
    neg_ext = {1,-1,-2};
  }

  #if 1
  topo->extrapolate(txv,Sign::pos(),pos_ext);
  topo->extrapolate(tyv,Sign::pos(),pos_ext);
  topo->extrapolate(tzv,Sign::pos(),pos_ext);
  topo->extrapolate(txl,Sign::neg(),neg_ext);
  topo->extrapolate(tyl,Sign::neg(),neg_ext);
  topo->extrapolate(tzl,Sign::neg(),neg_ext);
  #else
  topo->extrapolate(tnv,Sign::pos(),pos_ext);
  topo->extrapolate(tnl,Sign::neg(),neg_ext);
  #endif
#endif

#if 1
  /* calculate the normal component */
  for_aijk(i,j,k) {
    tnv[i][j][k] = txv[i][j][k]*nx[i][j][k]
                 + tyv[i][j][k]*ny[i][j][k]
                 + tzv[i][j][k]*nz[i][j][k];
    tnl[i][j][k] = txl[i][j][k]*nx[i][j][k]
                 + tyl[i][j][k]*ny[i][j][k]
                 + tzl[i][j][k]*nz[i][j][k];
  }
#endif
  
#if 1
  boil::plot->plot(clr,txv,tyv,tzv,"clr-txv-tyv-tzv",time->current_step());
  boil::plot->plot(clr,txl,tyl,tzl,"clr-txl-tyl-tzl",time->current_step());
  boil::plot->plot(clr,tnl,tnv,"clr-tnl-tnv",time->current_step());
  exit(0);
#endif

  return;
}

