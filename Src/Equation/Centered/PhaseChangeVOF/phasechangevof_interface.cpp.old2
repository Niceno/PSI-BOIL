#include "phasechangevof.h"

/***************************************************************************//**
 *  Checks if the given cell is at (or next to) an interface
******************************************************************************/
bool PhaseChangeVOF::Interface(const int i, const int j, const int k) {
  if (iflag[i][j][k]>0) {
    return true;
  } 
  return false;
}

bool PhaseChangeVOF::Interface(const int i, const int j, const int k,
                               const Comp m, const int dir) {

  if(m == Comp::i())
    return Interface_x(i,j,k,dir); 
  else if(m == Comp::j()) 
    return Interface_y(i,j,k,dir); 
  else
    return Interface_z(i,j,k,dir); 

  return false;
}

/* x-direction */
bool PhaseChangeVOF::Interface_x(const int i, const int j, const int k,
                                 const int dir) {

  int of(1);
  if(dir<0) of = -1;

  if(Interface(i   ,j,k) && Interface1D_x(i   ,j,k, dir)) 
    return true;
  if(Interface(i+of,j,k) && Interface1D_x(i+of,j,k,-dir))
    return true;

  return false;
}

/* y-direction */
bool PhaseChangeVOF::Interface_y(const int i, const int j, const int k,
                                 const int dir) {

  int of(1);
  if(dir<0) of = -1;

  if(Interface(i,j   ,k) && Interface1D_y(i,j   ,k, dir)) 
    return true;
  if(Interface(i,j+of,k) && Interface1D_y(i,j+of,k,-dir))
    return true;

  return false;
}

/* z-direction */
bool PhaseChangeVOF::Interface_z(const int i, const int j, const int k,
                                 const int dir) {

  int of(1);
  if(dir<0) of = -1;

  if(Interface(i,j,k   ) && Interface1D_z(i,j,k   , dir)) 
    return true;
  if(Interface(i,j,k+of) && Interface1D_z(i,j,k+of,-dir))
    return true;

  return false;
}

/* x-direction */
bool PhaseChangeVOF::Interface1D_x(const int i, const int j, const int k,
                                   const int dir) {
  int of(1);
  if(dir<0) of = -1;

  real intx = fsx[i][j][k];
  /* is result inside of cell + in the correct direction? */
  real centrex = phi.xc(i);
  real edgex   = centrex+0.5*phi.dxc(i)*real(of);
  if(dir>0) {
    if(intx>=centrex&&intx<=edgex) {
      return true;
    }
  } else {
    if(intx<=centrex&&intx>=edgex) {
      return true;
    }
  }

  return false;
}

/* y-direction */
bool PhaseChangeVOF::Interface1D_y(const int i, const int j, const int k,
                                   const int dir) {
  int of(1);
  if(dir<0) of = -1;

  real inty = fsy[i][j][k];
  /* is result inside of cell + in the correct direction? */
  real centrey = phi.yc(j);
  real edgey   = centrey+0.5*phi.dyc(j)*real(of);
  if(dir>0) {
    if(inty>=centrey&&inty<=edgey) {
      return true;
    }
  } else {
    if(inty<=centrey&&inty>=edgey) {
      return true;
    }
  }

  return false;
}

/* z-direction */
bool PhaseChangeVOF::Interface1D_z(const int i, const int j, const int k,
                                   const int dir) {
  int of(1);
  if(dir<0) of = -1;

  real intz = fsz[i][j][k];
  /* is result inside of cell + in the correct direction? */
  real centrez = phi.zc(k);
  real edgez   = centrez+0.5*phi.dzc(k)*real(of);
  if(dir>0) {
    if(intz>=centrez&&intz<=edgez) {
      return true;
    }
  } else {
    if(intz<=centrez&&intz>=edgez) {
      return true;
    }
  }

  return false;
}
