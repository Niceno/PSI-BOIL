#include "phasechangevof.h"

/***************************************************************************//**
 *  Checks if the given cell is at (or next to) an interface
******************************************************************************/
bool PhaseChangeVOF::Interface(const int i, const int j, const int k) {
  if (Interface(clr[i][j][k])) {
    return true;
  } 
  return false;
}

bool PhaseChangeVOF::Interface(const real heavi) {
  return heavi > boil::atto && heavi < 1.0-boil::atto;
}

bool PhaseChangeVOF::Interface(const int i, const int j, const int k,
                               const Comp m, const int dir) {

  if(m == Comp::i())
    return Interface_x(i,j,k,dir); 
  else if(m == Comp::j()) 
    return Interface_y(i,j,k,dir); 
  else
    return Interface_z(i,j,k,dir); 

  return false;
}

/* x-direction */
bool PhaseChangeVOF::Interface_x(const int i, const int j, const int k,
                                 const int dir) {

  int of(1);
  if(dir<0) of = -1;

  int flagc(0),flago(0);
  if(Interface(i   ,j,k))
    flagc = 1;
  if(Interface(i+of,j,k))
    flago = 1;

  if(flagc>0) { /* interface exists in centre */
    real intx;
    intx = fsx[i][j][k];
    /* is result inside of cell + in the correct direction? */
    real centrex = phi.xc(i);
    real edgex   = centrex+0.5*phi.dxc(i)*real(of);
    if(dir>0) {
      if(intx>=centrex&&intx<=edgex) {
        return true;
      }
    } else {
      if(intx<=centrex&&intx>=edgex) {
        return true;
      }
    }
  }

  if(flago>0) { /* interface exists in the neighbor */
    real intx;
    intx = fsx[i+of][j][k];
    /* is result inside of cell + in the correct direction? */
    real nbrx    = phi.xc(i+of);
    real centrex = phi.xc(i);
    real edgex   = centrex+0.5*phi.dxc(i+of)*real(of);
    if(dir<0) {
      if(intx>=nbrx&&intx<=edgex) {
        return true;
      }
    } else {
      if(intx<=nbrx&&intx>=edgex) {
        return true;
      }
    }
  }

  return false;
}

/* y-direction */
bool PhaseChangeVOF::Interface_y(const int i, const int j, const int k,
                                 const int dir) {
  int of(1);
  if(dir<0) of = -1;

  int flagc(0),flago(0);
  if(Interface(i,j   ,k))
    flagc = 1;
  if(Interface(i,j+of,k))
    flago = 1;

  if(flagc>0) { /* interface exists in centre */
    real inty;
    inty = fsy[i][j][k];
    /* is result inside of cell + in the correct direction? */
    real centrey = phi.yc(j);
    real edgey   = centrey+0.5*phi.dyc(j)*real(of);
    if(dir>0) {
      if(inty>=centrey&&inty<=edgey) {
        return true;
      }
    } else {
      if(inty<=centrey&&inty>=edgey) {
        return true;
      }
    }
  }

  if(flago>0) { /* interface exists in the neighbor */
    real inty;
    inty = fsy[i][j+of][k];
    /* is result inside of cell + in the correct direction? */
    real nbry    = phi.yc(j+of);
    real centrey = phi.yc(j);
    real edgey   = centrey+0.5*phi.dyc(j+of)*real(of);
    if(dir<0) {
      if(inty>=nbry&&inty<=edgey) {
        return true;
      }
    } else {
      if(inty<=nbry&&inty>=edgey) {
        return true;
      }
    }
  }

  return false;
}

/* z-direction */
bool PhaseChangeVOF::Interface_z(const int i, const int j, const int k,
                             const int dir) {
  int of(1);
  if(dir<0) of = -1;

  int flagc(0),flago(0);
  if(Interface(i,j,k   ))
    flagc = 1;
  if(Interface(i,j,k+of))
    flago = 1;

  if(flagc>0) { /* interface exists in centre */
    real intz;
    intz = fsz[i][j][k];
    /* is result inside of cell + in the correct direction? */
    real centrez = phi.zc(k);
    real edgez   = centrez+0.5*phi.dzc(k)*real(of);
    if(dir>0) {
      if(intz>=centrez&&intz<=edgez) {
        return true;
      }
    } else {
      if(intz<=centrez&&intz>=edgez) {
        return true;
      }
    }
  }

  if(fabs(flago)>0) { /* interface exists in the neighbor */
    real intz;
    intz = fsz[i][j][k+of];
    /* is result inside of cell + in the correct direction? */
    real nbrz    = phi.zc(k+of);
    real centrez = phi.zc(k);
    real edgez   = centrez+0.5*phi.dzc(k+of)*real(of);
    if(dir<0) {
      if(intz>=nbrz&&intz<=edgez) {
        return true;
      }
    } else {
      if(intz<=nbrz&&intz>=edgez) {
        return true;
      }
    }
  }

  return false;
}
