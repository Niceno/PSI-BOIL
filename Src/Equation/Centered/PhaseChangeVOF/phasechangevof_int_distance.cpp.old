#include "phasechangevof.h"

/* 
 * dir > 0: positive direction
 * dir < 0: negative direction
*/

/* x-direction */
real PhaseChangeVOF::distance_x(const int i, const int j, const int k,
                                const int dir, real & tint, 
                                const real clrc, const real clro) {
  int of(1);
  if(dir<0) of = -1;

  int flagc(0),flago(0);
  if(Interface(clrc))
    flagc = (clrc>phisurf) ? 1 : -1;
  if(Interface(clro))
    flago = (clro>phisurf) ? 1 : -1; 

  if(fabs(flagc)>0) { /* interface exists in centre */
    real intx;
    intx = fsx[i][j][k];
    /* is result inside of cell + in the correct direction? */
    real centrex = phi.xc(i);
    real edgex   = centrex+0.5*phi.dxc(i)*real(of);
    if(dir>0) {
      if(intx>=centrex&&intx<=edgex) {
        tint = Tint    (i,j,k);
        return intx-centrex;
      }
    } else {
      if(intx<=centrex&&intx>=edgex) {
        tint = Tint    (i,j,k);
        return centrex-intx;
      } 
    }
  } 

  if(fabs(flago)>0) { /* interface exists in the neighbor */
    real intx;
    intx = fsx[i+of][j][k];
    /* is result inside of cell + in the correct direction? */
    real nbrx    = phi.xc(i+of);
    real centrex = phi.xc(i);
    real edgex   = centrex+0.5*phi.dxc(i+of)*real(of);
    if(dir<0) {
      if(intx>=nbrx&&intx<=edgex) {
        tint = Tint    (i+of,j,k);
        return centrex-intx;
      }
    } else {
      //boil::oout<<intx<<" "<<nbrx<<" "<<edgex<<boil::endl;
      if(intx<=nbrx&&intx>=edgex) {
        tint = Tint    (i+of,j,k);
        return intx-centrex;
      } 
    }
  }

  boil::oout<<"EnthalpyTIF::int_dist_x: Error! Flag inconsistent w/ vol. fraction!\n";
    boil::oout<<i<<" "<<j<<" "<<k<<" "<<dir<<" "<<flagc<<" "<<flago<<" "
              <<clrc<<" "<<clro<<" "<<clr[i][j][k]<<" "<<clr[i+of][j][k]<<boil::endl;
  exit(0);
 
  return 0.0;
}

/* y-direction */
real PhaseChangeVOF::distance_y(const int i, const int j, const int k,
                                const int dir, real & tint, 
                                const real clrc, const real clro) {
  int of(1);
  if(dir<0) of = -1;

  int flagc(0),flago(0);
  if(Interface(clrc))
    flagc = (clrc>phisurf) ? 1 : -1;
  if(Interface(clro))
    flago = (clro>phisurf) ? 1 : -1; 

  if(fabs(flagc)>0) { /* interface exists in centre */
    real inty;
    inty = fsy[i][j][k];
    /* is result inside of cell + in the correct direction? */
    real centrey = phi.yc(j);
    real edgey   = centrey+0.5*phi.dyc(j)*real(of);
    if(dir>0) {
      if(inty>=centrey&&inty<=edgey) {
        tint = Tint    (i,j,k);
        return inty-centrey;
      }
    } else {
      if(inty<=centrey&&inty>=edgey) {
        tint = Tint    (i,j,k);
        return centrey-inty;
      } 
    }
  } 
  
  if(fabs(flago)>0) { /* interface exists in the neighbor */
    real inty;
    inty = fsy[i][j+of][k];
    /* is result inside of cell + in the correct direction? */
    real nbry    = phi.yc(j+of);
    real centrey = phi.yc(j);
    real edgey   = centrey+0.5*phi.dyc(j+of)*real(of);
    if(dir<0) {
      if(inty>=nbry&&inty<=edgey) {
        tint = Tint    (i,j+of,k);
        return centrey-inty;
      }
    } else {
      if(inty<=nbry&&inty>=edgey) {
        tint = Tint    (i,j+of,k);
        return inty-centrey;
      } 
    }
  }

  boil::oout<<"EnthalpyTIF::int_dist_y: Error! Flag inconsistent w/ vol. fraction!\n";
  boil::oout<<i<<" "<<j<<" "<<k<<" "<<dir<<" "<<flagc<<" "<<flago<<" "
            <<clrc<<" "<<clro<<" "<<clr[i][j][k]<<" "<<clr[i][j+of][k]<<boil::endl;
  exit(0);
 
  return 0.0;
}

/* z-direction */
real PhaseChangeVOF::distance_z(const int i, const int j, const int k,
                                const int dir, real & tint, 
                                const real clrc, const real clro) {
  int of(1);
  if(dir<0) of = -1;

  int flagc(0),flago(0);
  if(Interface(clrc))
    flagc = (clrc>phisurf) ? 1 : -1;
  if(Interface(clro))
    flago = (clro>phisurf) ? 1 : -1; 

  if(fabs(flagc)>0) { /* interface exists in centre */
    real intz;
    intz = fsz[i][j][k];
    /* is result inside of cell + in the correct direction? */
    real centrez = phi.zc(k);
    real edgez   = centrez+0.5*phi.dzc(k)*real(of);
    if(dir>0) {
      if(intz>=centrez&&intz<=edgez) {
        tint = Tint    (i,j,k);
        return intz-centrez;
      }
    } else {
      if(intz<=centrez&&intz>=edgez) {
        tint = Tint    (i,j,k);
        return centrez-intz;
      } 
    }
  } 
  
  if(fabs(flago)>0) { /* interface exists in the neighbor */
    real intz;
    intz = fsz[i][j][k+of];
    /* is result inside of cell + in the correct direction? */
    real nbrz    = phi.zc(k+of);
    real centrez = phi.zc(k);
    real edgez   = centrez+0.5*phi.dzc(k+of)*real(of);
    if(dir<0) {
      if(intz>=nbrz&&intz<=edgez) {
        tint = Tint    (i,j,k+of);
        return centrez-intz;
      }
    } else {
      if(intz<=nbrz&&intz>=edgez) {
        tint = Tint    (i,j,k+of);
        return intz-centrez;
      } 
    }
  }

  boil::oout<<"EnthalpyTIF::int_dist_z: Error! Flag inconsistent w/ vol. fraction!\n";
  boil::oout<<i<<" "<<j<<" "<<k<<" "<<dir<<" "<<flagc<<" "<<flago<<" "
            <<clrc<<" "<<clro<<" "<<clr[i][j][k]<<" "<<clr[i][j][k+of]<<boil::endl;
  exit(0);
 
  return 0.0;
}

