model_smagorinsky.cpp
5,11d4
< *
< *  optional (only when damping near wall is necessary): dist_max, dist, y_plus
< *  input  c_s: Smagorinsky constant [-]
< *         dist_max: maximum distance where damping effect [m]
< *         dist: distance function [m]
< *  output mu_t: turbulent eddy viscosity [Pa.s] = [kg/(ms)]
< *         y_plus: y_plus computed [-]
13,14c6
< void Model::smagorinsky( const Momentum * mom, Scalar * mu_t, real c_s,
<              const real *dist_max, const Scalar * dist, Scalar * y_plus) const {
---
> void Model::smagorinsky( const Momentum * mom, Scalar * mu_t, real c_s ) const {
19d10
<   const Body   & ibody =   mom->domain()->ibody(); 
22,24d12
<   if (y_plus) *y_plus=0.0;
<   real damp_sum = 0.0;
<   int  damp_n = 0;
38,57d25
<     /*-----------------------------------------------------------------------+
<     |  damping function near wall: Cs = Cs * sqrt(1.0 - exp(-(yplus/25)^3))  |
<     +-----------------------------------------------------------------------*/
<     real damp = 1.0;
<     if (dist) {
<       if( ibody.on(i,j,k) ) {
<         if ((*dist)[i][j][k] < *dist_max) {
<           //std::cout<<"smagorinsky:i,j,k= "<<i<<" "<<j<<" "<<k<<" " 
<           //         <<(*dist)[i][j][k]<<" "<<damp_n<<"\n";
<           real tx, ty, tz, tau_w, y_pl;
<           wall_function( uvw, fluid, * dist, & tau_w, & y_pl,
<                          i, j, k, &tx, &ty, &tz );
<           if (y_plus) (*y_plus)[i][j][k] = y_pl;
<           damp = sqrt(1.0 - exp(-pow(y_pl/25.0,3.0)));
<           damp_sum += damp;
<           damp_n++;
<         }
<       }
<     }
< 
61,62c29,63
<     real cs_damp = c_s * damp;
<     (*mu_t)[i][j][k] = fluid.rho(i,j,k) * pow((cs_damp*delta),2.0)*shear; 
---
>     (*mu_t)[i][j][k] = fluid.rho(i,j,k) * pow((c_s*delta),2.0)*shear; 
>   }
> 
>   /*---------------------------------------------------+
>   |  eliminate excessive viscosity close to the wall.  |
>   |  it will be handled by wall function in any case.  |
>   +---------------------------------------------------*/
>   if( uvw.bc(Comp::u()).type_here( Dir::imin(), BndType::wall()) ) {
>     const int i=mu_t->si();
>     for_vjk( (*mu_t),j,k ) (*mu_t)[i][j][k] = (*mu_t)[i+1][j][k];
>   }
> 
>   if( uvw.bc(Comp::u()).type_here( Dir::imax(), BndType::wall()) ) {
>     const int i=mu_t->ei();
>     for_vjk( (*mu_t),j,k ) (*mu_t)[i][j][k] = (*mu_t)[i-1][j][k];
>   }
> 
>   if( uvw.bc(Comp::u()).type_here( Dir::jmin(), BndType::wall()) ) {
>     const int j=mu_t->sj();
>     for_vik( (*mu_t),i,k ) (*mu_t)[i][j][k] = (*mu_t)[i][j+1][k];
>   }
> 
>   if( uvw.bc(Comp::u()).type_here( Dir::jmax(), BndType::wall()) ) {
>     const int j=mu_t->ej();
>     for_vik( (*mu_t),i,k ) (*mu_t)[i][j][k] = (*mu_t)[i][j-1][k];
>   }
> 
>   if( uvw.bc(Comp::u()).type_here( Dir::kmin(), BndType::wall()) ) {
>     const int k=mu_t->sk();
>     for_vij( (*mu_t),i,j ) (*mu_t)[i][j][k] = (*mu_t)[i][j][k+1];
>   }
> 
>   if( uvw.bc(Comp::u()).type_here( Dir::kmax(), BndType::wall()) ) {
>     const int k=mu_t->ek();
>     for_vij( (*mu_t),i,j ) (*mu_t)[i][j][k] = (*mu_t)[i][j][k-1];
65,68c66,113
<   boil::cart.sum_real(&damp_sum);
<   boil::cart.sum_int(&damp_n);
<   if (damp_n!=0) {
<     boil::oout<<"model_smagorinsky:damp_ave= "<<damp_sum/damp_n<<" "<<damp_n<<"\n";
---
>   /* for immersed boundary */
> #if 0
>   /* take handy aliases */
>   const Body   & ibody =   mom->domain()->ibody(); 
>   if( ibody.ncall() > 0 ) {
>     for(int cc=0; cc<ibody.nccells(); cc++){
>       int i,j,k;
>       ibody.ijk(cc,&i,&j,&k);
> 
>       real sum   = 0.0;
>       int  nwall = 0;
> 
>       if( ibody.off(i-1,j,k) ) {
>         sum += (*mu_t)[i+1][j][k];
>         nwall++;
>       }
>       if( ibody.off(i+1,j,k) ) {
>         sum += (*mu_t)[i-1][j][k];
>         nwall++;
>       }
> 
>       if( ibody.off(i,j-1,k) ) {
>         sum += (*mu_t)[i][j+1][k];
>         nwall++;
>       }
> 
>       if( ibody.off(i,j+1,k) ) {
>         sum += (*mu_t)[i][j-1][k];
>         nwall++;
>       }
> 
>       if( ibody.off(i,j,k-1) ) {
>         sum += (*mu_t)[i][j][k+1];
>         nwall++;
>       }
> 
>       if( ibody.off(i,j,k+1) ) {
>         sum += (*mu_t)[i][j][k-1];
>         nwall++;
>       }
> 
>       if (nwall>=1) {
>         (*mu_t)[i][j][k] = sum/real(nwall);
>       } else {
>         std::cout<<"smagorinsky: nwall=0 at proc= "<<boil::cart.iam()<<" i= "
>                  <<i<<" j= "<<j<<" k= "<<k<<"\n";
>       }
>     }
69a115
> #endif
